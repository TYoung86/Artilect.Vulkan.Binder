<?xml version="1.0" encoding="utf-8"?>
<doc>
  <assembly>
    <name>Vulkan</name>
  </assembly>
  <members>
    <member name="T:VkFramebuffer">
      <summary>Opaque handle to a framebuffer object</summary>
      <remarks>

Render passes operate in conjunction with  framebuffers.
Framebuffers represent a collection of specific memory attachments that a
render pass instance uses.


Framebuffers are represented by <c>VkFramebuffer</c> handles:


<code> VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkFramebuffer) </code>

</remarks>
      <seealso cref="T:IVkCommandBufferInheritanceInfo" />
      <seealso cref="T:IVkRenderPassBeginInfo" />
      <seealso cref="T:vkCreateFramebuffer" />
      <seealso cref="T:vkDestroyFramebuffer" />
    </member>
    <member name="T:VkDescriptorSetLayout">
      <summary>Opaque handle to a descriptor set layout object</summary>
      <remarks>

A descriptor set layout object is defined by an array of zero or more
descriptor bindings.
Each individual descriptor binding is specified by a descriptor type, a
count (array size) of the number of descriptors in the binding, a set of
shader stages that  can access the binding, and (if using immutable
samplers) an array of sampler descriptors.


Descriptor set layout objects are represented by <c>VkDescriptorSetLayout</c>
handles:


<code> VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkDescriptorSetLayout) </code>

</remarks>
      <seealso cref="T:IVkDescriptorSetAllocateInfo" />
      <seealso cref="T:IVkPipelineLayoutCreateInfo" />
      <seealso cref="T:vkCreateDescriptorSetLayout" />
      <seealso cref="T:vkDestroyDescriptorSetLayout" />
    </member>
    <member name="T:VkImageView">
      <summary>Opaque handle to a image view object</summary>
      <remarks>

Image objects are not directly accessed by pipeline shaders for reading or
writing image data.
Instead,  image views representing contiguous ranges of the image
subresources and containing additional metadata are used for that purpose.
Views  must be created on images of compatible types, and  must represent a
valid subset of image subresources.


Image views are represented by <c>VkImageView</c> handles:


<code> VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkImageView) </code>

</remarks>
      <seealso cref="T:VkDescriptorImageInfo" />
      <seealso cref="T:IVkFramebufferCreateInfo" />
      <seealso cref="T:vkCreateImageView" />
      <seealso cref="T:vkDestroyImageView" />
    </member>
    <member name="T:VkObjectTableNVX" />
    <member name="T:VkPipeline">
      <summary>Opaque handle to a pipeline object</summary>
      <remarks>

Compute and graphics pipelines are each represented by <c>VkPipeline</c>
handles:


<code> VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkPipeline) </code>

</remarks>
      <seealso cref="T:IVkComputePipelineCreateInfo" />
      <seealso cref="T:IVkGraphicsPipelineCreateInfo" />
      <seealso cref="T:vkCmdBindPipeline" />
      <seealso cref="T:vkCreateComputePipelines" />
      <seealso cref="T:vkCreateGraphicsPipelines" />
      <seealso cref="T:vkDestroyPipeline" />
    </member>
    <member name="T:VkQueryPool">
      <summary>Opaque handle to a query pool object</summary>
      <remarks>

Queries are managed using  query pool objects.
Each query pool is a collection of a specific number of queries of a
particular type.


Query pools are represented by <c>VkQueryPool</c> handles:


<code> VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkQueryPool) </code>

</remarks>
      <seealso cref="T:vkCmdBeginQuery" />
      <seealso cref="T:vkCmdCopyQueryPoolResults" />
      <seealso cref="T:vkCmdEndQuery" />
      <seealso cref="T:vkCmdResetQueryPool" />
      <seealso cref="T:vkCmdWriteTimestamp" />
      <seealso cref="T:vkCreateQueryPool" />
      <seealso cref="T:vkDestroyQueryPool" />
      <seealso cref="T:vkGetQueryPoolResults" />
    </member>
    <member name="T:VkSwapchainKHR" />
    <member name="T:VkDescriptorSet">
      <summary>Opaque handle to a descriptor set object</summary>
      <remarks>

Descriptor sets are allocated from descriptor pool objects, and are
represented by <c>VkDescriptorSet</c> handles:


<code> VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkDescriptorSet) </code>

</remarks>
      <seealso cref="T:IVkCopyDescriptorSet" />
      <seealso cref="T:IVkWriteDescriptorSet" />
      <seealso cref="T:vkAllocateDescriptorSets" />
      <seealso cref="T:vkCmdBindDescriptorSets" />
      <seealso cref="T:vkFreeDescriptorSets" />
    </member>
    <member name="T:VkDisplayKHR" />
    <member name="T:VkImage">
      <summary>Opaque handle to a image object</summary>
      <remarks>

Images represent multidimensional - up to 3 - arrays of data which  can be
used for various purposes (e.g. attachments, textures), by binding them to a
graphics or compute pipeline via descriptor sets, or by directly specifying
them as parameters to certain commands.


Images are represented by <c>VkImage</c> handles:


<code> VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkImage) </code>

</remarks>
      <seealso cref="T:IVkImageMemoryBarrier" />
      <seealso cref="T:IVkImageViewCreateInfo" />
      <seealso cref="T:IVkSparseImageMemoryBindInfo" />
      <seealso cref="T:IVkSparseImageOpaqueMemoryBindInfo" />
      <seealso cref="T:vkBindImageMemory" />
      <seealso cref="T:vkCmdBlitImage" />
      <seealso cref="T:vkCmdClearColorImage" />
      <seealso cref="T:vkCmdClearDepthStencilImage" />
      <seealso cref="T:vkCmdCopyBufferToImage" />
      <seealso cref="T:vkCmdCopyImage" />
      <seealso cref="T:vkCmdCopyImageToBuffer" />
      <seealso cref="T:vkCmdResolveImage" />
      <seealso cref="T:vkCreateImage" />
      <seealso cref="T:vkDestroyImage" />
      <seealso cref="T:vkGetImageMemoryRequirements" />
      <seealso cref="T:vkGetImageSparseMemoryRequirements" />
      <seealso cref="T:vkGetImageSubresourceLayout" />
    </member>
    <member name="T:VkDescriptorUpdateTemplateKHR" />
    <member name="T:VkFence">
      <summary>Opaque handle to a fence object</summary>
      <remarks>

Fences are a synchronization primitive that  can be used to insert a
dependency from a queue to the host.
Fences have two states - signaled and unsignaled.
A fence  can be signaled as part of the execution of a
<a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#devsandqueues-submission">queue submission</a> command.
Fences  can be unsignaled on the host with <see cref="T:vkResetFences" />.
Fences  can be waited on by the host with the <see cref="T:vkWaitForFences" /> command,
and the current state  can be queried with <see cref="T:vkGetFenceStatus" />.


Fences are represented by <c>VkFence</c> handles:


<code> VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkFence) </code>

</remarks>
      <seealso cref="T:vkCreateFence" />
      <seealso cref="T:vkDestroyFence" />
      <seealso cref="T:vkGetFenceStatus" />
      <seealso cref="T:vkQueueBindSparse" />
      <seealso cref="T:vkQueueSubmit" />
      <seealso cref="T:vkResetFences" />
      <seealso cref="T:vkWaitForFences" />
    </member>
    <member name="T:VkShaderModule">
      <summary>Opaque handle to a shader module object</summary>
      <remarks>

 Shader modules contain  shader code and one or more entry points.
Shaders are selected from a shader module by specifying an entry point as
part of <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#pipelines">pipeline</a> creation.
The stages of a pipeline  can use shaders that come from different modules.
The shader code defining a shader module  must be in the SPIR-V format, as
described by the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#spirvenv">Vulkan Environment for SPIR-V</a> appendix.


Shader modules are represented by <c>VkShaderModule</c> handles:


<code> VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkShaderModule) </code>

</remarks>
      <seealso cref="T:IVkPipelineShaderStageCreateInfo" />
      <seealso cref="T:vkCreateShaderModule" />
      <seealso cref="T:vkDestroyShaderModule" />
    </member>
    <member name="T:VkDeviceMemory">
      <summary>Opaque handle to a device memory object</summary>
      <remarks>

A Vulkan device operates on data in device memory via memory objects that
are represented in the API by a <c>VkDeviceMemory</c> handle.


Memory objects are represented by <c>VkDeviceMemory</c> handles:


<code> VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkDeviceMemory) </code>

</remarks>
      <seealso cref="T:IVkMappedMemoryRange" />
      <seealso cref="T:VkSparseImageMemoryBind" />
      <seealso cref="T:VkSparseMemoryBind" />
      <seealso cref="T:vkAllocateMemory" />
      <seealso cref="T:vkBindBufferMemory" />
      <seealso cref="T:vkBindImageMemory" />
      <seealso cref="T:vkFreeMemory" />
      <seealso cref="T:vkGetDeviceMemoryCommitment" />
      <seealso cref="T:vkMapMemory" />
      <seealso cref="T:vkUnmapMemory" />
    </member>
    <member name="T:VkSurfaceKHR" />
    <member name="T:VkSemaphore">
      <summary>Opaque handle to a semaphore object</summary>
      <remarks>

Semaphores are a synchronization primitive that  can be used to insert a
dependency between batches submitted to queues.
Semaphores have two states - signaled and unsignaled.
The state of a semaphore  can be signaled after execution of a batch of
commands is completed.
A batch  can wait for a semaphore to become signaled before it begins
execution, and the semaphore is also unsignaled before the batch begins
execution.


Semaphores are represented by <c>VkSemaphore</c> handles:


<code> VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkSemaphore) </code>

</remarks>
      <seealso cref="T:IVkBindSparseInfo" />
      <seealso cref="T:IVkSubmitInfo" />
      <seealso cref="T:vkCreateSemaphore" />
      <seealso cref="T:vkDestroySemaphore" />
    </member>
    <member name="T:VkBufferView">
      <summary>Opaque handle to a buffer view object</summary>
      <remarks>

A  buffer view represents a contiguous range of a buffer and a specific
format to be used to interpret the data.
Buffer views are used to enable shaders to access buffer contents
interpreted as formatted data.
In order to create a valid buffer view, the buffer  must have been created
with at least one of the following usage flags:

<list type="bullet"><item><description>
<c>VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT</c>
</description></item><item><description>
<c>VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT</c>
</description></item></list>

Buffer views are represented by <c>VkBufferView</c> handles:


<code> VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkBufferView) </code>

</remarks>
      <seealso cref="T:IVkWriteDescriptorSet" />
      <seealso cref="T:vkCreateBufferView" />
      <seealso cref="T:vkDestroyBufferView" />
    </member>
    <member name="T:VkPipelineCache">
      <summary>Opaque handle to a pipeline cache object</summary>
      <remarks>

Pipeline cache objects allow the result of pipeline construction to be
reused between pipelines and between runs of an application.
Reuse between pipelines is achieved by passing the same pipeline cache
object when creating multiple related pipelines.
Reuse across runs of an application is achieved by retrieving pipeline cache
contents in one run of an application, saving the contents, and using them
to preinitialize a pipeline cache on a subsequent run.
The contents of the pipeline cache objects are managed by the
implementation.
Applications  can manage the host memory consumed by a pipeline cache object
and control the amount of data retrieved from a pipeline cache object.


Pipeline cache objects are represented by <c>VkPipelineCache</c> handles:


<code> VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkPipelineCache) </code>

</remarks>
      <seealso cref="T:vkCreateComputePipelines" />
      <seealso cref="T:vkCreateGraphicsPipelines" />
      <seealso cref="T:vkCreatePipelineCache" />
      <seealso cref="T:vkDestroyPipelineCache" />
      <seealso cref="T:vkGetPipelineCacheData" />
      <seealso cref="T:vkMergePipelineCaches" />
    </member>
    <member name="T:VkDescriptorPool">
      <summary>Opaque handle to a descriptor pool object</summary>
      <remarks>

A  descriptor pool maintains a pool of descriptors, from which descriptor
sets are allocated.
Descriptor pools are externally synchronized, meaning that the application
 must not allocate and/or free descriptor sets from the same pool in
multiple threads simultaneously.


Descriptor pools are represented by <c>VkDescriptorPool</c> handles:


<code> VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkDescriptorPool) </code>

</remarks>
      <seealso cref="T:IVkDescriptorSetAllocateInfo" />
      <seealso cref="T:vkCreateDescriptorPool" />
      <seealso cref="T:vkDestroyDescriptorPool" />
      <seealso cref="T:vkFreeDescriptorSets" />
      <seealso cref="T:vkResetDescriptorPool" />
    </member>
    <member name="T:VkRenderPass">
      <summary>Opaque handle to a render pass object</summary>
      <remarks>

A  render pass represents a collection of attachments, subpasses, and
dependencies between the subpasses, and describes how the attachments are
used over the course of the subpasses.
The use of a render pass in a command buffer is a  render pass instance.


Render passes are represented by <c>VkRenderPass</c> handles:


<code> VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkRenderPass) </code>

</remarks>
      <seealso cref="T:IVkCommandBufferInheritanceInfo" />
      <seealso cref="T:IVkFramebufferCreateInfo" />
      <seealso cref="T:IVkGraphicsPipelineCreateInfo" />
      <seealso cref="T:IVkRenderPassBeginInfo" />
      <seealso cref="T:vkCreateRenderPass" />
      <seealso cref="T:vkDestroyRenderPass" />
      <seealso cref="T:vkGetRenderAreaGranularity" />
    </member>
    <member name="T:VkCommandPool">
      <summary>Opaque handle to a command pool object</summary>
      <remarks>

Command pools are opaque objects that command buffer memory is allocated
from, and which allow the implementation to amortize the cost of resource
creation across multiple command buffers.
Command pools are externally synchronized, meaning that a command pool  must
not be used concurrently in multiple threads.
That includes use via recording commands on any command buffers allocated
from the pool, as well as operations that allocate, free, and reset command
buffers or the pool itself.


Command pools are represented by <c>VkCommandPool</c> handles:


<code> VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkCommandPool) </code>

</remarks>
      <seealso cref="T:IVkCommandBufferAllocateInfo" />
      <seealso cref="T:vkCreateCommandPool" />
      <seealso cref="T:vkDestroyCommandPool" />
      <seealso cref="T:vkFreeCommandBuffers" />
      <seealso cref="T:vkResetCommandPool" />
    </member>
    <member name="T:VkBuffer">
      <summary>Opaque handle to a buffer object</summary>
      <remarks>

Buffers represent linear arrays of data which are used for various purposes
by binding them to a graphics or compute pipeline via descriptor sets or via
certain commands, or by directly specifying them as parameters to certain
commands.


Buffers are represented by <c>VkBuffer</c> handles:


<code> VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkBuffer) </code>

</remarks>
      <seealso cref="T:IVkBufferMemoryBarrier" />
      <seealso cref="T:IVkBufferViewCreateInfo" />
      <seealso cref="T:VkDescriptorBufferInfo" />
      <seealso cref="T:IVkSparseBufferMemoryBindInfo" />
      <seealso cref="T:vkBindBufferMemory" />
      <seealso cref="T:vkCmdBindIndexBuffer" />
      <seealso cref="T:vkCmdBindVertexBuffers" />
      <seealso cref="T:vkCmdCopyBuffer" />
      <seealso cref="T:vkCmdCopyBufferToImage" />
      <seealso cref="T:vkCmdCopyImageToBuffer" />
      <seealso cref="T:vkCmdCopyQueryPoolResults" />
      <seealso cref="T:vkCmdDispatchIndirect" />
      <seealso cref="T:vkCmdDrawIndexedIndirect" />
      <seealso cref="T:vkCmdDrawIndirect" />
      <seealso cref="T:vkCmdFillBuffer" />
      <seealso cref="T:vkCmdUpdateBuffer" />
      <seealso cref="T:vkCreateBuffer" />
      <seealso cref="T:vkDestroyBuffer" />
      <seealso cref="T:vkGetBufferMemoryRequirements" />
    </member>
    <member name="T:VkPipelineLayout">
      <summary>Opaque handle to a pipeline layout object</summary>
      <remarks>

Access to descriptor sets from a pipeline is accomplished through a
 pipeline layout.
Zero or more descriptor set layouts and zero or more push constant ranges
are combined to form a pipeline layout object which describes the complete
set of resources that  can be accessed by a pipeline.
The pipeline layout represents a sequence of descriptor sets with each
having a specific layout.
This sequence of layouts is used to determine the interface between shader
stages and shader resources.
Each pipeline is created using a pipeline layout.


Pipeline layout objects are represented by <c>VkPipelineLayout</c> handles:


<code> VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkPipelineLayout) </code>

</remarks>
      <seealso cref="T:IVkComputePipelineCreateInfo" />
      <seealso cref="T:IVkGraphicsPipelineCreateInfo" />
      <seealso cref="T:vkCmdBindDescriptorSets" />
      <seealso cref="T:vkCmdPushConstants" />
      <seealso cref="T:vkCreatePipelineLayout" />
      <seealso cref="T:vkDestroyPipelineLayout" />
    </member>
    <member name="T:VkEvent">
      <summary>Opaque handle to a event object</summary>
      <remarks>

Events are a synchronization primitive that  can be used to insert a
fine-grained dependency between commands submitted to the same queue, or
between the host and a queue.
Events have two states - signaled and unsignaled.
An application  can signal an event, or unsignal it, on either the host or
the device.
A device  can wait for an event to become signaled before executing further
operations.
No command exists to wait for an event to become signaled on the host, but
the current state of an event  can be queried.


Events are represented by <c>VkEvent</c> handles:


<code> VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkEvent) </code>

</remarks>
      <seealso cref="T:vkCmdResetEvent" />
      <seealso cref="T:vkCmdSetEvent" />
      <seealso cref="T:vkCmdWaitEvents" />
      <seealso cref="T:vkCreateEvent" />
      <seealso cref="T:vkDestroyEvent" />
      <seealso cref="T:vkGetEventStatus" />
      <seealso cref="T:vkResetEvent" />
      <seealso cref="T:vkSetEvent" />
    </member>
    <member name="T:VkDebugReportCallbackEXT" />
    <member name="T:VkDisplayModeKHR" />
    <member name="T:VkSampler">
      <summary>Opaque handle to a sampler object</summary>
      <remarks>

<c>VkSampler</c> objects represent the state of an image sampler which is
used by the implementation to read image data and apply filtering and other
transformations for the shader.


Samplers are represented by <c>VkSampler</c> handles:


<code> VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkSampler) </code>

</remarks>
      <seealso cref="T:VkDescriptorImageInfo" />
      <seealso cref="T:IVkDescriptorSetLayoutBinding" />
      <seealso cref="T:vkCreateSampler" />
      <seealso cref="T:vkDestroySampler" />
    </member>
    <member name="T:VkIndirectCommandsLayoutNVX" />
    <member name="T:vkCmdPushConstants">
      <summary>Update the values of push constants</summary>
      <remarks>


Valid Usage
<list type="bullet"><item><description>
<c>stageFlags</c> must match exactly the shader stages used in
<c>layout</c> for the range specified by <c>offset</c> and <c>size</c>
</description></item><item><description>
<c>offset</c> must be a multiple of <c>4</c>
</description></item><item><description>
<c>size</c> must be a multiple of <c>4</c>
</description></item><item><description>
<c>offset</c> must be less than
<c>VkPhysicalDeviceLimits</c>::<c>maxPushConstantsSize</c>
</description></item><item><description>
<c>size</c> must be less than or equal to
<c>VkPhysicalDeviceLimits</c>::<c>maxPushConstantsSize</c> minus
<c>offset</c>
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>commandBuffer</c> must be a valid <c>VkCommandBuffer</c> handle
</description></item><item><description>
<c>layout</c> must be a valid <c>VkPipelineLayout</c> handle
</description></item><item><description>
<c>stageFlags</c> must be a valid combination of <see cref="T:VkShaderStageFlags" /> values
</description></item><item><description>
<c>stageFlags</c> must not be <c>0</c>
</description></item><item><description>
<c>pValues</c> must be a pointer to an array of <c>size</c> bytes
</description></item><item><description>
<c>commandBuffer</c> must be in the  recording state
</description></item><item><description>
 The <c>VkCommandPool</c> that <c>commandBuffer</c> was allocated from  must support graphics, or compute operations
</description></item><item><description>
<c>size</c> must be greater than <c>0</c>
</description></item><item><description>
 Both of <c>commandBuffer</c>, and <c>layout</c> must have been created, allocated, or retrieved from the same <c>VkDevice</c>
</description></item></list>




Host Synchronization
<list type="bullet"><item><description>
Host access to <c>commandBuffer</c> must  be externally synchronized
</description></item><item><description>
Host access to the <c>VkCommandPool</c> that <c>commandBuffer</c> was allocated from  must be externally synchronized
</description></item></list>




Command Properties
<list type="table">       <listheader><tr><term> Command Buffer Levels </term><term> Render Pass Scope </term><term> Supported Queue Types </term><term> Pipeline Type </term></tr></listheader>
<item><term>
Primary<br />
Secondary
</term><term>
Both
</term><term>
Graphics<br />
compute
</term><term></term></item>
</list>



To update push constants, call:


<code> void vkCmdPushConstants(
    VkCommandBuffer                             commandBuffer,
    VkPipelineLayout                            layout,
    VkShaderStageFlags                          stageFlags,
    uint32_t                                    offset,
    uint32_t                                    size,
    const void*                                 pValues); </code>

</remarks>
      <seealso cref="T:VkCommandBuffer" />
      <seealso cref="T:VkPipelineLayout" />
      <seealso cref="T:VkShaderStageFlags" />
    </member>
    <member name="T:vkCmdSetScissor">
      <summary>Set the dynamic scissor rectangles on a command buffer</summary>
      <remarks>

The scissor rectangles taken from element  i of <c>pScissors</c> replace
the current state for the scissor index  <c>firstScissor</c> +  i,
for  i in  [0, <c>scissorCount</c>).


Each scissor rectangle is described by a <see cref="T:VkRect2D" /> structure, with the
<c>offset.x</c> and <c>offset.y</c> values determining the upper left corner
of the scissor rectangle, and the <c>extent.width</c> and <c>extent.height</c>
values determining the size in pixels.



Valid Usage
<list type="bullet"><item><description>

The currently bound graphics pipeline  must have been created with the
<c>VK_DYNAMIC_STATE_SCISSOR</c> dynamic state enabled
</description></item><item><description>
<c>firstScissor</c> must be less than
<c>VkPhysicalDeviceLimits</c>::<c>maxViewports</c>
</description></item><item><description>

The sum of <c>firstScissor</c> and <c>scissorCount</c> must be between
<c>1</c> and <c>VkPhysicalDeviceLimits</c>::<c>maxViewports</c>, inclusive
</description></item><item><description>

If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-multiViewport">multiple viewports</a> feature is
not enabled, <c>firstScissor</c> must be <c>0</c>
</description></item><item><description>

If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-multiViewport">multiple viewports</a> feature is
not enabled, <c>scissorCount</c> must be <c>1</c>
</description></item><item><description>

The <c>x</c> and <c>y</c> members of <c>offset</c> must be greater than or
equal to <c>0</c>
</description></item><item><description>

Evaluation of  (<c>offset.x</c> +  <c>extent.width</c>) must  not
cause a signed integer addition overflow
</description></item><item><description>

Evaluation of  (<c>offset.y</c> +  <c>extent.height</c>) must 
not cause a signed integer addition overflow
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>commandBuffer</c> must be a valid <c>VkCommandBuffer</c> handle
</description></item><item><description>
<c>pScissors</c> must be a pointer to an array of <c>scissorCount</c><c>VkRect2D</c> structures
</description></item><item><description>
<c>commandBuffer</c> must be in the  recording state
</description></item><item><description>
 The <c>VkCommandPool</c> that <c>commandBuffer</c> was allocated from  must support graphics operations
</description></item><item><description>
<c>scissorCount</c> must be greater than <c>0</c>
</description></item></list>




Host Synchronization
<list type="bullet"><item><description>
Host access to <c>commandBuffer</c> must  be externally synchronized
</description></item><item><description>
Host access to the <c>VkCommandPool</c> that <c>commandBuffer</c> was allocated from  must be externally synchronized
</description></item></list>




Command Properties
<list type="table">       <listheader><tr><term> Command Buffer Levels </term><term> Render Pass Scope </term><term> Supported Queue Types </term><term> Pipeline Type </term></tr></listheader>
<item><term>
Primary<br />
Secondary
</term><term>
Both
</term><term>
Graphics
</term><term></term></item>
</list>



The scissor test determines if a fragment&amp;#8217;s framebuffer coordinates
 (x<sub>f</sub>,y<sub>f</sub>) lie within the scissor rectangle corresponding to the
viewport index (see <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vertexpostproc-viewport">Controlling the Viewport</a>)
used by the primitive that generated the fragment.
If the pipeline state object is created without
<c>VK_DYNAMIC_STATE_SCISSOR</c> enabled then the scissor rectangles are set
by the <see cref="T:IVkPipelineViewportStateCreateInfo" /> state of the pipeline state
object.
Otherwise, to dynamically set the scissor rectangles call:


<code> void vkCmdSetScissor(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    firstScissor,
    uint32_t                                    scissorCount,
    const VkRect2D*                             pScissors); </code>

</remarks>
      <seealso cref="T:VkCommandBuffer" />
      <seealso cref="T:VkRect2D" />
    </member>
    <member name="T:vkDestroyEvent">
      <summary>Destroy an event object</summary>
      <remarks>


Valid Usage
<list type="bullet"><item><description>

All submitted commands that refer to <c>event</c> must  have completed
execution
</description></item><item><description>

If <c>VkAllocationCallbacks</c> were provided when <c>event</c> was
created, a compatible set of callbacks  must be provided here
</description></item><item><description>

If no <c>VkAllocationCallbacks</c> were provided when <c>event</c> was
created, <c>pAllocator</c> must be <c>NULL</c>
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>device</c> must be a valid <c>VkDevice</c> handle
</description></item><item><description>
 If <c>event</c> is not <see cref="!:VK_NULL_HANDLE" />, <c>event</c> must be a valid <c>VkEvent</c> handle
</description></item><item><description>
 If <c>pAllocator</c> is not <c>NULL</c>, <c>pAllocator</c> must be a pointer to a valid <c>VkAllocationCallbacks</c> structure
</description></item><item><description>
 If <c>event</c> is a valid handle, it  must have been created, allocated, or retrieved from <c>device</c>
</description></item></list>




Host Synchronization
<list type="bullet"><item><description>
Host access to <c>event</c> must  be externally synchronized
</description></item></list>




To destroy an event, call:


<code> void vkDestroyEvent(
    VkDevice                                    device,
    VkEvent                                     event,
    const VkAllocationCallbacks*                pAllocator); </code>

</remarks>
      <seealso cref="T:IVkAllocationCallbacks" />
      <seealso cref="T:VkDevice" />
      <seealso cref="T:VkEvent" />
    </member>
    <member name="T:vkDestroyRenderPass">
      <summary>Destroy a render pass object</summary>
      <remarks>


Valid Usage
<list type="bullet"><item><description>

All submitted commands that refer to <c>renderPass</c> must  have
completed execution
</description></item><item><description>

If <c>VkAllocationCallbacks</c> were provided when <c>renderPass</c> was
created, a compatible set of callbacks  must be provided here
</description></item><item><description>

If no <c>VkAllocationCallbacks</c> were provided when <c>renderPass</c>
was created, <c>pAllocator</c> must be <c>NULL</c>
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>device</c> must be a valid <c>VkDevice</c> handle
</description></item><item><description>
 If <c>renderPass</c> is not <see cref="!:VK_NULL_HANDLE" />, <c>renderPass</c> must be a valid <c>VkRenderPass</c> handle
</description></item><item><description>
 If <c>pAllocator</c> is not <c>NULL</c>, <c>pAllocator</c> must be a pointer to a valid <c>VkAllocationCallbacks</c> structure
</description></item><item><description>
 If <c>renderPass</c> is a valid handle, it  must have been created, allocated, or retrieved from <c>device</c>
</description></item></list>




Host Synchronization
<list type="bullet"><item><description>
Host access to <c>renderPass</c> must  be externally synchronized
</description></item></list>




To destroy a render pass, call:


<code> void vkDestroyRenderPass(
    VkDevice                                    device,
    VkRenderPass                                renderPass,
    const VkAllocationCallbacks*                pAllocator); </code>

</remarks>
      <seealso cref="T:IVkAllocationCallbacks" />
      <seealso cref="T:VkDevice" />
      <seealso cref="T:VkRenderPass" />
    </member>
    <member name="T:vkEnumerateDeviceLayerProperties">
      <summary>Returns properties of available physical device layers</summary>
      <remarks>

If <c>pProperties</c> is <c>NULL</c>, then the number of layer properties
available is returned in <c>pPropertyCount</c>.
Otherwise, <c>pPropertyCount</c> must point to a variable set by the user to
the number of elements in the <c>pProperties</c> array, and on return the
variable is overwritten with the number of structures actually written to
<c>pProperties</c>.
If <c>pPropertyCount</c> is less than the number of layer properties
available, at most <c>pPropertyCount</c> structures will be written.
If <c>pPropertyCount</c> is smaller than the number of layers available,
<c>VK_INCOMPLETE</c> will be returned instead of <c>VK_SUCCESS</c>, to
indicate that not all the available layer properties were returned.


The list of layers enumerated by <c>vkEnumerateDeviceLayerProperties</c> must be exactly the sequence of layers enabled for the instance.
The members of <c>VkLayerProperties</c> for each enumerated layer  must be
the same as the properties when the layer was enumerated by
<c>vkEnumerateInstanceLayerProperties</c>.



Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>physicalDevice</c> must be a valid <c>VkPhysicalDevice</c> handle
</description></item><item><description>
<c>pPropertyCount</c> must be a pointer to a <c>uint32_t</c> value
</description></item><item><description>
 If the value referenced by <c>pPropertyCount</c> is not <c>0</c>, and <c>pProperties</c> is not <c>NULL</c>, <c>pProperties</c> must be a pointer to an array of <c>pPropertyCount</c><c>VkLayerProperties</c> structures
</description></item></list>




Return Codes
<dl><dt>On success, this command returns</dt><dd>
<list type="bullet"><item><description>
<c>VK_SUCCESS</c>
</description></item><item><description>
<c>VK_INCOMPLETE</c>
</description></item></list>
</dd><dt>On failure, this command returns</dt><dd>
<list type="bullet"><item><description>
<c>VK_ERROR_OUT_OF_HOST_MEMORY</c>
</description></item><item><description>
<c>VK_ERROR_OUT_OF_DEVICE_MEMORY</c>
</description></item></list>
</dd></dl>




To enumerate device layers, call:


<code> VkResult vkEnumerateDeviceLayerProperties(
    VkPhysicalDevice                            physicalDevice,
    uint32_t*                                   pPropertyCount,
    VkLayerProperties*                          pProperties); </code>

</remarks>
      <seealso cref="T:VkLayerProperties" />
      <seealso cref="T:VkPhysicalDevice" />
    </member>
    <member name="T:PFN_vkVoidFunction">
      <summary>Dummy function pointer type returned by queries</summary>
      <remarks>

The definition of <see cref="T:PFN_vkVoidFunction" /> is:


<code> typedef void (VKAPI_PTR *PFN_vkVoidFunction)(void); </code>

</remarks>
      <seealso cref="T:vkGetDeviceProcAddr" />
      <seealso cref="T:vkGetInstanceProcAddr" />
    </member>
    <member name="T:vkCreateDescriptorUpdateTemplateKHR" />
    <member name="T:IVkSamplerReductionModeCreateInfoEXT" />
    <member name="T:VkSamplerReductionModeCreateInfoEXT32">
      <summary>See: <see cref="T:IVkSamplerReductionModeCreateInfoEXT" /></summary>
      <seealso cref="T:IVkSamplerReductionModeCreateInfoEXT" />
    </member>
    <member name="T:VkSamplerReductionModeCreateInfoEXT64">
      <summary>See: <see cref="T:IVkSamplerReductionModeCreateInfoEXT" /></summary>
      <seealso cref="T:IVkSamplerReductionModeCreateInfoEXT" />
    </member>
    <member name="T:IVkCommandBufferAllocateInfo">
      <summary>Structure specifying the allocation parameters for command buffer object</summary>
      <remarks>


Valid Usage
<list type="bullet"><item><description>
<c>commandBufferCount</c> must be greater than <c>0</c>
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>sType</c> must be <c>VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO</c>
</description></item><item><description>
<c>pNext</c> must be <c>NULL</c>
</description></item><item><description>
<c>commandPool</c> must be a valid <c>VkCommandPool</c> handle
</description></item><item><description>
<c>level</c> must be a valid <see cref="T:VkCommandBufferLevel" /> value
</description></item></list>




The <c>VkCommandBufferAllocateInfo</c> structure is defined as:


<code> typedef struct VkCommandBufferAllocateInfo {
    VkStructureType         sType;
    const void*             pNext;
    VkCommandPool           commandPool;
    VkCommandBufferLevel    level;
    uint32_t                commandBufferCount;
} VkCommandBufferAllocateInfo; </code>

</remarks>
      <seealso cref="T:VkCommandBufferLevel" />
      <seealso cref="T:VkCommandPool" />
      <seealso cref="T:VkStructureType" />
      <seealso cref="T:vkAllocateCommandBuffers" />
    </member>
    <member name="T:VkCommandBufferAllocateInfo32">
      <summary>See: <see cref="T:IVkCommandBufferAllocateInfo" /></summary>
      <seealso cref="T:IVkCommandBufferAllocateInfo" />
    </member>
    <member name="T:VkCommandBufferAllocateInfo64">
      <summary>See: <see cref="T:IVkCommandBufferAllocateInfo" /></summary>
      <seealso cref="T:IVkCommandBufferAllocateInfo" />
    </member>
    <member name="T:IVkPhysicalDeviceExternalBufferInfoKHX" />
    <member name="T:VkPhysicalDeviceExternalBufferInfoKHX32">
      <summary>See: <see cref="T:IVkPhysicalDeviceExternalBufferInfoKHX" /></summary>
      <seealso cref="T:IVkPhysicalDeviceExternalBufferInfoKHX" />
    </member>
    <member name="T:VkPhysicalDeviceExternalBufferInfoKHX64">
      <summary>See: <see cref="T:IVkPhysicalDeviceExternalBufferInfoKHX" /></summary>
      <seealso cref="T:IVkPhysicalDeviceExternalBufferInfoKHX" />
    </member>
    <member name="T:vkGetPipelineCacheData">
      <summary>Get the data store from a pipeline cache</summary>
      <remarks>

If <c>pData</c> is <c>NULL</c>, then the maximum size of the data that  can be
retrieved from the pipeline cache, in bytes, is returned in <c>pDataSize</c>.
Otherwise, <c>pDataSize</c> must point to a variable set by the user to the
size of the buffer, in bytes, pointed to by <c>pData</c>, and on return the
variable is overwritten with the amount of data actually written to
<c>pData</c>.


If <c>pDataSize</c> is less than the maximum size that  can be retrieved by
the pipeline cache, at most <c>pDataSize</c> bytes will be written to
<c>pData</c>, and <c>vkGetPipelineCacheData</c> will return
<c>VK_INCOMPLETE</c>.
Any data written to <c>pData</c> is valid and  can be provided as the
<c>pInitialData</c> member of the <c>VkPipelineCacheCreateInfo</c> structure
passed to <c>vkCreatePipelineCache</c>.


Two calls to <c>vkGetPipelineCacheData</c> with the same parameters  must
retrieve the same data unless a command that modifies the contents of the
cache is called between them.


Applications  can store the data retrieved from the pipeline cache, and use
these data, possibly in a future run of the application, to populate new
pipeline cache objects.
The results of pipeline compiles, however,  may depend on the vendor ID,
device ID, driver version, and other details of the device.
To enable applications to detect when previously retrieved data is
incompatible with the device, the initial bytes written to <c>pData</c> must 
be a header consisting of the following members:

<para>Table 1. Layout for pipeline cache header version <c>VK_PIPELINE_CACHE_HEADER_VERSION_ONE</c></para><list type="table">      <listheader><tr><term>Offset</term><term>Size</term><term>Meaning</term></tr></listheader>
<item><term>
0
</term><term>
4
</term><term>
length in bytes of the entire pipeline cache header
                             written as a stream of bytes, with the least
                             significant byte first
</term></item><item><term>
4
</term><term>
4
</term><term>
a <see cref="T:VkPipelineCacheHeaderVersion" /> value
                             written as a stream of bytes, with the least
                             significant byte first
</term></item><item><term>
8
</term><term>
4
</term><term>
a vendor ID equal to
                             <c>VkPhysicalDeviceProperties</c>::<c>vendorID</c>
                             written as a stream of bytes, with the least
                             significant byte first
</term></item><item><term>
12
</term><term>
4
</term><term>
a device ID equal to
                             <c>VkPhysicalDeviceProperties</c>::<c>deviceID</c>
                             written as a stream of bytes, with the least
                             significant byte first
</term></item><item><term>
16
</term><term>
<c>VK_UUID_SIZE</c>
</term><term>
a pipeline cache ID equal to
                             <c>VkPhysicalDeviceProperties</c>::<c>pipelineCacheUUID</c>
</term></item>
</list>

The first four bytes encode the length of the entire pipeline header, in
bytes.
This value includes all fields in the header including the pipeline cache
version field and the size of the length field.


The next four bytes encode the pipeline cache version, as described for
<see cref="T:VkPipelineCacheHeaderVersion" />.
A consumer of the pipeline cache  should use the cache version to interpret
the remainder of the cache header.


If <c>pDataSize</c> is less than what is necessary to store this header,
nothing will be written to <c>pData</c> and zero will be written to
<c>pDataSize</c>.



Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>device</c> must be a valid <c>VkDevice</c> handle
</description></item><item><description>
<c>pipelineCache</c> must be a valid <c>VkPipelineCache</c> handle
</description></item><item><description>
<c>pDataSize</c> must be a pointer to a <c>size_t</c> value
</description></item><item><description>
 If the value referenced by <c>pDataSize</c> is not <c>0</c>, and <c>pData</c> is not <c>NULL</c>, <c>pData</c> must be a pointer to an array of <c>pDataSize</c> bytes
</description></item><item><description>
<c>pipelineCache</c> must have been created, allocated, or retrieved from <c>device</c>
</description></item></list>




Return Codes
<dl><dt>On success, this command returns</dt><dd>
<list type="bullet"><item><description>
<c>VK_SUCCESS</c>
</description></item><item><description>
<c>VK_INCOMPLETE</c>
</description></item></list>
</dd><dt>On failure, this command returns</dt><dd>
<list type="bullet"><item><description>
<c>VK_ERROR_OUT_OF_HOST_MEMORY</c>
</description></item><item><description>
<c>VK_ERROR_OUT_OF_DEVICE_MEMORY</c>
</description></item></list>
</dd></dl>




Data  can be retrieved from a pipeline cache object using the command:


<code> VkResult vkGetPipelineCacheData(
    VkDevice                                    device,
    VkPipelineCache                             pipelineCache,
    size_t*                                     pDataSize,
    void*                                       pData); </code>

</remarks>
      <seealso cref="T:VkDevice" />
      <seealso cref="T:VkPipelineCache" />
    </member>
    <member name="T:vkUnregisterObjectsNVX" />
    <member name="T:IVkShaderModuleCreateInfo">
      <summary>Structure specifying parameters of a newly created shader module</summary>
      <remarks>


Valid Usage
<list type="bullet"><item><description>
<c>codeSize</c> must  be greater than 0
</description></item><item><description>
<c>codeSize</c> must  be a multiple of 4
</description></item><item><description>
<c>pCode</c> must point to valid SPIR-V code, formatted and packed as
described by the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#spirv-spec">Khronos SPIR-V Specification</a>
</description></item><item><description>
<c>pCode</c> must adhere to the validation rules described by the
<a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#spirvenv-module-validation">Validation Rules within a Module</a> section
of the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#spirvenv-capabilities">SPIR-V Environment</a> appendix
</description></item><item><description>
<c>pCode</c> must declare the <c>Shader</c> capability for SPIR-V code
</description></item><item><description>
<c>pCode</c> must not declare any capability that is not supported by
the API, as described by the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#spirvenv-module-validation">Capabilities</a> section of the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#spirvenv-capabilities">SPIR-V
Environment</a> appendix
</description></item><item><description>

If <c>pCode</c> declares any of the capabilities that are listed as not
required by the implementation, the relevant feature  must be enabled,
as listed in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#spirvenv-capabilities-table">SPIR-V Environment</a>
appendix
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>sType</c> must be <c>VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO</c>
</description></item><item><description>
<c>pNext</c> must be <c>NULL</c>
</description></item><item><description>
<c>flags</c> must be <c>0</c>
</description></item><item><description>
<c>pCode</c> must be a pointer to an array of \(codeSize \over 4\) <c>uint32_t</c> values
</description></item></list>




The <c>VkShaderModuleCreateInfo</c> structure is defined as:


<code> typedef struct VkShaderModuleCreateInfo {
    VkStructureType              sType;
    const void*                  pNext;
    VkShaderModuleCreateFlags    flags;
    size_t                       codeSize;
    const uint32_t*              pCode;
} VkShaderModuleCreateInfo; </code>

</remarks>
      <seealso cref="T:VkShaderModuleCreateFlags" />
      <seealso cref="T:VkStructureType" />
      <seealso cref="T:vkCreateShaderModule" />
    </member>
    <member name="T:VkShaderModuleCreateInfo32">
      <summary>See: <see cref="T:IVkShaderModuleCreateInfo" /></summary>
      <seealso cref="T:IVkShaderModuleCreateInfo" />
    </member>
    <member name="T:VkShaderModuleCreateInfo64">
      <summary>See: <see cref="T:IVkShaderModuleCreateInfo" /></summary>
      <seealso cref="T:IVkShaderModuleCreateInfo" />
    </member>
    <member name="T:vkCmdSetStencilReference">
      <summary>Set the stencil reference dynamic state</summary>
      <remarks>


Valid Usage
<list type="bullet"><item><description>

The currently bound graphics pipeline  must have been created with the
<c>VK_DYNAMIC_STATE_STENCIL_REFERENCE</c> dynamic state enabled
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>commandBuffer</c> must be a valid <c>VkCommandBuffer</c> handle
</description></item><item><description>
<c>faceMask</c> must be a valid combination of <see cref="T:VkStencilFaceFlags" /> values
</description></item><item><description>
<c>faceMask</c> must not be <c>0</c>
</description></item><item><description>
<c>commandBuffer</c> must be in the  recording state
</description></item><item><description>
 The <c>VkCommandPool</c> that <c>commandBuffer</c> was allocated from  must support graphics operations
</description></item></list>




Host Synchronization
<list type="bullet"><item><description>
Host access to <c>commandBuffer</c> must  be externally synchronized
</description></item><item><description>
Host access to the <c>VkCommandPool</c> that <c>commandBuffer</c> was allocated from  must be externally synchronized
</description></item></list>




Command Properties
<list type="table">       <listheader><tr><term> Command Buffer Levels </term><term> Render Pass Scope </term><term> Supported Queue Types </term><term> Pipeline Type </term></tr></listheader>
<item><term>
Primary<br />
Secondary
</term><term>
Both
</term><term>
Graphics
</term><term></term></item>
</list>



If the pipeline state object is created with the
<c>VK_DYNAMIC_STATE_STENCIL_REFERENCE</c> dynamic state enabled, then to
dynamically set the stencil reference value call:


<code> void vkCmdSetStencilReference(
    VkCommandBuffer                             commandBuffer,
    VkStencilFaceFlags                          faceMask,
    uint32_t                                    reference); </code>

</remarks>
      <seealso cref="T:VkCommandBuffer" />
      <seealso cref="T:VkStencilFaceFlags" />
    </member>
    <member name="T:vkCmdDebugMarkerBeginEXT" />
    <member name="T:vkCmdBindDescriptorSets">
      <summary>Binds descriptor sets to a command buffer</summary>
      <remarks>

<c>vkCmdBindDescriptorSets</c> causes the sets numbered [<c>firstSet</c>..
<c>firstSet</c>+<c>descriptorSetCount</c>-1] to use the bindings stored in
<c>pDescriptorSets</c>[0..<c>descriptorSetCount</c>-1] for subsequent
rendering commands (either compute or graphics, according to the
<c>pipelineBindPoint</c>).
Any bindings that were previously applied via these sets are no longer
valid.


Once bound, a descriptor set affects rendering of subsequent graphics or
compute commands in the command buffer until a different set is bound to the
same set number, or else until the set is disturbed as described in
<a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#descriptorsets-compatibility">Pipeline Layout Compatibility</a>.


A compatible descriptor set  must be bound for all set numbers that any
shaders in a pipeline access, at the time that a draw or dispatch command is
recorded to execute using that pipeline.
However, if none of the shaders in a pipeline statically use any bindings
with a particular set number, then no descriptor set need be bound for that
set number, even if the pipeline layout includes a non-trivial descriptor
set layout for that set number.


If any of the sets being bound include dynamic uniform or storage buffers,
then <c>pDynamicOffsets</c> includes one element for each array element in
each dynamic descriptor type binding in each set.
Values are taken from <c>pDynamicOffsets</c> in an order such that all
entries for set N come before set N+1; within a set, entries are ordered by
the binding numbers in the descriptor set layouts; and within a binding
array, elements are in order.
<c>dynamicOffsetCount</c> must  equal the total number of dynamic descriptors
in the sets being bound.


The effective offset used for dynamic uniform and storage buffer bindings is
the sum of the relative offset taken from <c>pDynamicOffsets</c>, and the
base address of the buffer plus base offset in the descriptor set.
The length of the dynamic uniform and storage buffer bindings is the buffer
range as specified in the descriptor set.


Each of the <c>pDescriptorSets</c> must be compatible with the pipeline
layout specified by <c>layout</c>.
The layout used to program the bindings  must also be compatible with the
pipeline used in subsequent graphics or compute commands, as defined in the
<a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#descriptorsets-compatibility">Pipeline Layout Compatibility</a> section.


The descriptor set contents bound by a call to <c>vkCmdBindDescriptorSets</c> may be consumed during host execution of the command, or during shader
execution of the resulting draws, or any time in between.
Thus, the contents  must not be altered (overwritten by an update command,
or freed) between when the command is recorded and when the command
completes executing on the queue.
The contents of <c>pDynamicOffsets</c> are consumed immediately during
execution of <c>vkCmdBindDescriptorSets</c>.
Once all pending uses have completed, it is legal to update and reuse a
descriptor set.



Valid Usage
<list type="bullet"><item><description>

Any given element of <c>pDescriptorSets</c> must have been allocated
with a <c>VkDescriptorSetLayout</c> that matches (is the same as, or
identically defined as) the <c>VkDescriptorSetLayout</c> at set  n in
<c>layout</c>, where  n is the sum of <c>firstSet</c> and the index into
<c>pDescriptorSets</c>
</description></item><item><description>
<c>dynamicOffsetCount</c> must be equal to the total number of dynamic
descriptors in <c>pDescriptorSets</c>
</description></item><item><description>

The sum of <c>firstSet</c> and <c>descriptorSetCount</c> must be less
than or equal to <c>VkPipelineLayoutCreateInfo</c>::<c>setLayoutCount</c>
provided when <c>layout</c> was created
</description></item><item><description>
<c>pipelineBindPoint</c> must be supported by the <c>commandBuffer</c>&amp;#8217;s
parent <c>VkCommandPool</c>&amp;#8217;s queue family
</description></item><item><description>

Any given element of <c>pDynamicOffsets</c> must  satisfy the required
alignment for the corresponding descriptor binding&amp;#8217;s descriptor type
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>commandBuffer</c> must be a valid <c>VkCommandBuffer</c> handle
</description></item><item><description>
<c>pipelineBindPoint</c> must be a valid <see cref="T:VkPipelineBindPoint" /> value
</description></item><item><description>
<c>layout</c> must be a valid <c>VkPipelineLayout</c> handle
</description></item><item><description>
<c>pDescriptorSets</c> must be a pointer to an array of <c>descriptorSetCount</c> valid <c>VkDescriptorSet</c> handles
</description></item><item><description>
 If <c>dynamicOffsetCount</c> is not <c>0</c>, <c>pDynamicOffsets</c> must be a pointer to an array of <c>dynamicOffsetCount</c><c>uint32_t</c> values
</description></item><item><description>
<c>commandBuffer</c> must be in the  recording state
</description></item><item><description>
 The <c>VkCommandPool</c> that <c>commandBuffer</c> was allocated from  must support graphics, or compute operations
</description></item><item><description>
<c>descriptorSetCount</c> must be greater than <c>0</c>
</description></item><item><description>
 Each of <c>commandBuffer</c>, <c>layout</c>, and the elements of <c>pDescriptorSets</c> must have been created, allocated, or retrieved from the same <c>VkDevice</c>
</description></item></list>




Host Synchronization
<list type="bullet"><item><description>
Host access to <c>commandBuffer</c> must  be externally synchronized
</description></item><item><description>
Host access to the <c>VkCommandPool</c> that <c>commandBuffer</c> was allocated from  must be externally synchronized
</description></item></list>




Command Properties
<list type="table">       <listheader><tr><term> Command Buffer Levels </term><term> Render Pass Scope </term><term> Supported Queue Types </term><term> Pipeline Type </term></tr></listheader>
<item><term>
Primary<br />
Secondary
</term><term>
Both
</term><term>
Graphics<br />
compute
</term><term></term></item>
</list>



To bind one or more descriptor sets to a command buffer, call:


<code> void vkCmdBindDescriptorSets(
    VkCommandBuffer                             commandBuffer,
    VkPipelineBindPoint                         pipelineBindPoint,
    VkPipelineLayout                            layout,
    uint32_t                                    firstSet,
    uint32_t                                    descriptorSetCount,
    const VkDescriptorSet*                      pDescriptorSets,
    uint32_t                                    dynamicOffsetCount,
    const uint32_t*                             pDynamicOffsets); </code>

</remarks>
      <seealso cref="T:VkCommandBuffer" />
      <seealso cref="T:VkDescriptorSet" />
      <seealso cref="T:VkPipelineBindPoint" />
      <seealso cref="T:VkPipelineLayout" />
    </member>
    <member name="T:vkDestroyImage">
      <summary>Destroy an image object</summary>
      <remarks>


Valid Usage
<list type="bullet"><item><description>

All submitted commands that refer to <c>image</c>, either directly or via
a <c>VkImageView</c>,  must have completed execution
</description></item><item><description>

If <c>VkAllocationCallbacks</c> were provided when <c>image</c> was
created, a compatible set of callbacks  must be provided here
</description></item><item><description>

If no <c>VkAllocationCallbacks</c> were provided when <c>image</c> was
created, <c>pAllocator</c> must be <c>NULL</c>
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>device</c> must be a valid <c>VkDevice</c> handle
</description></item><item><description>
 If <c>image</c> is not <see cref="!:VK_NULL_HANDLE" />, <c>image</c> must be a valid <c>VkImage</c> handle
</description></item><item><description>
 If <c>pAllocator</c> is not <c>NULL</c>, <c>pAllocator</c> must be a pointer to a valid <c>VkAllocationCallbacks</c> structure
</description></item><item><description>
 If <c>image</c> is a valid handle, it  must have been created, allocated, or retrieved from <c>device</c>
</description></item></list>




Host Synchronization
<list type="bullet"><item><description>
Host access to <c>image</c> must  be externally synchronized
</description></item></list>




To destroy an image, call:


<code> void vkDestroyImage(
    VkDevice                                    device,
    VkImage                                     image,
    const VkAllocationCallbacks*                pAllocator); </code>

</remarks>
      <seealso cref="T:IVkAllocationCallbacks" />
      <seealso cref="T:VkDevice" />
      <seealso cref="T:VkImage" />
    </member>
    <member name="T:IVkPipelineViewportSwizzleStateCreateInfoNV" />
    <member name="T:VkPipelineViewportSwizzleStateCreateInfoNV32">
      <summary>See: <see cref="T:IVkPipelineViewportSwizzleStateCreateInfoNV" /></summary>
      <seealso cref="T:IVkPipelineViewportSwizzleStateCreateInfoNV" />
    </member>
    <member name="T:VkPipelineViewportSwizzleStateCreateInfoNV64">
      <summary>See: <see cref="T:IVkPipelineViewportSwizzleStateCreateInfoNV" /></summary>
      <seealso cref="T:IVkPipelineViewportSwizzleStateCreateInfoNV" />
    </member>
    <member name="T:vkGetPhysicalDeviceMemoryProperties">
      <summary>Reports memory information for the specified physical device</summary>
      <remarks>


Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>physicalDevice</c> must be a valid <c>VkPhysicalDevice</c> handle
</description></item><item><description>
<c>pMemoryProperties</c> must be a pointer to a <c>VkPhysicalDeviceMemoryProperties</c> structure
</description></item></list>




To query memory properties, call:


<code> void vkGetPhysicalDeviceMemoryProperties(
    VkPhysicalDevice                            physicalDevice,
    VkPhysicalDeviceMemoryProperties*           pMemoryProperties); </code>

</remarks>
      <seealso cref="T:VkPhysicalDevice" />
      <seealso cref="T:VkPhysicalDeviceMemoryProperties" />
    </member>
    <member name="T:VkPhysicalDeviceSparseProperties">
      <summary>Structure specifying physical device sparse memory properties</summary>
      <remarks>

The <c>VkPhysicalDeviceSparseProperties</c> structure is defined as:


<code> typedef struct VkPhysicalDeviceSparseProperties {
    VkBool32    residencyStandard2DBlockShape;
    VkBool32    residencyStandard2DMultisampleBlockShape;
    VkBool32    residencyStandard3DBlockShape;
    VkBool32    residencyAlignedMipSize;
    VkBool32    residencyNonResidentStrict;
} VkPhysicalDeviceSparseProperties; </code>

</remarks>
      <seealso cref="T:IVkPhysicalDeviceProperties" />
    </member>
    <member name="T:vkCreateShaderModule">
      <summary>Creates a new shader module object</summary>
      <remarks>

Once a shader module has been created, any entry points it contains  can be
used in pipeline shader stages as described in <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#pipelines-compute">Compute
Pipelines</a> and <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#pipelines-graphics">Graphics Pipelines</a>.



Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>device</c> must be a valid <c>VkDevice</c> handle
</description></item><item><description>
<c>pCreateInfo</c> must be a pointer to a valid <c>VkShaderModuleCreateInfo</c> structure
</description></item><item><description>
 If <c>pAllocator</c> is not <c>NULL</c>, <c>pAllocator</c> must be a pointer to a valid <c>VkAllocationCallbacks</c> structure
</description></item><item><description>
<c>pShaderModule</c> must be a pointer to a <c>VkShaderModule</c> handle
</description></item></list>




Return Codes
<dl><dt>On success, this command returns</dt><dd>
<list type="bullet"><item><description>
<c>VK_SUCCESS</c>
</description></item></list>
</dd><dt>On failure, this command returns</dt><dd>
<list type="bullet"><item><description>
<c>VK_ERROR_OUT_OF_HOST_MEMORY</c>
</description></item><item><description>
<c>VK_ERROR_OUT_OF_DEVICE_MEMORY</c>
</description></item></list>
</dd></dl>




To create a shader module, call:


<code> VkResult vkCreateShaderModule(
    VkDevice                                    device,
    const VkShaderModuleCreateInfo*             pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkShaderModule*                             pShaderModule); </code>

</remarks>
      <seealso cref="T:IVkAllocationCallbacks" />
      <seealso cref="T:VkDevice" />
      <seealso cref="T:VkShaderModule" />
      <seealso cref="T:IVkShaderModuleCreateInfo" />
    </member>
    <member name="T:vkCreateGraphicsPipelines">
      <summary>Create graphics pipelines</summary>
      <remarks>

The <see cref="T:IVkGraphicsPipelineCreateInfo" /> structure includes an array of shader
create info structures containing all the desired active shader stages, as
well as creation info to define all relevant fixed-function stages, and a
pipeline layout.



Valid Usage
<list type="bullet"><item><description>

If the <c>flags</c> member of any given element of <c>pCreateInfos</c>
contains the <c>VK_PIPELINE_CREATE_DERIVATIVE_BIT</c> flag, and the
<c>basePipelineIndex</c> member of that same element is not <c>-1</c>,
<c>basePipelineIndex</c> must be less than the index into
<c>pCreateInfos</c> that corresponds to that element
</description></item><item><description>

If the <c>flags</c> member of any given element of <c>pCreateInfos</c>
contains the <c>VK_PIPELINE_CREATE_DERIVATIVE_BIT</c> flag, the base
pipeline  must have been created with the
<c>VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT</c> flag set
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>device</c> must be a valid <c>VkDevice</c> handle
</description></item><item><description>
 If <c>pipelineCache</c> is not <see cref="!:VK_NULL_HANDLE" />, <c>pipelineCache</c> must be a valid <c>VkPipelineCache</c> handle
</description></item><item><description>
<c>pCreateInfos</c> must be a pointer to an array of <c>createInfoCount</c> valid <c>VkGraphicsPipelineCreateInfo</c> structures
</description></item><item><description>
 If <c>pAllocator</c> is not <c>NULL</c>, <c>pAllocator</c> must be a pointer to a valid <c>VkAllocationCallbacks</c> structure
</description></item><item><description>
<c>pPipelines</c> must be a pointer to an array of <c>createInfoCount</c><c>VkPipeline</c> handles
</description></item><item><description>
<c>createInfoCount</c> must be greater than <c>0</c>
</description></item><item><description>
 If <c>pipelineCache</c> is a valid handle, it  must have been created, allocated, or retrieved from <c>device</c>
</description></item></list>




Return Codes
<dl><dt>On success, this command returns</dt><dd>
<list type="bullet"><item><description>
<c>VK_SUCCESS</c>
</description></item></list>
</dd><dt>On failure, this command returns</dt><dd>
<list type="bullet"><item><description>
<c>VK_ERROR_OUT_OF_HOST_MEMORY</c>
</description></item><item><description>
<c>VK_ERROR_OUT_OF_DEVICE_MEMORY</c>
</description></item></list>
</dd></dl>




To create graphics pipelines, call:


<code> VkResult vkCreateGraphicsPipelines(
    VkDevice                                    device,
    VkPipelineCache                             pipelineCache,
    uint32_t                                    createInfoCount,
    const VkGraphicsPipelineCreateInfo*         pCreateInfos,
    const VkAllocationCallbacks*                pAllocator,
    VkPipeline*                                 pPipelines); </code>

</remarks>
      <seealso cref="T:IVkAllocationCallbacks" />
      <seealso cref="T:VkDevice" />
      <seealso cref="T:IVkGraphicsPipelineCreateInfo" />
      <seealso cref="T:VkPipeline" />
      <seealso cref="T:VkPipelineCache" />
    </member>
    <member name="T:vkCmdProcessCommandsNVX" />
    <member name="T:vkDestroyObjectTableNVX" />
    <member name="T:vkGetPhysicalDeviceQueueFamilyProperties2KHR" />
    <member name="T:vkCreateRenderPass">
      <summary>Create a new render pass object</summary>
      <remarks>


Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>device</c> must be a valid <c>VkDevice</c> handle
</description></item><item><description>
<c>pCreateInfo</c> must be a pointer to a valid <c>VkRenderPassCreateInfo</c> structure
</description></item><item><description>
 If <c>pAllocator</c> is not <c>NULL</c>, <c>pAllocator</c> must be a pointer to a valid <c>VkAllocationCallbacks</c> structure
</description></item><item><description>
<c>pRenderPass</c> must be a pointer to a <c>VkRenderPass</c> handle
</description></item></list>




Return Codes
<dl><dt>On success, this command returns</dt><dd>
<list type="bullet"><item><description>
<c>VK_SUCCESS</c>
</description></item></list>
</dd><dt>On failure, this command returns</dt><dd>
<list type="bullet"><item><description>
<c>VK_ERROR_OUT_OF_HOST_MEMORY</c>
</description></item><item><description>
<c>VK_ERROR_OUT_OF_DEVICE_MEMORY</c>
</description></item></list>
</dd></dl>




To create a render pass, call:


<code> VkResult vkCreateRenderPass(
    VkDevice                                    device,
    const VkRenderPassCreateInfo*               pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkRenderPass*                               pRenderPass); </code>

</remarks>
      <seealso cref="T:IVkAllocationCallbacks" />
      <seealso cref="T:VkDevice" />
      <seealso cref="T:VkRenderPass" />
      <seealso cref="T:IVkRenderPassCreateInfo" />
    </member>
    <member name="T:vkCreateIndirectCommandsLayoutNVX" />
    <member name="T:IVkPresentRegionsKHR" />
    <member name="T:VkPresentRegionsKHR32">
      <summary>See: <see cref="T:IVkPresentRegionsKHR" /></summary>
      <seealso cref="T:IVkPresentRegionsKHR" />
    </member>
    <member name="T:VkPresentRegionsKHR64">
      <summary>See: <see cref="T:IVkPresentRegionsKHR" /></summary>
      <seealso cref="T:IVkPresentRegionsKHR" />
    </member>
    <member name="T:IVkSwapchainCounterCreateInfoEXT" />
    <member name="T:VkSwapchainCounterCreateInfoEXT32">
      <summary>See: <see cref="T:IVkSwapchainCounterCreateInfoEXT" /></summary>
      <seealso cref="T:IVkSwapchainCounterCreateInfoEXT" />
    </member>
    <member name="T:VkSwapchainCounterCreateInfoEXT64">
      <summary>See: <see cref="T:IVkSwapchainCounterCreateInfoEXT" /></summary>
      <seealso cref="T:IVkSwapchainCounterCreateInfoEXT" />
    </member>
    <member name="T:VkOffset2D">
      <summary>Structure specifying a two-dimensional offset</summary>
      <remarks>

A two-dimensional offsets is defined by the structure:


<code> typedef struct VkOffset2D {
    int32_t    x;
    int32_t    y;
} VkOffset2D; </code>

</remarks>
      <seealso cref="T:VkRect2D" />
    </member>
    <member name="T:vkDestroyFramebuffer">
      <summary>Destroy a framebuffer object</summary>
      <remarks>


Valid Usage
<list type="bullet"><item><description>

All submitted commands that refer to <c>framebuffer</c> must  have
completed execution
</description></item><item><description>

If <c>VkAllocationCallbacks</c> were provided when <c>framebuffer</c> was
created, a compatible set of callbacks  must be provided here
</description></item><item><description>

If no <c>VkAllocationCallbacks</c> were provided when <c>framebuffer</c>
was created, <c>pAllocator</c> must be <c>NULL</c>
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>device</c> must be a valid <c>VkDevice</c> handle
</description></item><item><description>
 If <c>framebuffer</c> is not <see cref="!:VK_NULL_HANDLE" />, <c>framebuffer</c> must be a valid <c>VkFramebuffer</c> handle
</description></item><item><description>
 If <c>pAllocator</c> is not <c>NULL</c>, <c>pAllocator</c> must be a pointer to a valid <c>VkAllocationCallbacks</c> structure
</description></item><item><description>
 If <c>framebuffer</c> is a valid handle, it  must have been created, allocated, or retrieved from <c>device</c>
</description></item></list>




Host Synchronization
<list type="bullet"><item><description>
Host access to <c>framebuffer</c> must  be externally synchronized
</description></item></list>




To destroy a framebuffer, call:


<code> void vkDestroyFramebuffer(
    VkDevice                                    device,
    VkFramebuffer                               framebuffer,
    const VkAllocationCallbacks*                pAllocator); </code>

</remarks>
      <seealso cref="T:IVkAllocationCallbacks" />
      <seealso cref="T:VkDevice" />
      <seealso cref="T:VkFramebuffer" />
    </member>
    <member name="T:vkDestroyDebugReportCallbackEXT" />
    <member name="T:VkObjectTableEntryNVX" />
    <member name="T:vkResetDescriptorPool">
      <summary>Resets a descriptor pool object</summary>
      <remarks>

Resetting a descriptor pool recycles all of the resources from all of the
descriptor sets allocated from the descriptor pool back to the descriptor
pool, and the descriptor sets are implicitly freed.



Valid Usage
<list type="bullet"><item><description>

All uses of <c>descriptorPool</c> (via any allocated descriptor sets)
 must have completed execution
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>device</c> must be a valid <c>VkDevice</c> handle
</description></item><item><description>
<c>descriptorPool</c> must be a valid <c>VkDescriptorPool</c> handle
</description></item><item><description>
<c>flags</c> must be <c>0</c>
</description></item><item><description>
<c>descriptorPool</c> must have been created, allocated, or retrieved from <c>device</c>
</description></item></list>




Host Synchronization
<list type="bullet"><item><description>
Host access to <c>descriptorPool</c> must  be externally synchronized
</description></item><item><description>
Host access to any <c>VkDescriptorSet</c> objects allocated from <c>descriptorPool</c> must  be externally synchronized
</description></item></list>




Return Codes
<dl><dt>On success, this command returns</dt><dd>
<list type="bullet"><item><description>
<c>VK_SUCCESS</c>
</description></item></list>
</dd><dt>On failure, this command returns</dt><dd>
<list type="bullet"><item><description>
<c>VK_ERROR_OUT_OF_HOST_MEMORY</c>
</description></item><item><description>
<c>VK_ERROR_OUT_OF_DEVICE_MEMORY</c>
</description></item></list>
</dd></dl>




To return all descriptor sets allocated from a given pool to the pool,
rather than freeing individual descriptor sets, call:


<code> VkResult vkResetDescriptorPool(
    VkDevice                                    device,
    VkDescriptorPool                            descriptorPool,
    VkDescriptorPoolResetFlags                  flags); </code>

</remarks>
      <seealso cref="T:VkDescriptorPool" />
      <seealso cref="T:VkDescriptorPoolResetFlags" />
      <seealso cref="T:VkDevice" />
    </member>
    <member name="T:IVkDeviceGroupRenderPassBeginInfoKHX" />
    <member name="T:VkDeviceGroupRenderPassBeginInfoKHX32">
      <summary>See: <see cref="T:IVkDeviceGroupRenderPassBeginInfoKHX" /></summary>
      <seealso cref="T:IVkDeviceGroupRenderPassBeginInfoKHX" />
    </member>
    <member name="T:VkDeviceGroupRenderPassBeginInfoKHX64">
      <summary>See: <see cref="T:IVkDeviceGroupRenderPassBeginInfoKHX" /></summary>
      <seealso cref="T:IVkDeviceGroupRenderPassBeginInfoKHX" />
    </member>
    <member name="T:vkCmdUpdateBuffer">
      <summary>Update a buffer's contents from host memory</summary>
      <remarks>

<c>dataSize</c> must be less than or equal to 65536 bytes.
For larger updates, applications  can use buffer to buffer
<a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#copies-buffers">copies</a>.


The source data is copied from the user pointer to the command buffer when
the command is called.


<c>vkCmdUpdateBuffer</c> is only allowed outside of a render pass.
This command is treated as &amp;#8220;transfer&amp;#8221; operation, for the purposes of
synchronization barriers.
The <c>VK_BUFFER_USAGE_TRANSFER_DST_BIT</c> must be specified in <c>usage</c>
of <see cref="T:IVkBufferCreateInfo" /> in order for the buffer to be compatible with
<c>vkCmdUpdateBuffer</c>.



Valid Usage
<list type="bullet"><item><description>
<c>dstOffset</c> must be less than the size of <c>dstBuffer</c>
</description></item><item><description>
<c>dataSize</c> must be less than or equal to the size of
<c>dstBuffer</c> minus <c>dstOffset</c>
</description></item><item><description>
<c>dstBuffer</c> must have been created with
<c>VK_BUFFER_USAGE_TRANSFER_DST_BIT</c> usage flag
</description></item><item><description>

If <c>dstBuffer</c> is non-sparse then it  must be bound completely and
contiguously to a single <c>VkDeviceMemory</c> object
</description></item><item><description>
<c>dstOffset</c> must be a multiple of <c>4</c>
</description></item><item><description>
<c>dataSize</c> must be less than or equal to <c>65536</c>
</description></item><item><description>
<c>dataSize</c> must be a multiple of <c>4</c>
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>commandBuffer</c> must be a valid <c>VkCommandBuffer</c> handle
</description></item><item><description>
<c>dstBuffer</c> must be a valid <c>VkBuffer</c> handle
</description></item><item><description>
<c>pData</c> must be a pointer to an array of <c>dataSize</c> bytes
</description></item><item><description>
<c>commandBuffer</c> must be in the  recording state
</description></item><item><description>
 The <c>VkCommandPool</c> that <c>commandBuffer</c> was allocated from  must support transfer, graphics, or compute operations
</description></item><item><description>
 This command  must only be called outside of a render pass instance
</description></item><item><description>
<c>dataSize</c> must be greater than <c>0</c>
</description></item><item><description>
 Both of <c>commandBuffer</c>, and <c>dstBuffer</c> must have been created, allocated, or retrieved from the same <c>VkDevice</c>
</description></item></list>




Host Synchronization
<list type="bullet"><item><description>
Host access to <c>commandBuffer</c> must  be externally synchronized
</description></item><item><description>
Host access to the <c>VkCommandPool</c> that <c>commandBuffer</c> was allocated from  must be externally synchronized
</description></item></list>




Command Properties
<list type="table">       <listheader><tr><term> Command Buffer Levels </term><term> Render Pass Scope </term><term> Supported Queue Types </term><term> Pipeline Type </term></tr></listheader>
<item><term>
Primary<br />
Secondary
</term><term>
Outside
</term><term>
Transfer<br />
graphics<br />
compute
</term><term>
Transfer
</term></item>
</list>



To update buffer data inline in a command buffer, call:


<code> void vkCmdUpdateBuffer(
    VkCommandBuffer                             commandBuffer,
    VkBuffer                                    dstBuffer,
    VkDeviceSize                                dstOffset,
    VkDeviceSize                                dataSize,
    const void*                                 pData); </code>

</remarks>
      <seealso cref="T:VkBuffer" />
      <seealso cref="T:VkCommandBuffer" />
    </member>
    <member name="T:vkCreateSharedSwapchainsKHR" />
    <member name="T:VkObjectTableIndexBufferEntryNVX" />
    <member name="T:IVkInstanceCreateInfo">
      <summary>Structure specifying parameters of a newly created instance</summary>
      <remarks>


Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>sType</c> must be <c>VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO</c>
</description></item><item><description>
<c>pNext</c> must be <c>NULL</c>
</description></item><item><description>
<c>flags</c> must be <c>0</c>
</description></item><item><description>
 If <c>pApplicationInfo</c> is not <c>NULL</c>, <c>pApplicationInfo</c> must be a pointer to a valid <c>VkApplicationInfo</c> structure
</description></item><item><description>
 If <c>enabledLayerCount</c> is not <c>0</c>, <c>ppEnabledLayerNames</c> must be a pointer to an array of <c>enabledLayerCount</c> null-terminated UTF-8 strings
</description></item><item><description>
 If <c>enabledExtensionCount</c> is not <c>0</c>, <c>ppEnabledExtensionNames</c> must be a pointer to an array of <c>enabledExtensionCount</c> null-terminated UTF-8 strings
</description></item></list>




The <c>VkInstanceCreateInfo</c> structure is defined as:


<code> typedef struct VkInstanceCreateInfo {
    VkStructureType             sType;
    const void*                 pNext;
    VkInstanceCreateFlags       flags;
    const VkApplicationInfo*    pApplicationInfo;
    uint32_t                    enabledLayerCount;
    const char* const*          ppEnabledLayerNames;
    uint32_t                    enabledExtensionCount;
    const char* const*          ppEnabledExtensionNames;
} VkInstanceCreateInfo; </code>

</remarks>
      <seealso cref="T:IVkApplicationInfo" />
      <seealso cref="T:VkInstanceCreateFlags" />
      <seealso cref="T:VkStructureType" />
      <seealso cref="T:vkCreateInstance" />
    </member>
    <member name="T:VkInstanceCreateInfo32">
      <summary>See: <see cref="T:IVkInstanceCreateInfo" /></summary>
      <seealso cref="T:IVkInstanceCreateInfo" />
    </member>
    <member name="T:VkInstanceCreateInfo64">
      <summary>See: <see cref="T:IVkInstanceCreateInfo" /></summary>
      <seealso cref="T:IVkInstanceCreateInfo" />
    </member>
    <member name="T:IVkDebugMarkerMarkerInfoEXT" />
    <member name="T:VkDebugMarkerMarkerInfoEXT32">
      <summary>See: <see cref="T:IVkDebugMarkerMarkerInfoEXT" /></summary>
      <seealso cref="T:IVkDebugMarkerMarkerInfoEXT" />
    </member>
    <member name="T:VkDebugMarkerMarkerInfoEXT64">
      <summary>See: <see cref="T:IVkDebugMarkerMarkerInfoEXT" /></summary>
      <seealso cref="T:IVkDebugMarkerMarkerInfoEXT" />
    </member>
    <member name="T:vkRegisterDisplayEventEXT" />
    <member name="T:vkCreateComputePipelines">
      <summary>Creates a new compute pipeline object</summary>
      <remarks>


Valid Usage
<list type="bullet"><item><description>

If the <c>flags</c> member of any given element of <c>pCreateInfos</c>
contains the <c>VK_PIPELINE_CREATE_DERIVATIVE_BIT</c> flag, and the
<c>basePipelineIndex</c> member of that same element is not <c>-1</c>,
<c>basePipelineIndex</c> must be less than the index into
<c>pCreateInfos</c> that corresponds to that element
</description></item><item><description>

If the <c>flags</c> member of any given element of <c>pCreateInfos</c>
contains the <c>VK_PIPELINE_CREATE_DERIVATIVE_BIT</c> flag, the base
pipeline  must have been created with the
<c>VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT</c> flag set
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>device</c> must be a valid <c>VkDevice</c> handle
</description></item><item><description>
 If <c>pipelineCache</c> is not <see cref="!:VK_NULL_HANDLE" />, <c>pipelineCache</c> must be a valid <c>VkPipelineCache</c> handle
</description></item><item><description>
<c>pCreateInfos</c> must be a pointer to an array of <c>createInfoCount</c> valid <c>VkComputePipelineCreateInfo</c> structures
</description></item><item><description>
 If <c>pAllocator</c> is not <c>NULL</c>, <c>pAllocator</c> must be a pointer to a valid <c>VkAllocationCallbacks</c> structure
</description></item><item><description>
<c>pPipelines</c> must be a pointer to an array of <c>createInfoCount</c><c>VkPipeline</c> handles
</description></item><item><description>
<c>createInfoCount</c> must be greater than <c>0</c>
</description></item><item><description>
 If <c>pipelineCache</c> is a valid handle, it  must have been created, allocated, or retrieved from <c>device</c>
</description></item></list>




Return Codes
<dl><dt>On success, this command returns</dt><dd>
<list type="bullet"><item><description>
<c>VK_SUCCESS</c>
</description></item></list>
</dd><dt>On failure, this command returns</dt><dd>
<list type="bullet"><item><description>
<c>VK_ERROR_OUT_OF_HOST_MEMORY</c>
</description></item><item><description>
<c>VK_ERROR_OUT_OF_DEVICE_MEMORY</c>
</description></item></list>
</dd></dl>




To create compute pipelines, call:


<code> VkResult vkCreateComputePipelines(
    VkDevice                                    device,
    VkPipelineCache                             pipelineCache,
    uint32_t                                    createInfoCount,
    const VkComputePipelineCreateInfo*          pCreateInfos,
    const VkAllocationCallbacks*                pAllocator,
    VkPipeline*                                 pPipelines); </code>

</remarks>
      <seealso cref="T:IVkAllocationCallbacks" />
      <seealso cref="T:IVkComputePipelineCreateInfo" />
      <seealso cref="T:VkDevice" />
      <seealso cref="T:VkPipeline" />
      <seealso cref="T:VkPipelineCache" />
    </member>
    <member name="T:vkGetSwapchainStatusKHR" />
    <member name="T:vkDeviceWaitIdle">
      <summary>Wait for a device to become idle</summary>
      <remarks>

<c>vkDeviceWaitIdle</c> is equivalent to calling <c>vkQueueWaitIdle</c> for
all queues owned by <c>device</c>.



Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>device</c> must be a valid <c>VkDevice</c> handle
</description></item></list>




Host Synchronization
<list type="bullet"><item><description>
Host access to all <c>VkQueue</c> objects created from <c>device</c> must  be externally synchronized
</description></item></list>




Return Codes
<dl><dt>On success, this command returns</dt><dd>
<list type="bullet"><item><description>
<c>VK_SUCCESS</c>
</description></item></list>
</dd><dt>On failure, this command returns</dt><dd>
<list type="bullet"><item><description>
<c>VK_ERROR_OUT_OF_HOST_MEMORY</c>
</description></item><item><description>
<c>VK_ERROR_OUT_OF_DEVICE_MEMORY</c>
</description></item><item><description>
<c>VK_ERROR_DEVICE_LOST</c>
</description></item></list>
</dd></dl>




To wait on the host for the completion of outstanding queue operations for
all queues on a given logical device, call:


<code> VkResult vkDeviceWaitIdle(
    VkDevice                                    device); </code>

</remarks>
      <seealso cref="T:VkDevice" />
    </member>
    <member name="T:IVkDeviceGroupPresentCapabilitiesKHX" />
    <member name="T:VkDeviceGroupPresentCapabilitiesKHX32">
      <summary>See: <see cref="T:IVkDeviceGroupPresentCapabilitiesKHX" /></summary>
      <seealso cref="T:IVkDeviceGroupPresentCapabilitiesKHX" />
    </member>
    <member name="T:VkDeviceGroupPresentCapabilitiesKHX64">
      <summary>See: <see cref="T:IVkDeviceGroupPresentCapabilitiesKHX" /></summary>
      <seealso cref="T:IVkDeviceGroupPresentCapabilitiesKHX" />
    </member>
    <member name="T:vkAllocateMemory">
      <summary>Allocate GPU memory</summary>
      <remarks>

Allocations returned by <c>vkAllocateMemory</c> are guaranteed to meet any
alignment requirement by the implementation.
For example, if an implementation requires 128 byte alignment for images and
64 byte alignment for buffers, the device memory returned through this
mechanism would be 128-byte aligned.
This ensures that applications  can correctly suballocate objects of
different types (with potentially different alignment requirements) in the
same memory object.


When memory is allocated, its contents are undefined.


There is an implementation-dependent maximum number of memory allocations
which  can be simultaneously created on a device.
This is specified by the
<a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-limits-maxMemoryAllocationCount"><c>maxMemoryAllocationCount</c></a>
member of the <c>VkPhysicalDeviceLimits</c> structure.
If <c>maxMemoryAllocationCount</c> is exceeded, <c>vkAllocateMemory</c> will
return <c>VK_ERROR_TOO_MANY_OBJECTS</c>.

<list type="table"><tr><td><i title="Note"></i></td><td>
Note

Some platforms  may have a limit on the maximum size of a single allocation.
For example, certain systems  may fail to create allocations with a size
greater than or equal to 4GB.
Such a limit is implementation-dependent, and if such a failure occurs then
the error <c>VK_ERROR_OUT_OF_DEVICE_MEMORY</c> should  be returned.

</td></tr></list>


Valid Usage
<list type="bullet"><item><description>

The number of currently valid memory objects, allocated from
<c>device</c>,  must be less than
<c>VkPhysicalDeviceLimits</c>::<c>maxMemoryAllocationCount</c>
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>device</c> must be a valid <c>VkDevice</c> handle
</description></item><item><description>
<c>pAllocateInfo</c> must be a pointer to a valid <c>VkMemoryAllocateInfo</c> structure
</description></item><item><description>
 If <c>pAllocator</c> is not <c>NULL</c>, <c>pAllocator</c> must be a pointer to a valid <c>VkAllocationCallbacks</c> structure
</description></item><item><description>
<c>pMemory</c> must be a pointer to a <c>VkDeviceMemory</c> handle
</description></item></list>




Return Codes
<dl><dt>On success, this command returns</dt><dd>
<list type="bullet"><item><description>
<c>VK_SUCCESS</c>
</description></item></list>
</dd><dt>On failure, this command returns</dt><dd>
<list type="bullet"><item><description>
<c>VK_ERROR_OUT_OF_HOST_MEMORY</c>
</description></item><item><description>
<c>VK_ERROR_OUT_OF_DEVICE_MEMORY</c>
</description></item><item><description>
<c>VK_ERROR_TOO_MANY_OBJECTS</c>
</description></item></list>
</dd></dl>




To allocate memory objects, call:


<code> VkResult vkAllocateMemory(
    VkDevice                                    device,
    const VkMemoryAllocateInfo*                 pAllocateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkDeviceMemory*                             pMemory); </code>

</remarks>
      <seealso cref="T:IVkAllocationCallbacks" />
      <seealso cref="T:VkDevice" />
      <seealso cref="T:VkDeviceMemory" />
      <seealso cref="T:IVkMemoryAllocateInfo" />
    </member>
    <member name="T:VkPastPresentationTimingGOOGLE" />
    <member name="T:VkRect2D">
      <summary>Structure specifying a two-dimensional subregion</summary>
      <remarks>

Rectangles are used to describe a specified rectangular region of pixels
within an image or framebuffer.
Rectangles include both an offset and an extent of the same dimensionality,
as described above.
Two-dimensional rectangles are defined by the structure


<code> typedef struct VkRect2D {
    VkOffset2D    offset;
    VkExtent2D    extent;
} VkRect2D; </code>

</remarks>
      <seealso cref="T:VkClearRect" />
      <seealso cref="T:VkExtent2D" />
      <seealso cref="T:VkOffset2D" />
      <seealso cref="T:IVkPipelineViewportStateCreateInfo" />
      <seealso cref="T:IVkRenderPassBeginInfo" />
      <seealso cref="T:vkCmdSetScissor" />
    </member>
    <member name="T:vkDestroySurfaceKHR" />
    <member name="T:IVkIndirectCommandsLayoutCreateInfoNVX" />
    <member name="T:VkIndirectCommandsLayoutCreateInfoNVX32">
      <summary>See: <see cref="T:IVkIndirectCommandsLayoutCreateInfoNVX" /></summary>
      <seealso cref="T:IVkIndirectCommandsLayoutCreateInfoNVX" />
    </member>
    <member name="T:VkIndirectCommandsLayoutCreateInfoNVX64">
      <summary>See: <see cref="T:IVkIndirectCommandsLayoutCreateInfoNVX" /></summary>
      <seealso cref="T:IVkIndirectCommandsLayoutCreateInfoNVX" />
    </member>
    <member name="T:IVkMappedMemoryRange">
      <summary>Structure specifying a mapped memory range</summary>
      <remarks>


Valid Usage
<list type="bullet"><item><description>
<c>memory</c> must  currently be mapped
</description></item><item><description>

If <c>size</c> is not equal to <c>VK_WHOLE_SIZE</c>, <c>offset</c> and
<c>size</c> must specify a range contained within the currently mapped
range of <c>memory</c>
</description></item><item><description>

If <c>size</c> is equal to <c>VK_WHOLE_SIZE</c>, <c>offset</c> must be
within the currently mapped range of <c>memory</c>
</description></item><item><description>

If <c>size</c> is equal to <c>VK_WHOLE_SIZE</c>, the end of the current
mapping of <c>memory</c> must be a multiple of
<c>VkPhysicalDeviceLimits</c>::<c>nonCoherentAtomSize</c> bytes from the
beginning of the memory object.
</description></item><item><description>
<c>offset</c> must be a multiple of
<c>VkPhysicalDeviceLimits</c>::<c>nonCoherentAtomSize</c>
</description></item><item><description>

If <c>size</c> is not equal to <c>VK_WHOLE_SIZE</c>, <c>size</c> must
either be a multiple of
<c>VkPhysicalDeviceLimits</c>::<c>nonCoherentAtomSize</c>, or <c>offset</c>
plus <c>size</c> must equal the size of <c>memory</c>.
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>sType</c> must be <c>VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE</c>
</description></item><item><description>
<c>pNext</c> must be <c>NULL</c>
</description></item><item><description>
<c>memory</c> must be a valid <c>VkDeviceMemory</c> handle
</description></item></list>




The <c>VkMappedMemoryRange</c> structure is defined as:


<code> typedef struct VkMappedMemoryRange {
    VkStructureType    sType;
    const void*        pNext;
    VkDeviceMemory     memory;
    VkDeviceSize       offset;
    VkDeviceSize       size;
} VkMappedMemoryRange; </code>

</remarks>
      <seealso cref="T:VkDeviceMemory" />
      <seealso cref="T:VkStructureType" />
      <seealso cref="T:vkFlushMappedMemoryRanges" />
      <seealso cref="T:vkInvalidateMappedMemoryRanges" />
    </member>
    <member name="T:VkMappedMemoryRange32">
      <summary>See: <see cref="T:IVkMappedMemoryRange" /></summary>
      <seealso cref="T:IVkMappedMemoryRange" />
    </member>
    <member name="T:VkMappedMemoryRange64">
      <summary>See: <see cref="T:IVkMappedMemoryRange" /></summary>
      <seealso cref="T:IVkMappedMemoryRange" />
    </member>
    <member name="T:vkCmdDebugMarkerInsertEXT" />
    <member name="T:IVkDedicatedAllocationImageCreateInfoNV" />
    <member name="T:VkDedicatedAllocationImageCreateInfoNV32">
      <summary>See: <see cref="T:IVkDedicatedAllocationImageCreateInfoNV" /></summary>
      <seealso cref="T:IVkDedicatedAllocationImageCreateInfoNV" />
    </member>
    <member name="T:VkDedicatedAllocationImageCreateInfoNV64">
      <summary>See: <see cref="T:IVkDedicatedAllocationImageCreateInfoNV" /></summary>
      <seealso cref="T:IVkDedicatedAllocationImageCreateInfoNV" />
    </member>
    <member name="T:IVkPipelineRasterizationStateCreateInfo">
      <summary>Structure specifying parameters of a newly created pipeline rasterization state</summary>
      <remarks>


Valid Usage
<list type="bullet"><item><description>

If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-depthClamp">depth clamping</a> feature is not
enabled, <c>depthClampEnable</c> must be <c>VK_FALSE</c>
</description></item><item><description>

If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-fillModeNonSolid">non-solid fill modes</a>
feature is not enabled, <c>polygonMode</c> must be
<c>VK_POLYGON_MODE_FILL</c>
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>sType</c> must be <c>VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO</c>
</description></item><item><description>
<c>pNext</c> must be <c>NULL</c>
</description></item><item><description>
<c>flags</c> must be <c>0</c>
</description></item><item><description>
<c>polygonMode</c> must be a valid <see cref="T:VkPolygonMode" /> value
</description></item><item><description>
<c>cullMode</c> must be a valid combination of <see cref="T:VkCullModeFlags" /> values
</description></item><item><description>
<c>frontFace</c> must be a valid <see cref="T:VkFrontFace" /> value
</description></item></list>




The <c>VkPipelineRasterizationStateCreateInfo</c> structure is defined as:


<code> typedef struct VkPipelineRasterizationStateCreateInfo {
    VkStructureType                            sType;
    const void*                                pNext;
    VkPipelineRasterizationStateCreateFlags    flags;
    VkBool32                                   depthClampEnable;
    VkBool32                                   rasterizerDiscardEnable;
    VkPolygonMode                              polygonMode;
    VkCullModeFlags                            cullMode;
    VkFrontFace                                frontFace;
    VkBool32                                   depthBiasEnable;
    float                                      depthBiasConstantFactor;
    float                                      depthBiasClamp;
    float                                      depthBiasSlopeFactor;
    float                                      lineWidth;
} VkPipelineRasterizationStateCreateInfo; </code>

</remarks>
      <seealso cref="T:VkCullModeFlags" />
      <seealso cref="T:VkFrontFace" />
      <seealso cref="T:IVkGraphicsPipelineCreateInfo" />
      <seealso cref="T:VkPipelineRasterizationStateCreateFlags" />
      <seealso cref="T:VkPolygonMode" />
      <seealso cref="T:VkStructureType" />
    </member>
    <member name="T:VkPipelineRasterizationStateCreateInfo32">
      <summary>See: <see cref="T:IVkPipelineRasterizationStateCreateInfo" /></summary>
      <seealso cref="T:IVkPipelineRasterizationStateCreateInfo" />
    </member>
    <member name="T:VkPipelineRasterizationStateCreateInfo64">
      <summary>See: <see cref="T:IVkPipelineRasterizationStateCreateInfo" /></summary>
      <seealso cref="T:IVkPipelineRasterizationStateCreateInfo" />
    </member>
    <member name="T:IVkPhysicalDevicePushDescriptorPropertiesKHR" />
    <member name="T:VkPhysicalDevicePushDescriptorPropertiesKHR32">
      <summary>See: <see cref="T:IVkPhysicalDevicePushDescriptorPropertiesKHR" /></summary>
      <seealso cref="T:IVkPhysicalDevicePushDescriptorPropertiesKHR" />
    </member>
    <member name="T:VkPhysicalDevicePushDescriptorPropertiesKHR64">
      <summary>See: <see cref="T:IVkPhysicalDevicePushDescriptorPropertiesKHR" /></summary>
      <seealso cref="T:IVkPhysicalDevicePushDescriptorPropertiesKHR" />
    </member>
    <member name="T:IVkCmdReserveSpaceForCommandsInfoNVX" />
    <member name="T:VkCmdReserveSpaceForCommandsInfoNVX32">
      <summary>See: <see cref="T:IVkCmdReserveSpaceForCommandsInfoNVX" /></summary>
      <seealso cref="T:IVkCmdReserveSpaceForCommandsInfoNVX" />
    </member>
    <member name="T:VkCmdReserveSpaceForCommandsInfoNVX64">
      <summary>See: <see cref="T:IVkCmdReserveSpaceForCommandsInfoNVX" /></summary>
      <seealso cref="T:IVkCmdReserveSpaceForCommandsInfoNVX" />
    </member>
    <member name="T:vkGetPhysicalDeviceFormatProperties">
      <summary>Lists physical device's format capabilities</summary>
      <remarks>


Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>physicalDevice</c> must be a valid <c>VkPhysicalDevice</c> handle
</description></item><item><description>
<c>format</c> must be a valid <see cref="T:VkFormat" /> value
</description></item><item><description>
<c>pFormatProperties</c> must be a pointer to a <c>VkFormatProperties</c> structure
</description></item></list>




To query supported format features which are properties of the physical
device, call:


<code> void vkGetPhysicalDeviceFormatProperties(
    VkPhysicalDevice                            physicalDevice,
    VkFormat                                    format,
    VkFormatProperties*                         pFormatProperties); </code>

</remarks>
      <seealso cref="T:VkFormat" />
      <seealso cref="T:VkFormatProperties" />
      <seealso cref="T:VkPhysicalDevice" />
    </member>
    <member name="T:vkCreateDisplayPlaneSurfaceKHR" />
    <member name="T:IVkDeviceCreateInfo">
      <summary>Structure specifying parameters of a newly created device</summary>
      <remarks>


Valid Usage
<list type="bullet"><item><description>

The <c>queueFamilyIndex</c> member of any given element of
<c>pQueueCreateInfos</c> must be unique within <c>pQueueCreateInfos</c>
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>sType</c> must be <c>VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO</c>
</description></item><item><description>
<c>pNext</c> must be <c>NULL</c>
</description></item><item><description>
<c>flags</c> must be <c>0</c>
</description></item><item><description>
<c>pQueueCreateInfos</c> must be a pointer to an array of <c>queueCreateInfoCount</c> valid <c>VkDeviceQueueCreateInfo</c> structures
</description></item><item><description>
 If <c>enabledLayerCount</c> is not <c>0</c>, <c>ppEnabledLayerNames</c> must be a pointer to an array of <c>enabledLayerCount</c> null-terminated UTF-8 strings
</description></item><item><description>
 If <c>enabledExtensionCount</c> is not <c>0</c>, <c>ppEnabledExtensionNames</c> must be a pointer to an array of <c>enabledExtensionCount</c> null-terminated UTF-8 strings
</description></item><item><description>
 If <c>pEnabledFeatures</c> is not <c>NULL</c>, <c>pEnabledFeatures</c> must be a pointer to a valid <c>VkPhysicalDeviceFeatures</c> structure
</description></item><item><description>
<c>queueCreateInfoCount</c> must be greater than <c>0</c>
</description></item></list>




The <c>VkDeviceCreateInfo</c> structure is defined as:


<code> typedef struct VkDeviceCreateInfo {
    VkStructureType                    sType;
    const void*                        pNext;
    VkDeviceCreateFlags                flags;
    uint32_t                           queueCreateInfoCount;
    const VkDeviceQueueCreateInfo*     pQueueCreateInfos;
    uint32_t                           enabledLayerCount;
    const char* const*                 ppEnabledLayerNames;
    uint32_t                           enabledExtensionCount;
    const char* const*                 ppEnabledExtensionNames;
    const VkPhysicalDeviceFeatures*    pEnabledFeatures;
} VkDeviceCreateInfo; </code>

</remarks>
      <seealso cref="T:VkDeviceCreateFlags" />
      <seealso cref="T:IVkDeviceQueueCreateInfo" />
      <seealso cref="T:VkPhysicalDeviceFeatures" />
      <seealso cref="T:VkStructureType" />
      <seealso cref="T:vkCreateDevice" />
    </member>
    <member name="T:VkDeviceCreateInfo32">
      <summary>See: <see cref="T:IVkDeviceCreateInfo" /></summary>
      <seealso cref="T:IVkDeviceCreateInfo" />
    </member>
    <member name="T:VkDeviceCreateInfo64">
      <summary>See: <see cref="T:IVkDeviceCreateInfo" /></summary>
      <seealso cref="T:IVkDeviceCreateInfo" />
    </member>
    <member name="T:vkCmdClearAttachments">
      <summary>Clear regions within currently bound framebuffer attachments</summary>
      <remarks>

<c>vkCmdClearAttachments</c> can clear multiple regions of each attachment
used in the current subpass of a render pass instance.
This command  must be called only inside a render pass instance, and
implicitly selects the images to clear based on the current framebuffer
attachments and the command parameters.



Valid Usage
<list type="bullet"><item><description>

If the <c>aspectMask</c> member of any given element of
<c>pAttachments</c> contains <c>VK_IMAGE_ASPECT_COLOR_BIT</c>, the
<c>colorAttachment</c> member of those elements  must refer to a valid
color attachment in the current subpass
</description></item><item><description>

The rectangular region specified by a given element of <c>pRects</c> must  be contained within the render area of the current render pass
instance
</description></item><item><description>

The layers specified by a given element of <c>pRects</c> must be
contained within every attachment that <c>pAttachments</c> refers to
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>commandBuffer</c> must be a valid <c>VkCommandBuffer</c> handle
</description></item><item><description>
<c>pAttachments</c> must be a pointer to an array of <c>attachmentCount</c> valid <c>VkClearAttachment</c> structures
</description></item><item><description>
<c>pRects</c> must be a pointer to an array of <c>rectCount</c><c>VkClearRect</c> structures
</description></item><item><description>
<c>commandBuffer</c> must be in the  recording state
</description></item><item><description>
 The <c>VkCommandPool</c> that <c>commandBuffer</c> was allocated from  must support graphics operations
</description></item><item><description>
 This command  must only be called inside of a render pass instance
</description></item><item><description>
<c>attachmentCount</c> must be greater than <c>0</c>
</description></item><item><description>
<c>rectCount</c> must be greater than <c>0</c>
</description></item></list>




Host Synchronization
<list type="bullet"><item><description>
Host access to <c>commandBuffer</c> must  be externally synchronized
</description></item><item><description>
Host access to the <c>VkCommandPool</c> that <c>commandBuffer</c> was allocated from  must be externally synchronized
</description></item></list>




Command Properties
<list type="table">       <listheader><tr><term> Command Buffer Levels </term><term> Render Pass Scope </term><term> Supported Queue Types </term><term> Pipeline Type </term></tr></listheader>
<item><term>
Primary<br />
Secondary
</term><term>
Inside
</term><term>
Graphics
</term><term>
Graphics
</term></item>
</list>



To clear one or more regions of color and depth/stencil attachments inside a
render pass instance, call:


<code> void vkCmdClearAttachments(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    attachmentCount,
    const VkClearAttachment*                    pAttachments,
    uint32_t                                    rectCount,
    const VkClearRect*                          pRects); </code>

</remarks>
      <seealso cref="T:VkClearAttachment" />
      <seealso cref="T:VkClearRect" />
      <seealso cref="T:VkCommandBuffer" />
    </member>
    <member name="T:vkCmdWriteTimestamp">
      <summary>Write a device timestamp into a query object</summary>
      <remarks>

<c>vkCmdWriteTimestamp</c> latches the value of the timer when all previous
commands have completed executing as far as the specified pipeline stage,
and writes the timestamp value to memory.
When the timestamp value is written, the availability status of the query is
set to available.

<list type="table"><tr><td><i title="Note"></i></td><td>
Note

If an implementation is unable to detect completion and latch the timer at
any specific stage of the pipeline, it  may instead do so at any logically
later stage.

</td></tr></list>

<see cref="T:vkCmdCopyQueryPoolResults" /> can then be called to copy the timestamp
value from the query pool into buffer memory, with ordering and
synchronization behavior equivalent to how other queries operate.
Timestamp values  can also be retrieved from the query pool using
<see cref="T:vkGetQueryPoolResults" />.
As with other queries, the query  must be reset using
<see cref="T:vkCmdResetQueryPool" /> before requesting the timestamp value be written
to it.


While <c>vkCmdWriteTimestamp</c> can be called inside or outside of a render
pass instance, <see cref="T:vkCmdCopyQueryPoolResults" /> must  only be called outside
of a render pass instance.



Valid Usage
<list type="bullet"><item><description>
<c>queryPool</c> must have been created with a <c>queryType</c> of
<c>VK_QUERY_TYPE_TIMESTAMP</c>
</description></item><item><description>

The query identified by <c>queryPool</c> and <c>query</c> must be
 unavailable
</description></item><item><description>

The command pool&amp;#8217;s queue family  must support a non-zero
<c>timestampValidBits</c>
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>commandBuffer</c> must be a valid <c>VkCommandBuffer</c> handle
</description></item><item><description>
<c>pipelineStage</c> must be a valid <see cref="T:VkPipelineStageFlags" /> value
</description></item><item><description>
<c>queryPool</c> must be a valid <c>VkQueryPool</c> handle
</description></item><item><description>
<c>commandBuffer</c> must be in the  recording state
</description></item><item><description>
 The <c>VkCommandPool</c> that <c>commandBuffer</c> was allocated from  must support graphics, or compute operations
</description></item><item><description>
 Both of <c>commandBuffer</c>, and <c>queryPool</c> must have been created, allocated, or retrieved from the same <c>VkDevice</c>
</description></item></list>




Host Synchronization
<list type="bullet"><item><description>
Host access to <c>commandBuffer</c> must  be externally synchronized
</description></item><item><description>
Host access to the <c>VkCommandPool</c> that <c>commandBuffer</c> was allocated from  must be externally synchronized
</description></item></list>




Command Properties
<list type="table">       <listheader><tr><term> Command Buffer Levels </term><term> Render Pass Scope </term><term> Supported Queue Types </term><term> Pipeline Type </term></tr></listheader>
<item><term>
Primary<br />
Secondary
</term><term>
Both
</term><term>
Graphics<br />
compute
</term><term>
Transfer
</term></item>
</list>



To request a timestamp, call:


<code> void vkCmdWriteTimestamp(
    VkCommandBuffer                             commandBuffer,
    VkPipelineStageFlagBits                     pipelineStage,
    VkQueryPool                                 queryPool,
    uint32_t                                    query); </code>

</remarks>
      <seealso cref="T:VkCommandBuffer" />
      <seealso cref="T:VkPipelineStageFlags" />
      <seealso cref="T:VkQueryPool" />
    </member>
    <member name="T:IVkSpecializationMapEntry">
      <summary>Structure specifying a specialization map entry</summary>
      <remarks>

If a <c>constantID</c> value is not a specialization constant ID used in the
shader, that map entry does not affect the behavior of the pipeline.



Valid Usage
<list type="bullet"><item><description>

For a <c>constantID</c> specialization constant declared in a shader,
<c>size</c> must match the byte size of the <c>constantID</c>.
If the specialization constant is of type <c>boolean</c>, <c>size</c> must
be the byte size of <c>VkBool32</c>
</description></item></list>




The <c>VkSpecializationMapEntry</c> structure is defined as:


<code> typedef struct VkSpecializationMapEntry {
    uint32_t    constantID;
    uint32_t    offset;
    size_t      size;
} VkSpecializationMapEntry; </code>

</remarks>
      <seealso cref="T:IVkSpecializationInfo" />
    </member>
    <member name="T:VkSpecializationMapEntry32">
      <summary>See: <see cref="T:IVkSpecializationMapEntry" /></summary>
      <seealso cref="T:IVkSpecializationMapEntry" />
    </member>
    <member name="T:VkSpecializationMapEntry64">
      <summary>See: <see cref="T:IVkSpecializationMapEntry" /></summary>
      <seealso cref="T:IVkSpecializationMapEntry" />
    </member>
    <member name="T:IVkSharedPresentSurfaceCapabilitiesKHR" />
    <member name="T:VkSharedPresentSurfaceCapabilitiesKHR32">
      <summary>See: <see cref="T:IVkSharedPresentSurfaceCapabilitiesKHR" /></summary>
      <seealso cref="T:IVkSharedPresentSurfaceCapabilitiesKHR" />
    </member>
    <member name="T:VkSharedPresentSurfaceCapabilitiesKHR64">
      <summary>See: <see cref="T:IVkSharedPresentSurfaceCapabilitiesKHR" /></summary>
      <seealso cref="T:IVkSharedPresentSurfaceCapabilitiesKHR" />
    </member>
    <member name="T:vkDestroyImageView">
      <summary>Destroy an image view object</summary>
      <remarks>


Valid Usage
<list type="bullet"><item><description>

All submitted commands that refer to <c>imageView</c> must  have
completed execution
</description></item><item><description>

If <c>VkAllocationCallbacks</c> were provided when <c>imageView</c> was
created, a compatible set of callbacks  must be provided here
</description></item><item><description>

If no <c>VkAllocationCallbacks</c> were provided when <c>imageView</c> was
created, <c>pAllocator</c> must be <c>NULL</c>
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>device</c> must be a valid <c>VkDevice</c> handle
</description></item><item><description>
 If <c>imageView</c> is not <see cref="!:VK_NULL_HANDLE" />, <c>imageView</c> must be a valid <c>VkImageView</c> handle
</description></item><item><description>
 If <c>pAllocator</c> is not <c>NULL</c>, <c>pAllocator</c> must be a pointer to a valid <c>VkAllocationCallbacks</c> structure
</description></item><item><description>
 If <c>imageView</c> is a valid handle, it  must have been created, allocated, or retrieved from <c>device</c>
</description></item></list>




Host Synchronization
<list type="bullet"><item><description>
Host access to <c>imageView</c> must  be externally synchronized
</description></item></list>




To destroy an image view, call:


<code> void vkDestroyImageView(
    VkDevice                                    device,
    VkImageView                                 imageView,
    const VkAllocationCallbacks*                pAllocator); </code>

</remarks>
      <seealso cref="T:IVkAllocationCallbacks" />
      <seealso cref="T:VkDevice" />
      <seealso cref="T:VkImageView" />
    </member>
    <member name="T:vkResetCommandPool">
      <summary>Reset a command pool</summary>
      <remarks>

Resetting a command pool recycles all of the resources from all of the
command buffers allocated from the command pool back to the command pool.
All command buffers that have been allocated from the command pool are put
in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#commandbuffers-lifecycle">initial state</a>.


Any primary command buffer allocated from another <see cref="T:VkCommandPool" /> that
is in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#commandbuffers-lifecycle">recording or executable state</a> and
has a secondary command buffer allocated from <c>commandPool</c> recorded
into it, becomes <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#commandbuffers-lifecycle">invalid</a>.



Valid Usage
<list type="bullet"><item><description>

All <c>VkCommandBuffer</c> objects allocated from <c>commandPool</c> must
not be in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#commandbuffers-lifecycle">pending state</a>
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>device</c> must be a valid <c>VkDevice</c> handle
</description></item><item><description>
<c>commandPool</c> must be a valid <c>VkCommandPool</c> handle
</description></item><item><description>
<c>flags</c> must be a valid combination of <see cref="T:VkCommandPoolResetFlags" /> values
</description></item><item><description>
<c>commandPool</c> must have been created, allocated, or retrieved from <c>device</c>
</description></item></list>




Host Synchronization
<list type="bullet"><item><description>
Host access to <c>commandPool</c> must  be externally synchronized
</description></item></list>




Return Codes
<dl><dt>On success, this command returns</dt><dd>
<list type="bullet"><item><description>
<c>VK_SUCCESS</c>
</description></item></list>
</dd><dt>On failure, this command returns</dt><dd>
<list type="bullet"><item><description>
<c>VK_ERROR_OUT_OF_HOST_MEMORY</c>
</description></item><item><description>
<c>VK_ERROR_OUT_OF_DEVICE_MEMORY</c>
</description></item></list>
</dd></dl>




To reset a command pool, call:


<code> VkResult vkResetCommandPool(
    VkDevice                                    device,
    VkCommandPool                               commandPool,
    VkCommandPoolResetFlags                     flags); </code>

</remarks>
      <seealso cref="T:VkCommandPool" />
      <seealso cref="T:VkCommandPoolResetFlags" />
      <seealso cref="T:VkDevice" />
    </member>
    <member name="T:vkQueuePresentKHR" />
    <member name="T:VkExtensionProperties">
      <summary>Structure specifying a extension properties</summary>
      <remarks>

The <c>VkExtensionProperties</c> structure is defined as:


<code> typedef struct VkExtensionProperties {
    char        extensionName[VK_MAX_EXTENSION_NAME_SIZE];
    uint32_t    specVersion;
} VkExtensionProperties; </code>

</remarks>
      <seealso cref="T:vkEnumerateDeviceExtensionProperties" />
      <seealso cref="T:vkEnumerateInstanceExtensionProperties" />
    </member>
    <member name="T:vkCreateDisplayModeKHR" />
    <member name="T:vkGetPhysicalDeviceSurfaceFormats2KHR" />
    <member name="T:IVkPhysicalDeviceIDPropertiesKHX" />
    <member name="T:VkPhysicalDeviceIDPropertiesKHX32">
      <summary>See: <see cref="T:IVkPhysicalDeviceIDPropertiesKHX" /></summary>
      <seealso cref="T:IVkPhysicalDeviceIDPropertiesKHX" />
    </member>
    <member name="T:VkPhysicalDeviceIDPropertiesKHX64">
      <summary>See: <see cref="T:IVkPhysicalDeviceIDPropertiesKHX" /></summary>
      <seealso cref="T:IVkPhysicalDeviceIDPropertiesKHX" />
    </member>
    <member name="T:VkImageSubresourceLayers">
      <summary>Structure specifying a image subresource layers</summary>
      <remarks>


Valid Usage
<list type="bullet"><item><description>

If <c>aspectMask</c> contains <c>VK_IMAGE_ASPECT_COLOR_BIT</c>, it  must
not contain either of <c>VK_IMAGE_ASPECT_DEPTH_BIT</c> or
<c>VK_IMAGE_ASPECT_STENCIL_BIT</c>
</description></item><item><description>
<c>aspectMask</c> must not contain <c>VK_IMAGE_ASPECT_METADATA_BIT</c>
</description></item><item><description>
<c>mipLevel</c> must be less than the <c>mipLevels</c> specified in
<see cref="T:IVkImageCreateInfo" /> when the image was created
</description></item><item><description>
 (<c>baseArrayLayer</c> +  <c>layerCount</c>)  must be less than
or equal to the <c>arrayLayers</c> specified in <see cref="T:IVkImageCreateInfo" />
when the image was created
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>aspectMask</c> must be a valid combination of <see cref="T:VkImageAspectFlags" /> values
</description></item><item><description>
<c>aspectMask</c> must not be <c>0</c>
</description></item></list>




The <c>VkImageSubresourceLayers</c> structure is defined as:


<code> typedef struct VkImageSubresourceLayers {
    VkImageAspectFlags    aspectMask;
    uint32_t              mipLevel;
    uint32_t              baseArrayLayer;
    uint32_t              layerCount;
} VkImageSubresourceLayers; </code>

</remarks>
      <seealso cref="T:VkBufferImageCopy" />
      <seealso cref="T:VkImageAspectFlags" />
      <seealso cref="T:VkImageBlit" />
      <seealso cref="T:VkImageCopy" />
      <seealso cref="T:VkImageResolve" />
    </member>
    <member name="T:vkGetPhysicalDeviceFeatures2KHR" />
    <member name="T:vkCmdDrawIndexed">
      <summary>Issue an indexed draw into a command buffer</summary>
      <remarks>

When the command is executed, primitives are assembled using the current
primitive topology and <c>indexCount</c> vertices whose indices are retrieved
from the index buffer.
The index buffer is treated as an array of tightly packed unsigned integers
of size defined by the <see cref="T:vkCmdBindIndexBuffer" />::<c>indexType</c> parameter
with which the buffer was bound.


The first vertex index is at an offset of <c>firstIndex</c> * <c>indexSize</c>
+ <c>offset</c> within the currently bound index buffer, where <c>offset</c>
is the offset specified by <c>vkCmdBindIndexBuffer</c> and <c>indexSize</c> is
the byte size of the type specified by <c>indexType</c>.
Subsequent index values are retrieved from consecutive locations in the
index buffer.
Indices are first compared to the primitive restart value, then zero
extended to 32 bits (if the <c>indexType</c> is <c>VK_INDEX_TYPE_UINT16</c>)
and have <c>vertexOffset</c> added to them, before being supplied as the
<c>vertexIndex</c> value.


The primitives are drawn <c>instanceCount</c> times with <c>instanceIndex</c>
starting with <c>firstInstance</c> and increasing sequentially for each
instance.
The assembled primitives execute the currently bound graphics pipeline.



Valid Usage
<list type="bullet"><item><description>

The current render pass  must be <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#renderpass-compatibility">compatible</a>
with the <c>renderPass</c> member of the
<c>VkGraphicsPipelineCreateInfo</c> structure specified when creating the
<c>VkPipeline</c> currently bound to
<c>VK_PIPELINE_BIND_POINT_GRAPHICS</c>.
</description></item><item><description>

The subpass index of the current render pass  must be equal to the
<c>subpass</c> member of the <c>VkGraphicsPipelineCreateInfo</c> structure
specified when creating the <c>VkPipeline</c> currently bound to
<c>VK_PIPELINE_BIND_POINT_GRAPHICS</c>.
</description></item><item><description>

For each set  n that is statically used by the <c>VkPipeline</c>
currently bound to <c>VK_PIPELINE_BIND_POINT_GRAPHICS</c>, a descriptor
set  must have been bound to  n at
<c>VK_PIPELINE_BIND_POINT_GRAPHICS</c>, with a <c>VkPipelineLayout</c>
that is compatible for set  n, with the <c>VkPipelineLayout</c> used to
create the current <c>VkPipeline</c>, as described in
<a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#descriptorsets-compatibility">../../html/vkspec.html#descriptorsets-compatibility</a>
</description></item><item><description>

For each push constant that is statically used by the <c>VkPipeline</c>
currently bound to <c>VK_PIPELINE_BIND_POINT_GRAPHICS</c>, a push
constant value  must have been set for
<c>VK_PIPELINE_BIND_POINT_GRAPHICS</c>, with a <c>VkPipelineLayout</c>
that is compatible for push constants, with the <c>VkPipelineLayout</c>
used to create the current <c>VkPipeline</c>, as described in
<a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#descriptorsets-compatibility">../../html/vkspec.html#descriptorsets-compatibility</a>
</description></item><item><description>

Descriptors in each bound descriptor set, specified via
<c>vkCmdBindDescriptorSets</c>,  must be valid if they are statically
used by the currently bound <c>VkPipeline</c> object, specified via
<c>vkCmdBindPipeline</c>
</description></item><item><description>

All vertex input bindings accessed via vertex input variables declared
in the vertex shader entry point&amp;#8217;s interface  must have valid buffers
bound
</description></item><item><description>

For a given vertex buffer binding, any attribute data fetched  must be
entirely contained within the corresponding vertex buffer binding, as
described in <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#fxvertex-input">../../html/vkspec.html#fxvertex-input</a>
</description></item><item><description>

A valid graphics pipeline  must be bound to the current command buffer
with <c>VK_PIPELINE_BIND_POINT_GRAPHICS</c>
</description></item><item><description>

If the <c>VkPipeline</c> object currently bound to
<c>VK_PIPELINE_BIND_POINT_GRAPHICS</c> requires any dynamic state, that
state  must have been set on the current command buffer
</description></item><item><description>
 (<c>indexSize</c> * (<c>firstIndex</c> +  <c>indexCount</c>)
+  <c>offset</c>)  must be less than or equal to the size of the
currently bound index buffer, with indexSize being based on the type
specified by <c>indexType</c>, where the index buffer, <c>indexType</c>,
and <c>offset</c> are specified via <c>vkCmdBindIndexBuffer</c>
</description></item><item><description>

Every input attachment used by the current subpass  must be bound to the
pipeline via a descriptor set
</description></item><item><description>

If any <c>VkSampler</c> object that is accessed from a shader by the
<c>VkPipeline</c> currently bound to
<c>VK_PIPELINE_BIND_POINT_GRAPHICS</c> uses unnormalized coordinates, it
 must not be used to sample from any <c>VkImage</c> with a
<c>VkImageView</c> of the type <c>VK_IMAGE_VIEW_TYPE_3D</c>,
<c>VK_IMAGE_VIEW_TYPE_CUBE</c>, <c>VK_IMAGE_VIEW_TYPE_1D_ARRAY</c>,
<c>VK_IMAGE_VIEW_TYPE_2D_ARRAY</c> or
<c>VK_IMAGE_VIEW_TYPE_CUBE_ARRAY</c>, in any shader stage
</description></item><item><description>

If any <c>VkSampler</c> object that is accessed from a shader by the
<c>VkPipeline</c> currently bound to
<c>VK_PIPELINE_BIND_POINT_GRAPHICS</c> uses unnormalized coordinates, it
 must not be used with any of the SPIR-V <c>OpImageSample*</c> or
<c>OpImageSparseSample*</c> instructions with <c>ImplicitLod</c>, <c>Dref</c> or
<c>Proj</c> in their name, in any shader stage
</description></item><item><description>

If any <c>VkSampler</c> object that is accessed from a shader by the
<c>VkPipeline</c> currently bound to
<c>VK_PIPELINE_BIND_POINT_GRAPHICS</c> uses unnormalized coordinates, it
 must not be used with any of the SPIR-V <c>OpImageSample*</c> or
<c>OpImageSparseSample*</c> instructions that includes a LOD bias or any
offset values, in any shader stage
</description></item><item><description>

If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-robustBufferAccess">robust buffer access</a>
feature is not enabled, and any shader stage in the <c>VkPipeline</c>
object currently bound to <c>VK_PIPELINE_BIND_POINT_GRAPHICS</c> accesses
a uniform buffer, it  must not access values outside of the range of
that buffer specified in the currently bound descriptor set
</description></item><item><description>

If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-robustBufferAccess">robust buffer access</a>
feature is not enabled, and any shader stage in the <c>VkPipeline</c>
object currently bound to <c>VK_PIPELINE_BIND_POINT_GRAPHICS</c> accesses
a storage buffer, it  must not access values outside of the range of
that buffer specified in the currently bound descriptor set
</description></item><item><description>

Any <c>VkImageView</c> being sampled with <c>VK_FILTER_LINEAR</c> as a
result of this command  must be of a format which supports linear
filtering, as specified by the
<c>VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT</c> flag in
<c>VkFormatProperties</c>::<c>linearTilingFeatures</c> (for a linear
image) or <c>VkFormatProperties</c>::<c>optimalTilingFeatures</c>(for an
optimally tiled image) returned by
<c>vkGetPhysicalDeviceFormatProperties</c>
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>commandBuffer</c> must be a valid <c>VkCommandBuffer</c> handle
</description></item><item><description>
<c>commandBuffer</c> must be in the  recording state
</description></item><item><description>
 The <c>VkCommandPool</c> that <c>commandBuffer</c> was allocated from  must support graphics operations
</description></item><item><description>
 This command  must only be called inside of a render pass instance
</description></item></list>




Host Synchronization
<list type="bullet"><item><description>
Host access to <c>commandBuffer</c> must  be externally synchronized
</description></item><item><description>
Host access to the <c>VkCommandPool</c> that <c>commandBuffer</c> was allocated from  must be externally synchronized
</description></item></list>




Command Properties
<list type="table">       <listheader><tr><term> Command Buffer Levels </term><term> Render Pass Scope </term><term> Supported Queue Types </term><term> Pipeline Type </term></tr></listheader>
<item><term>
Primary<br />
Secondary
</term><term>
Inside
</term><term>
Graphics
</term><term>
Graphics
</term></item>
</list>



To record an indexed draw, call:


<code> void vkCmdDrawIndexed(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    indexCount,
    uint32_t                                    instanceCount,
    uint32_t                                    firstIndex,
    int32_t                                     vertexOffset,
    uint32_t                                    firstInstance); </code>

</remarks>
      <seealso cref="T:VkCommandBuffer" />
    </member>
    <member name="T:vkCreateSampler">
      <summary>Create a new sampler object</summary>
      <remarks>


Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>device</c> must be a valid <c>VkDevice</c> handle
</description></item><item><description>
<c>pCreateInfo</c> must be a pointer to a valid <c>VkSamplerCreateInfo</c> structure
</description></item><item><description>
 If <c>pAllocator</c> is not <c>NULL</c>, <c>pAllocator</c> must be a pointer to a valid <c>VkAllocationCallbacks</c> structure
</description></item><item><description>
<c>pSampler</c> must be a pointer to a <c>VkSampler</c> handle
</description></item></list>




Return Codes
<dl><dt>On success, this command returns</dt><dd>
<list type="bullet"><item><description>
<c>VK_SUCCESS</c>
</description></item></list>
</dd><dt>On failure, this command returns</dt><dd>
<list type="bullet"><item><description>
<c>VK_ERROR_OUT_OF_HOST_MEMORY</c>
</description></item><item><description>
<c>VK_ERROR_OUT_OF_DEVICE_MEMORY</c>
</description></item><item><description>
<c>VK_ERROR_TOO_MANY_OBJECTS</c>
</description></item></list>
</dd></dl>




To create a sampler object, call:


<code> VkResult vkCreateSampler(
    VkDevice                                    device,
    const VkSamplerCreateInfo*                  pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkSampler*                                  pSampler); </code>

</remarks>
      <seealso cref="T:IVkAllocationCallbacks" />
      <seealso cref="T:VkDevice" />
      <seealso cref="T:VkSampler" />
      <seealso cref="T:IVkSamplerCreateInfo" />
    </member>
    <member name="T:vkDisplayPowerControlEXT" />
    <member name="T:vkDebugReportMessageEXT" />
    <member name="T:vkDestroyInstance">
      <summary>Destroy an instance of Vulkan</summary>
      <remarks>


Valid Usage
<list type="bullet"><item><description>

All child objects created using <c>instance</c> must have been destroyed
prior to destroying <c>instance</c>
</description></item><item><description>

If <c>VkAllocationCallbacks</c> were provided when <c>instance</c> was
created, a compatible set of callbacks  must be provided here
</description></item><item><description>

If no <c>VkAllocationCallbacks</c> were provided when <c>instance</c> was
created, <c>pAllocator</c> must be <c>NULL</c>
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
 If <c>instance</c> is not <c>NULL</c>, <c>instance</c> must be a valid <c>VkInstance</c> handle
</description></item><item><description>
 If <c>pAllocator</c> is not <c>NULL</c>, <c>pAllocator</c> must be a pointer to a valid <c>VkAllocationCallbacks</c> structure
</description></item></list>




Host Synchronization
<list type="bullet"><item><description>
Host access to <c>instance</c> must  be externally synchronized
</description></item></list>




To destroy an instance, call:


<code> void vkDestroyInstance(
    VkInstance                                  instance,
    const VkAllocationCallbacks*                pAllocator); </code>

</remarks>
      <seealso cref="T:IVkAllocationCallbacks" />
      <seealso cref="T:VkInstance" />
    </member>
    <member name="T:IVkPresentInfoKHR" />
    <member name="T:VkPresentInfoKHR32">
      <summary>See: <see cref="T:IVkPresentInfoKHR" /></summary>
      <seealso cref="T:IVkPresentInfoKHR" />
    </member>
    <member name="T:VkPresentInfoKHR64">
      <summary>See: <see cref="T:IVkPresentInfoKHR" /></summary>
      <seealso cref="T:IVkPresentInfoKHR" />
    </member>
    <member name="T:vkDestroyDescriptorSetLayout">
      <summary>Destroy a descriptor set layout object</summary>
      <remarks>


Valid Usage
<list type="bullet"><item><description>

If <c>VkAllocationCallbacks</c> were provided when
<c>descriptorSetLayout</c> was created, a compatible set of callbacks
 must be provided here
</description></item><item><description>

If no <c>VkAllocationCallbacks</c> were provided when
<c>descriptorSetLayout</c> was created, <c>pAllocator</c> must be <c>NULL</c>
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>device</c> must be a valid <c>VkDevice</c> handle
</description></item><item><description>
 If <c>descriptorSetLayout</c> is not <see cref="!:VK_NULL_HANDLE" />, <c>descriptorSetLayout</c> must be a valid <c>VkDescriptorSetLayout</c> handle
</description></item><item><description>
 If <c>pAllocator</c> is not <c>NULL</c>, <c>pAllocator</c> must be a pointer to a valid <c>VkAllocationCallbacks</c> structure
</description></item><item><description>
 If <c>descriptorSetLayout</c> is a valid handle, it  must have been created, allocated, or retrieved from <c>device</c>
</description></item></list>




Host Synchronization
<list type="bullet"><item><description>
Host access to <c>descriptorSetLayout</c> must  be externally synchronized
</description></item></list>




To destroy a descriptor set layout, call:


<code> void vkDestroyDescriptorSetLayout(
    VkDevice                                    device,
    VkDescriptorSetLayout                       descriptorSetLayout,
    const VkAllocationCallbacks*                pAllocator); </code>

</remarks>
      <seealso cref="T:IVkAllocationCallbacks" />
      <seealso cref="T:VkDescriptorSetLayout" />
      <seealso cref="T:VkDevice" />
    </member>
    <member name="T:vkGetBufferMemoryRequirements">
      <summary>Returns the memory requirements for specified Vulkan object</summary>
      <remarks>


Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>device</c> must be a valid <c>VkDevice</c> handle
</description></item><item><description>
<c>buffer</c> must be a valid <c>VkBuffer</c> handle
</description></item><item><description>
<c>pMemoryRequirements</c> must be a pointer to a <c>VkMemoryRequirements</c> structure
</description></item><item><description>
<c>buffer</c> must have been created, allocated, or retrieved from <c>device</c>
</description></item></list>




To determine the memory requirements for a buffer resource, call:


<code> void vkGetBufferMemoryRequirements(
    VkDevice                                    device,
    VkBuffer                                    buffer,
    VkMemoryRequirements*                       pMemoryRequirements); </code>

</remarks>
      <seealso cref="T:VkBuffer" />
      <seealso cref="T:VkDevice" />
      <seealso cref="T:VkMemoryRequirements" />
    </member>
    <member name="T:vkGetFenceStatus">
      <summary>Return the status of a fence</summary>
      <remarks>

Upon success, <c>vkGetFenceStatus</c> returns the status of the fence object,
with the following return codes:

<para>Table 1. Fence Object Status Codes</para><list type="table">     <listheader><tr><term>Status</term><term>Meaning</term></tr></listheader>
<item><term>
<c>VK_SUCCESS</c>
</term><term>
The fence specified by <c>fence</c> is signaled.
</term></item><item><term>
<c>VK_NOT_READY</c>
</term><term>
The fence specified by <c>fence</c> is unsignaled.
</term></item><item><term>
<c>VK_DEVICE_LOST</c>
</term><term>
The device has been lost.  See <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#devsandqueues-lost-device">Lost Device</a>.
</term></item>
</list>

If a <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#devsandqueues-submission">queue submission</a> command is pending
execution, then the value returned by this command  may immediately be out
of date.


If the device has been lost (see <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#devsandqueues-lost-device">Lost Device</a>),
<c>vkGetFenceStatus</c> may return any of the above status codes.
If the device has been lost and <c>vkGetFenceStatus</c> is called repeatedly,
it will eventually return either <c>VK_SUCCESS</c> or <c>VK_DEVICE_LOST</c>.



Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>device</c> must be a valid <c>VkDevice</c> handle
</description></item><item><description>
<c>fence</c> must be a valid <c>VkFence</c> handle
</description></item><item><description>
<c>fence</c> must have been created, allocated, or retrieved from <c>device</c>
</description></item></list>




Return Codes
<dl><dt>On success, this command returns</dt><dd>
<list type="bullet"><item><description>
<c>VK_SUCCESS</c>
</description></item><item><description>
<c>VK_NOT_READY</c>
</description></item></list>
</dd><dt>On failure, this command returns</dt><dd>
<list type="bullet"><item><description>
<c>VK_ERROR_OUT_OF_HOST_MEMORY</c>
</description></item><item><description>
<c>VK_ERROR_OUT_OF_DEVICE_MEMORY</c>
</description></item><item><description>
<c>VK_ERROR_DEVICE_LOST</c>
</description></item></list>
</dd></dl>




To query the status of a fence from the host, call:


<code> VkResult vkGetFenceStatus(
    VkDevice                                    device,
    VkFence                                     fence); </code>

</remarks>
      <seealso cref="T:VkDevice" />
      <seealso cref="T:VkFence" />
    </member>
    <member name="T:vkCmdPushDescriptorSetWithTemplateKHR" />
    <member name="T:IVkPhysicalDeviceLimits">
      <summary>Structure reporting implementation-dependent physical device limits</summary>
      <remarks>
<dl><dt>1</dt><dd>
For all bitmasks of <see cref="T:VkSampleCountFlags" />, the sample count limits
defined above represent the minimum supported sample counts for each
image type.
Individual images  may support additional sample counts, which are
queried using <see cref="T:vkGetPhysicalDeviceImageFormatProperties" /> as
described in <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-supported-sample-counts">Supported Sample
Counts</a>.
</dd></dl>


The <c>VkPhysicalDeviceLimits</c> structure is defined as:


<code> typedef struct VkPhysicalDeviceLimits {
    uint32_t              maxImageDimension1D;
    uint32_t              maxImageDimension2D;
    uint32_t              maxImageDimension3D;
    uint32_t              maxImageDimensionCube;
    uint32_t              maxImageArrayLayers;
    uint32_t              maxTexelBufferElements;
    uint32_t              maxUniformBufferRange;
    uint32_t              maxStorageBufferRange;
    uint32_t              maxPushConstantsSize;
    uint32_t              maxMemoryAllocationCount;
    uint32_t              maxSamplerAllocationCount;
    VkDeviceSize          bufferImageGranularity;
    VkDeviceSize          sparseAddressSpaceSize;
    uint32_t              maxBoundDescriptorSets;
    uint32_t              maxPerStageDescriptorSamplers;
    uint32_t              maxPerStageDescriptorUniformBuffers;
    uint32_t              maxPerStageDescriptorStorageBuffers;
    uint32_t              maxPerStageDescriptorSampledImages;
    uint32_t              maxPerStageDescriptorStorageImages;
    uint32_t              maxPerStageDescriptorInputAttachments;
    uint32_t              maxPerStageResources;
    uint32_t              maxDescriptorSetSamplers;
    uint32_t              maxDescriptorSetUniformBuffers;
    uint32_t              maxDescriptorSetUniformBuffersDynamic;
    uint32_t              maxDescriptorSetStorageBuffers;
    uint32_t              maxDescriptorSetStorageBuffersDynamic;
    uint32_t              maxDescriptorSetSampledImages;
    uint32_t              maxDescriptorSetStorageImages;
    uint32_t              maxDescriptorSetInputAttachments;
    uint32_t              maxVertexInputAttributes;
    uint32_t              maxVertexInputBindings;
    uint32_t              maxVertexInputAttributeOffset;
    uint32_t              maxVertexInputBindingStride;
    uint32_t              maxVertexOutputComponents;
    uint32_t              maxTessellationGenerationLevel;
    uint32_t              maxTessellationPatchSize;
    uint32_t              maxTessellationControlPerVertexInputComponents;
    uint32_t              maxTessellationControlPerVertexOutputComponents;
    uint32_t              maxTessellationControlPerPatchOutputComponents;
    uint32_t              maxTessellationControlTotalOutputComponents;
    uint32_t              maxTessellationEvaluationInputComponents;
    uint32_t              maxTessellationEvaluationOutputComponents;
    uint32_t              maxGeometryShaderInvocations;
    uint32_t              maxGeometryInputComponents;
    uint32_t              maxGeometryOutputComponents;
    uint32_t              maxGeometryOutputVertices;
    uint32_t              maxGeometryTotalOutputComponents;
    uint32_t              maxFragmentInputComponents;
    uint32_t              maxFragmentOutputAttachments;
    uint32_t              maxFragmentDualSrcAttachments;
    uint32_t              maxFragmentCombinedOutputResources;
    uint32_t              maxComputeSharedMemorySize;
    uint32_t              maxComputeWorkGroupCount[3];
    uint32_t              maxComputeWorkGroupInvocations;
    uint32_t              maxComputeWorkGroupSize[3];
    uint32_t              subPixelPrecisionBits;
    uint32_t              subTexelPrecisionBits;
    uint32_t              mipmapPrecisionBits;
    uint32_t              maxDrawIndexedIndexValue;
    uint32_t              maxDrawIndirectCount;
    float                 maxSamplerLodBias;
    float                 maxSamplerAnisotropy;
    uint32_t              maxViewports;
    uint32_t              maxViewportDimensions[2];
    float                 viewportBoundsRange[2];
    uint32_t              viewportSubPixelBits;
    size_t                minMemoryMapAlignment;
    VkDeviceSize          minTexelBufferOffsetAlignment;
    VkDeviceSize          minUniformBufferOffsetAlignment;
    VkDeviceSize          minStorageBufferOffsetAlignment;
    int32_t               minTexelOffset;
    uint32_t              maxTexelOffset;
    int32_t               minTexelGatherOffset;
    uint32_t              maxTexelGatherOffset;
    float                 minInterpolationOffset;
    float                 maxInterpolationOffset;
    uint32_t              subPixelInterpolationOffsetBits;
    uint32_t              maxFramebufferWidth;
    uint32_t              maxFramebufferHeight;
    uint32_t              maxFramebufferLayers;
    VkSampleCountFlags    framebufferColorSampleCounts;
    VkSampleCountFlags    framebufferDepthSampleCounts;
    VkSampleCountFlags    framebufferStencilSampleCounts;
    VkSampleCountFlags    framebufferNoAttachmentsSampleCounts;
    uint32_t              maxColorAttachments;
    VkSampleCountFlags    sampledImageColorSampleCounts;
    VkSampleCountFlags    sampledImageIntegerSampleCounts;
    VkSampleCountFlags    sampledImageDepthSampleCounts;
    VkSampleCountFlags    sampledImageStencilSampleCounts;
    VkSampleCountFlags    storageImageSampleCounts;
    uint32_t              maxSampleMaskWords;
    VkBool32              timestampComputeAndGraphics;
    float                 timestampPeriod;
    uint32_t              maxClipDistances;
    uint32_t              maxCullDistances;
    uint32_t              maxCombinedClipAndCullDistances;
    uint32_t              discreteQueuePriorities;
    float                 pointSizeRange[2];
    float                 lineWidthRange[2];
    float                 pointSizeGranularity;
    float                 lineWidthGranularity;
    VkBool32              strictLines;
    VkBool32              standardSampleLocations;
    VkDeviceSize          optimalBufferCopyOffsetAlignment;
    VkDeviceSize          optimalBufferCopyRowPitchAlignment;
    VkDeviceSize          nonCoherentAtomSize;
} VkPhysicalDeviceLimits; </code>

</remarks>
      <seealso cref="T:IVkPhysicalDeviceProperties" />
      <seealso cref="T:VkSampleCountFlags" />
    </member>
    <member name="T:VkPhysicalDeviceLimits32">
      <summary>See: <see cref="T:IVkPhysicalDeviceLimits" /></summary>
      <seealso cref="T:IVkPhysicalDeviceLimits" />
    </member>
    <member name="T:VkPhysicalDeviceLimits64">
      <summary>See: <see cref="T:IVkPhysicalDeviceLimits" /></summary>
      <seealso cref="T:IVkPhysicalDeviceLimits" />
    </member>
    <member name="T:vkCmdSetDeviceMaskKHX" />
    <member name="T:vkCreateObjectTableNVX" />
    <member name="T:vkFlushMappedMemoryRanges">
      <summary>Flush mapped memory ranges</summary>
      <remarks>

<c>vkFlushMappedMemoryRanges</c> guarantees that host writes to the memory
ranges described by <c>pMemoryRanges</c> can be made available to device
access, via <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-dependencies-available-and-visible">availability operations</a> from the <c>VK_ACCESS_HOST_WRITE_BIT</c><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-access-types">access type</a>.


Unmapping non-coherent memory does not implicitly flush the mapped memory,
and host writes that have not been flushed  may not ever be visible to the
device.
However, implementations  must ensure that writes that have not been flushed
do not become visible to any other memory.

<list type="table"><tr><td><i title="Note"></i></td><td>
Note

The above guarantee avoids a potential memory corruption in scenarios where
host writes to a mapped memory object have not been flushed before the
memory is unmapped (or freed), and the virtual address range is subsequently
reused for a different mapping (or memory allocation).

</td></tr></list>


Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>device</c> must be a valid <c>VkDevice</c> handle
</description></item><item><description>
<c>pMemoryRanges</c> must be a pointer to an array of <c>memoryRangeCount</c> valid <c>VkMappedMemoryRange</c> structures
</description></item><item><description>
<c>memoryRangeCount</c> must be greater than <c>0</c>
</description></item></list>




Return Codes
<dl><dt>On success, this command returns</dt><dd>
<list type="bullet"><item><description>
<c>VK_SUCCESS</c>
</description></item></list>
</dd><dt>On failure, this command returns</dt><dd>
<list type="bullet"><item><description>
<c>VK_ERROR_OUT_OF_HOST_MEMORY</c>
</description></item><item><description>
<c>VK_ERROR_OUT_OF_DEVICE_MEMORY</c>
</description></item></list>
</dd></dl>




To flush ranges of non-coherent memory from the host caches, call:


<code> VkResult vkFlushMappedMemoryRanges(
    VkDevice                                    device,
    uint32_t                                    memoryRangeCount,
    const VkMappedMemoryRange*                  pMemoryRanges); </code>

</remarks>
      <seealso cref="T:VkDevice" />
      <seealso cref="T:IVkMappedMemoryRange" />
    </member>
    <member name="T:vkDestroyIndirectCommandsLayoutNVX" />
    <member name="T:vkResetCommandBuffer">
      <summary>Reset a command buffer to the initial state</summary>
      <remarks>

Any primary command buffer that is in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#commandbuffers-lifecycle">recording or executable state</a> and has <c>commandBuffer</c> recorded into
it, becomes <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#commandbuffers-lifecycle">invalid</a>.



Valid Usage
<list type="bullet"><item><description>
<c>commandBuffer</c> must not be in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#commandbuffers-lifecycle">pending state</a>
</description></item><item><description>
<c>commandBuffer</c> must have been allocated from a pool that was
created with the <c>VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT</c>
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>commandBuffer</c> must be a valid <c>VkCommandBuffer</c> handle
</description></item><item><description>
<c>flags</c> must be a valid combination of <see cref="T:VkCommandBufferResetFlags" /> values
</description></item></list>




Host Synchronization
<list type="bullet"><item><description>
Host access to <c>commandBuffer</c> must  be externally synchronized
</description></item></list>




Return Codes
<dl><dt>On success, this command returns</dt><dd>
<list type="bullet"><item><description>
<c>VK_SUCCESS</c>
</description></item></list>
</dd><dt>On failure, this command returns</dt><dd>
<list type="bullet"><item><description>
<c>VK_ERROR_OUT_OF_HOST_MEMORY</c>
</description></item><item><description>
<c>VK_ERROR_OUT_OF_DEVICE_MEMORY</c>
</description></item></list>
</dd></dl>




To reset command buffers, call:


<code> VkResult vkResetCommandBuffer(
    VkCommandBuffer                             commandBuffer,
    VkCommandBufferResetFlags                   flags); </code>

</remarks>
      <seealso cref="T:VkCommandBuffer" />
      <seealso cref="T:VkCommandBufferResetFlags" />
    </member>
    <member name="T:IVkSurfaceCapabilities2EXT" />
    <member name="T:VkSurfaceCapabilities2EXT32">
      <summary>See: <see cref="T:IVkSurfaceCapabilities2EXT" /></summary>
      <seealso cref="T:IVkSurfaceCapabilities2EXT" />
    </member>
    <member name="T:VkSurfaceCapabilities2EXT64">
      <summary>See: <see cref="T:IVkSurfaceCapabilities2EXT" /></summary>
      <seealso cref="T:IVkSurfaceCapabilities2EXT" />
    </member>
    <member name="T:vkGetMemoryFdPropertiesKHX" />
    <member name="T:vkCreatePipelineCache">
      <summary>Creates a new pipeline cache</summary>
      <remarks>
<list type="table"><tr><td><i title="Note"></i></td><td>
Note

Applications  can track and manage the total host memory size of a pipeline
cache object using the <c>pAllocator</c>.
Applications  can limit the amount of data retrieved from a pipeline cache
object in <c>vkGetPipelineCacheData</c>.
Implementations  should not internally limit the total number of entries
added to a pipeline cache object or the total host memory consumed.

</td></tr></list>

Once created, a pipeline cache  can be passed to the
<c>vkCreateGraphicsPipelines</c> and <c>vkCreateComputePipelines</c> commands.
If the pipeline cache passed into these commands is not
<see cref="!:VK_NULL_HANDLE" />, the implementation will query it for possible reuse
opportunities and update it with new content.
The use of the pipeline cache object in these commands is internally
synchronized, and the same pipeline cache object  can be used in multiple
threads simultaneously.

<list type="table"><tr><td><i title="Note"></i></td><td>
Note

Implementations  should make every effort to limit any critical sections to
the actual accesses to the cache, which is expected to be significantly
shorter than the duration of the <c>vkCreateGraphicsPipelines</c> and
<c>vkCreateComputePipelines</c> commands.

</td></tr></list>


Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>device</c> must be a valid <c>VkDevice</c> handle
</description></item><item><description>
<c>pCreateInfo</c> must be a pointer to a valid <c>VkPipelineCacheCreateInfo</c> structure
</description></item><item><description>
 If <c>pAllocator</c> is not <c>NULL</c>, <c>pAllocator</c> must be a pointer to a valid <c>VkAllocationCallbacks</c> structure
</description></item><item><description>
<c>pPipelineCache</c> must be a pointer to a <c>VkPipelineCache</c> handle
</description></item></list>




Return Codes
<dl><dt>On success, this command returns</dt><dd>
<list type="bullet"><item><description>
<c>VK_SUCCESS</c>
</description></item></list>
</dd><dt>On failure, this command returns</dt><dd>
<list type="bullet"><item><description>
<c>VK_ERROR_OUT_OF_HOST_MEMORY</c>
</description></item><item><description>
<c>VK_ERROR_OUT_OF_DEVICE_MEMORY</c>
</description></item></list>
</dd></dl>




To create pipeline cache objects, call:


<code> VkResult vkCreatePipelineCache(
    VkDevice                                    device,
    const VkPipelineCacheCreateInfo*            pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkPipelineCache*                            pPipelineCache); </code>

</remarks>
      <seealso cref="T:IVkAllocationCallbacks" />
      <seealso cref="T:VkDevice" />
      <seealso cref="T:VkPipelineCache" />
      <seealso cref="T:IVkPipelineCacheCreateInfo" />
    </member>
    <member name="T:vkGetPastPresentationTimingGOOGLE" />
    <member name="T:vkCmdSetStencilWriteMask">
      <summary>Set the stencil write mask dynamic state</summary>
      <remarks>


Valid Usage
<list type="bullet"><item><description>

The currently bound graphics pipeline  must have been created with the
<c>VK_DYNAMIC_STATE_STENCIL_WRITE_MASK</c> dynamic state enabled
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>commandBuffer</c> must be a valid <c>VkCommandBuffer</c> handle
</description></item><item><description>
<c>faceMask</c> must be a valid combination of <see cref="T:VkStencilFaceFlags" /> values
</description></item><item><description>
<c>faceMask</c> must not be <c>0</c>
</description></item><item><description>
<c>commandBuffer</c> must be in the  recording state
</description></item><item><description>
 The <c>VkCommandPool</c> that <c>commandBuffer</c> was allocated from  must support graphics operations
</description></item></list>




Host Synchronization
<list type="bullet"><item><description>
Host access to <c>commandBuffer</c> must  be externally synchronized
</description></item><item><description>
Host access to the <c>VkCommandPool</c> that <c>commandBuffer</c> was allocated from  must be externally synchronized
</description></item></list>




Command Properties
<list type="table">       <listheader><tr><term> Command Buffer Levels </term><term> Render Pass Scope </term><term> Supported Queue Types </term><term> Pipeline Type </term></tr></listheader>
<item><term>
Primary<br />
Secondary
</term><term>
Both
</term><term>
Graphics
</term><term></term></item>
</list>



If the pipeline state object is created with the
<c>VK_DYNAMIC_STATE_STENCIL_WRITE_MASK</c> dynamic state enabled, then to
dynamically set the stencil write mask call:


<code> void vkCmdSetStencilWriteMask(
    VkCommandBuffer                             commandBuffer,
    VkStencilFaceFlags                          faceMask,
    uint32_t                                    writeMask); </code>

</remarks>
      <seealso cref="T:VkCommandBuffer" />
      <seealso cref="T:VkStencilFaceFlags" />
    </member>
    <member name="T:vkGetPhysicalDevicePresentRectanglesKHX" />
    <member name="T:vkDebugMarkerSetObjectTagEXT" />
    <member name="T:vkGetPhysicalDeviceDisplayPropertiesKHR" />
    <member name="T:vkDestroySampler">
      <summary>Destroy a sampler object</summary>
      <remarks>


Valid Usage
<list type="bullet"><item><description>

All submitted commands that refer to <c>sampler</c> must  have completed
execution
</description></item><item><description>

If <c>VkAllocationCallbacks</c> were provided when <c>sampler</c> was
created, a compatible set of callbacks  must be provided here
</description></item><item><description>

If no <c>VkAllocationCallbacks</c> were provided when <c>sampler</c> was
created, <c>pAllocator</c> must be <c>NULL</c>
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>device</c> must be a valid <c>VkDevice</c> handle
</description></item><item><description>
 If <c>sampler</c> is not <see cref="!:VK_NULL_HANDLE" />, <c>sampler</c> must be a valid <c>VkSampler</c> handle
</description></item><item><description>
 If <c>pAllocator</c> is not <c>NULL</c>, <c>pAllocator</c> must be a pointer to a valid <c>VkAllocationCallbacks</c> structure
</description></item><item><description>
 If <c>sampler</c> is a valid handle, it  must have been created, allocated, or retrieved from <c>device</c>
</description></item></list>




Host Synchronization
<list type="bullet"><item><description>
Host access to <c>sampler</c> must  be externally synchronized
</description></item></list>




To destroy a sampler, call:


<code> void vkDestroySampler(
    VkDevice                                    device,
    VkSampler                                   sampler,
    const VkAllocationCallbacks*                pAllocator); </code>

</remarks>
      <seealso cref="T:IVkAllocationCallbacks" />
      <seealso cref="T:VkDevice" />
      <seealso cref="T:VkSampler" />
    </member>
    <member name="T:IVkObjectTableCreateInfoNVX" />
    <member name="T:VkObjectTableCreateInfoNVX32">
      <summary>See: <see cref="T:IVkObjectTableCreateInfoNVX" /></summary>
      <seealso cref="T:IVkObjectTableCreateInfoNVX" />
    </member>
    <member name="T:VkObjectTableCreateInfoNVX64">
      <summary>See: <see cref="T:IVkObjectTableCreateInfoNVX" /></summary>
      <seealso cref="T:IVkObjectTableCreateInfoNVX" />
    </member>
    <member name="T:vkCmdDraw">
      <summary>Draw primitives</summary>
      <remarks>

When the command is executed, primitives are assembled using the current
primitive topology and <c>vertexCount</c> consecutive vertex indices with the
first <c>vertexIndex</c> value equal to <c>firstVertex</c>.
The primitives are drawn <c>instanceCount</c> times with <c>instanceIndex</c>
starting with <c>firstInstance</c> and increasing sequentially for each
instance.
The assembled primitives execute the currently bound graphics pipeline.



Valid Usage
<list type="bullet"><item><description>

The current render pass  must be <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#renderpass-compatibility">compatible</a>
with the <c>renderPass</c> member of the
<c>VkGraphicsPipelineCreateInfo</c> structure specified when creating the
<c>VkPipeline</c> currently bound to
<c>VK_PIPELINE_BIND_POINT_GRAPHICS</c>.
</description></item><item><description>

The subpass index of the current render pass  must be equal to the
<c>subpass</c> member of the <c>VkGraphicsPipelineCreateInfo</c> structure
specified when creating the <c>VkPipeline</c> currently bound to
<c>VK_PIPELINE_BIND_POINT_GRAPHICS</c>.
</description></item><item><description>

For each set  n that is statically used by the <c>VkPipeline</c>
currently bound to <c>VK_PIPELINE_BIND_POINT_GRAPHICS</c>, a descriptor
set  must have been bound to  n at
<c>VK_PIPELINE_BIND_POINT_GRAPHICS</c>, with a <c>VkPipelineLayout</c>
that is compatible for set  n, with the <c>VkPipelineLayout</c> used to
create the current <c>VkPipeline</c>, as described in
<a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#descriptorsets-compatibility">../../html/vkspec.html#descriptorsets-compatibility</a>
</description></item><item><description>

For each push constant that is statically used by the <c>VkPipeline</c>
currently bound to <c>VK_PIPELINE_BIND_POINT_GRAPHICS</c>, a push
constant value  must have been set for
<c>VK_PIPELINE_BIND_POINT_GRAPHICS</c>, with a <c>VkPipelineLayout</c>
that is compatible for push constants, with the <c>VkPipelineLayout</c>
used to create the current <c>VkPipeline</c>, as described in
<a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#descriptorsets-compatibility">../../html/vkspec.html#descriptorsets-compatibility</a>
</description></item><item><description>

Descriptors in each bound descriptor set, specified via
<c>vkCmdBindDescriptorSets</c>,  must be valid if they are statically
used by the currently bound <c>VkPipeline</c> object, specified via
<c>vkCmdBindPipeline</c>
</description></item><item><description>

All vertex input bindings accessed via vertex input variables declared
in the vertex shader entry point&amp;#8217;s interface  must have valid buffers
bound
</description></item><item><description>

For a given vertex buffer binding, any attribute data fetched  must be
entirely contained within the corresponding vertex buffer binding, as
described in <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#fxvertex-input">../../html/vkspec.html#fxvertex-input</a>
</description></item><item><description>

A valid graphics pipeline  must be bound to the current command buffer
with <c>VK_PIPELINE_BIND_POINT_GRAPHICS</c>
</description></item><item><description>

If the <c>VkPipeline</c> object currently bound to
<c>VK_PIPELINE_BIND_POINT_GRAPHICS</c> requires any dynamic state, that
state  must have been set on the current command buffer
</description></item><item><description>

Every input attachment used by the current subpass  must be bound to the
pipeline via a descriptor set
</description></item><item><description>

If any <c>VkSampler</c> object that is accessed from a shader by the
<c>VkPipeline</c> currently bound to
<c>VK_PIPELINE_BIND_POINT_GRAPHICS</c> uses unnormalized coordinates, it
 must not be used to sample from any <c>VkImage</c> with a
<c>VkImageView</c> of the type <c>VK_IMAGE_VIEW_TYPE_3D</c>,
<c>VK_IMAGE_VIEW_TYPE_CUBE</c>, <c>VK_IMAGE_VIEW_TYPE_1D_ARRAY</c>,
<c>VK_IMAGE_VIEW_TYPE_2D_ARRAY</c> or
<c>VK_IMAGE_VIEW_TYPE_CUBE_ARRAY</c>, in any shader stage
</description></item><item><description>

If any <c>VkSampler</c> object that is accessed from a shader by the
<c>VkPipeline</c> currently bound to
<c>VK_PIPELINE_BIND_POINT_GRAPHICS</c> uses unnormalized coordinates, it
 must not be used with any of the SPIR-V <c>OpImageSample*</c> or
<c>OpImageSparseSample*</c> instructions with <c>ImplicitLod</c>, <c>Dref</c> or
<c>Proj</c> in their name, in any shader stage
</description></item><item><description>

If any <c>VkSampler</c> object that is accessed from a shader by the
<c>VkPipeline</c> currently bound to
<c>VK_PIPELINE_BIND_POINT_GRAPHICS</c> uses unnormalized coordinates, it
 must not be used with any of the SPIR-V <c>OpImageSample*</c> or
<c>OpImageSparseSample*</c> instructions that includes a LOD bias or any
offset values, in any shader stage
</description></item><item><description>

If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-robustBufferAccess">robust buffer access</a>
feature is not enabled, and any shader stage in the <c>VkPipeline</c>
object currently bound to <c>VK_PIPELINE_BIND_POINT_GRAPHICS</c> accesses
a uniform buffer, it  must not access values outside of the range of
that buffer specified in the currently bound descriptor set
</description></item><item><description>

If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-robustBufferAccess">robust buffer access</a>
feature is not enabled, and any shader stage in the <c>VkPipeline</c>
object currently bound to <c>VK_PIPELINE_BIND_POINT_GRAPHICS</c> accesses
a storage buffer, it  must not access values outside of the range of
that buffer specified in the currently bound descriptor set
</description></item><item><description>

Any <c>VkImageView</c> being sampled with <c>VK_FILTER_LINEAR</c> as a
result of this command  must be of a format which supports linear
filtering, as specified by the
<c>VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT</c> flag in
<c>VkFormatProperties</c>::<c>linearTilingFeatures</c> (for a linear
image) or <c>VkFormatProperties</c>::<c>optimalTilingFeatures</c>(for an
optimally tiled image) returned by
<c>vkGetPhysicalDeviceFormatProperties</c>
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>commandBuffer</c> must be a valid <c>VkCommandBuffer</c> handle
</description></item><item><description>
<c>commandBuffer</c> must be in the  recording state
</description></item><item><description>
 The <c>VkCommandPool</c> that <c>commandBuffer</c> was allocated from  must support graphics operations
</description></item><item><description>
 This command  must only be called inside of a render pass instance
</description></item></list>




Host Synchronization
<list type="bullet"><item><description>
Host access to <c>commandBuffer</c> must  be externally synchronized
</description></item><item><description>
Host access to the <c>VkCommandPool</c> that <c>commandBuffer</c> was allocated from  must be externally synchronized
</description></item></list>




Command Properties
<list type="table">       <listheader><tr><term> Command Buffer Levels </term><term> Render Pass Scope </term><term> Supported Queue Types </term><term> Pipeline Type </term></tr></listheader>
<item><term>
Primary<br />
Secondary
</term><term>
Inside
</term><term>
Graphics
</term><term>
Graphics
</term></item>
</list>



To record a non-indexed draw, call:


<code> void vkCmdDraw(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    vertexCount,
    uint32_t                                    instanceCount,
    uint32_t                                    firstVertex,
    uint32_t                                    firstInstance); </code>

</remarks>
      <seealso cref="T:VkCommandBuffer" />
    </member>
    <member name="T:vkImportSemaphoreFdKHX" />
    <member name="T:vkDestroyPipelineLayout">
      <summary>Destroy a pipeline layout object</summary>
      <remarks>


Valid Usage
<list type="bullet"><item><description>

If <c>VkAllocationCallbacks</c> were provided when <c>pipelineLayout</c>
was created, a compatible set of callbacks  must be provided here
</description></item><item><description>

If no <c>VkAllocationCallbacks</c> were provided when
<c>pipelineLayout</c> was created, <c>pAllocator</c> must be <c>NULL</c>
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>device</c> must be a valid <c>VkDevice</c> handle
</description></item><item><description>
 If <c>pipelineLayout</c> is not <see cref="!:VK_NULL_HANDLE" />, <c>pipelineLayout</c> must be a valid <c>VkPipelineLayout</c> handle
</description></item><item><description>
 If <c>pAllocator</c> is not <c>NULL</c>, <c>pAllocator</c> must be a pointer to a valid <c>VkAllocationCallbacks</c> structure
</description></item><item><description>
 If <c>pipelineLayout</c> is a valid handle, it  must have been created, allocated, or retrieved from <c>device</c>
</description></item></list>




Host Synchronization
<list type="bullet"><item><description>
Host access to <c>pipelineLayout</c> must  be externally synchronized
</description></item></list>




To destroy a pipeline layout, call:


<code> void vkDestroyPipelineLayout(
    VkDevice                                    device,
    VkPipelineLayout                            pipelineLayout,
    const VkAllocationCallbacks*                pAllocator); </code>

</remarks>
      <seealso cref="T:IVkAllocationCallbacks" />
      <seealso cref="T:VkDevice" />
      <seealso cref="T:VkPipelineLayout" />
    </member>
    <member name="T:vkCmdWaitEvents">
      <summary>Wait for one or more events and insert a set of memory</summary>
      <remarks>

When <c>vkCmdWaitEvents</c> is submitted to a queue, it defines a memory
dependency between prior event signal operations, and subsequent commands.


The first synchronization scope only includes event signal operations that
operate on members of <c>pEvents</c>, and the operations that happened-before
the event signal operations.
Event signal operations performed by <see cref="T:vkCmdSetEvent" /> that were
previously submitted to the same queue are included in the first
synchronization scope, if the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-pipeline-stages-order">logically latest</a> pipeline stage in their <c>stageMask</c> parameter is
<a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-pipeline-stages-order">logically earlier</a> than or equal
to the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-pipeline-stages-order">logically latest</a> pipeline
stage in <c>srcStageMask</c>.
Event signal operations performed by <see cref="T:vkSetEvent" /> are only included in
the first synchronization scope if <c>VK_PIPELINE_STAGE_HOST_BIT</c> is
included in <c>srcStageMask</c>.


The second <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-dependencies-scopes">synchronization scope</a>
includes commands subsequently submitted to the same queue, including those
in the same command buffer and batch.
The second synchronization scope is limited to operations on the pipeline
stages determined by the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-pipeline-stages-masks">destination stage mask</a> specified by <c>dstStageMask</c>.


The first <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-dependencies-access-scopes">access scope</a> is
limited to access in the pipeline stages determined by the
<a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-pipeline-stages-masks">source stage mask</a> specified by
<c>srcStageMask</c>.
Within that, the first access scope only includes the first access scopes
defined by elements of the <c>pMemoryBarriers</c>,
<c>pBufferMemoryBarriers</c> and <c>pImageMemoryBarriers</c> arrays, which
each define a set of <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-memory-barriers">memory barriers</a>.
If no memory barriers are specified, then the first access scope includes no
accesses.


The second <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-dependencies-access-scopes">access scope</a> is
limited to access in the pipeline stages determined by the
<a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-pipeline-stages-masks">destination stage mask</a> specified
by <c>dstStageMask</c>.
Within that, the second access scope only includes the second access scopes
defined by elements of the <c>pMemoryBarriers</c>,
<c>pBufferMemoryBarriers</c> and <c>pImageMemoryBarriers</c> arrays, which
each define a set of <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-memory-barriers">memory barriers</a>.
If no memory barriers are specified, then the second access scope includes
no accesses.

<list type="table"><tr><td><i title="Note"></i></td><td>
Note

<see cref="T:vkCmdWaitEvents" /> is used with <see cref="T:vkCmdSetEvent" /> to define a memory
dependency between two sets of action commands, roughly in the same way as
pipeline barriers, but split into two commands such that work between the
two  may execute unhindered.

</td></tr></list>
<list type="table"><tr><td><i title="Note"></i></td><td>
Note

Applications  should be careful to avoid race conditions when using events.
There is no direct ordering guarantee between a <see cref="T:vkCmdResetEvent" />
command and a <see cref="T:vkCmdWaitEvents" /> command submitted after it, so some
other execution dependency  must be included between these commands (e.g. a
semaphore).

</td></tr></list>


Valid Usage
<list type="bullet"><item><description>
<c>srcStageMask</c> must be the bitwise OR of the <c>stageMask</c>
parameter used in previous calls to <c>vkCmdSetEvent</c> with any of the
members of <c>pEvents</c> and <c>VK_PIPELINE_STAGE_HOST_BIT</c> if any of
the members of <c>pEvents</c> was set using <c>vkSetEvent</c>
</description></item><item><description>

If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-geometryShader">geometry shaders</a> feature is
not enabled, <c>srcStageMask</c> must not contain
<c>VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT</c>
</description></item><item><description>

If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-geometryShader">geometry shaders</a> feature is
not enabled, <c>dstStageMask</c> must not contain
<c>VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT</c>
</description></item><item><description>

If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-tessellationShader">tessellation shaders</a>
feature is not enabled, <c>srcStageMask</c> must not contain
<c>VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT</c> or
<c>VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT</c>
</description></item><item><description>

If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-tessellationShader">tessellation shaders</a>
feature is not enabled, <c>dstStageMask</c> must not contain
<c>VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT</c> or
<c>VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT</c>
</description></item><item><description>

If <c>pEvents</c> includes one or more events that will be signaled by
<c>vkSetEvent</c> after <c>commandBuffer</c> has been submitted to a
queue, then <c>vkCmdWaitEvents</c> must  not be called inside a render
pass instance
</description></item><item><description>

Any pipeline stage included in <c>srcStageMask</c> or <c>dstStageMask</c> must be supported by the capabilities of the queue family specified by
the <c>queueFamilyIndex</c> member of the <see cref="T:IVkCommandPoolCreateInfo" />
structure that was used to create the <c>VkCommandPool</c> that
<c>commandBuffer</c> was allocated from, as specified in the
<a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-pipeline-stages-supported">table of supported pipeline
stages</a>.
</description></item><item><description>

Any given element of <c>pMemoryBarriers</c>, <c>pBufferMemoryBarriers</c>
or <c>pImageMemoryBarriers</c> must not have any access flag included in
its <c>srcAccessMask</c> member if that bit is not supported by any of
the pipeline stages in <c>srcStageMask</c>, as specified in the
<a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-access-types-supported">table of supported access
types</a>.
</description></item><item><description>

Any given element of <c>pMemoryBarriers</c>, <c>pBufferMemoryBarriers</c>
or <c>pImageMemoryBarriers</c> must not have any access flag included in
its <c>dstAccessMask</c> member if that bit is not supported by any of
the pipeline stages in <c>dstStageMask</c>, as specified in the
<a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-access-types-supported">table of supported access
types</a>.
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>commandBuffer</c> must be a valid <c>VkCommandBuffer</c> handle
</description></item><item><description>
<c>pEvents</c> must be a pointer to an array of <c>eventCount</c> valid <c>VkEvent</c> handles
</description></item><item><description>
<c>srcStageMask</c> must be a valid combination of <see cref="T:VkPipelineStageFlags" /> values
</description></item><item><description>
<c>srcStageMask</c> must not be <c>0</c>
</description></item><item><description>
<c>dstStageMask</c> must be a valid combination of <see cref="T:VkPipelineStageFlags" /> values
</description></item><item><description>
<c>dstStageMask</c> must not be <c>0</c>
</description></item><item><description>
 If <c>memoryBarrierCount</c> is not <c>0</c>, <c>pMemoryBarriers</c> must be a pointer to an array of <c>memoryBarrierCount</c> valid <c>VkMemoryBarrier</c> structures
</description></item><item><description>
 If <c>bufferMemoryBarrierCount</c> is not <c>0</c>, <c>pBufferMemoryBarriers</c> must be a pointer to an array of <c>bufferMemoryBarrierCount</c> valid <c>VkBufferMemoryBarrier</c> structures
</description></item><item><description>
 If <c>imageMemoryBarrierCount</c> is not <c>0</c>, <c>pImageMemoryBarriers</c> must be a pointer to an array of <c>imageMemoryBarrierCount</c> valid <c>VkImageMemoryBarrier</c> structures
</description></item><item><description>
<c>commandBuffer</c> must be in the  recording state
</description></item><item><description>
 The <c>VkCommandPool</c> that <c>commandBuffer</c> was allocated from  must support graphics, or compute operations
</description></item><item><description>
<c>eventCount</c> must be greater than <c>0</c>
</description></item><item><description>
 Both of <c>commandBuffer</c>, and the elements of <c>pEvents</c> must have been created, allocated, or retrieved from the same <c>VkDevice</c>
</description></item></list>




Host Synchronization
<list type="bullet"><item><description>
Host access to <c>commandBuffer</c> must  be externally synchronized
</description></item><item><description>
Host access to the <c>VkCommandPool</c> that <c>commandBuffer</c> was allocated from  must be externally synchronized
</description></item></list>




Command Properties
<list type="table">       <listheader><tr><term> Command Buffer Levels </term><term> Render Pass Scope </term><term> Supported Queue Types </term><term> Pipeline Type </term></tr></listheader>
<item><term>
Primary<br />
Secondary
</term><term>
Both
</term><term>
Graphics<br />
compute
</term><term></term></item>
</list>



To wait for one or more events to enter the signaled state on a device,
call:


<code> void vkCmdWaitEvents(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    eventCount,
    const VkEvent*                              pEvents,
    VkPipelineStageFlags                        srcStageMask,
    VkPipelineStageFlags                        dstStageMask,
    uint32_t                                    memoryBarrierCount,
    const VkMemoryBarrier*                      pMemoryBarriers,
    uint32_t                                    bufferMemoryBarrierCount,
    const VkBufferMemoryBarrier*                pBufferMemoryBarriers,
    uint32_t                                    imageMemoryBarrierCount,
    const VkImageMemoryBarrier*                 pImageMemoryBarriers); </code>

</remarks>
      <seealso cref="T:IVkBufferMemoryBarrier" />
      <seealso cref="T:VkCommandBuffer" />
      <seealso cref="T:VkEvent" />
      <seealso cref="T:IVkImageMemoryBarrier" />
      <seealso cref="T:IVkMemoryBarrier" />
      <seealso cref="T:VkPipelineStageFlags" />
    </member>
    <member name="T:IVkExternalImageFormatPropertiesKHX" />
    <member name="T:VkExternalImageFormatPropertiesKHX32">
      <summary>See: <see cref="T:IVkExternalImageFormatPropertiesKHX" /></summary>
      <seealso cref="T:IVkExternalImageFormatPropertiesKHX" />
    </member>
    <member name="T:VkExternalImageFormatPropertiesKHX64">
      <summary>See: <see cref="T:IVkExternalImageFormatPropertiesKHX" /></summary>
      <seealso cref="T:IVkExternalImageFormatPropertiesKHX" />
    </member>
    <member name="T:IVkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT" />
    <member name="T:VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT32">
      <summary>See: <see cref="T:IVkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT" /></summary>
      <seealso cref="T:IVkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT" />
    </member>
    <member name="T:VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT64">
      <summary>See: <see cref="T:IVkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT" /></summary>
      <seealso cref="T:IVkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT" />
    </member>
    <member name="T:VkIndirectCommandsLayoutTokenNVX" />
    <member name="T:IVkPipelineCoverageToColorStateCreateInfoNV" />
    <member name="T:VkPipelineCoverageToColorStateCreateInfoNV32">
      <summary>See: <see cref="T:IVkPipelineCoverageToColorStateCreateInfoNV" /></summary>
      <seealso cref="T:IVkPipelineCoverageToColorStateCreateInfoNV" />
    </member>
    <member name="T:VkPipelineCoverageToColorStateCreateInfoNV64">
      <summary>See: <see cref="T:IVkPipelineCoverageToColorStateCreateInfoNV" /></summary>
      <seealso cref="T:IVkPipelineCoverageToColorStateCreateInfoNV" />
    </member>
    <member name="T:vkCmdExecuteCommands">
      <summary>Execute a secondary command buffer from a primary command buffer</summary>
      <remarks>

If any element of <c>pCommandBuffers</c> was not recorded with the
<c>VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT</c> flag, and it was recorded
into any other primary command buffer which is currently in the
<a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#commandbuffers-lifecycle">executable or recording state</a>, that primary
command buffer becomes <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#commandbuffers-lifecycle">invalid</a>.



Valid Usage
<list type="bullet"><item><description>
<c>commandBuffer</c> must have been allocated with a <c>level</c> of
<c>VK_COMMAND_BUFFER_LEVEL_PRIMARY</c>
</description></item><item><description>

Any given element of <c>pCommandBuffers</c> must have been allocated
with a <c>level</c> of <c>VK_COMMAND_BUFFER_LEVEL_SECONDARY</c>
</description></item><item><description>

Any given element of <c>pCommandBuffers</c> must be in the
<a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#commandbuffers-lifecycle">pending or executable state</a>.
</description></item><item><description>

If any element of <c>pCommandBuffers</c> was not recorded with the
<c>VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT</c> flag, and it was
recorded into any other primary command buffer, that primary command
buffer  must not be in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#commandbuffers-lifecycle">pending state</a>
</description></item><item><description>

If any given element of <c>pCommandBuffers</c> was not recorded with the
<c>VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT</c> flag, it  must not be
in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#commandbuffers-lifecycle">pending state</a>.
</description></item><item><description>

If any given element of <c>pCommandBuffers</c> was not recorded with the
<c>VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT</c> flag, it  must not
have already been recorded to <c>commandBuffer</c>.
</description></item><item><description>

If any given element of <c>pCommandBuffers</c> was not recorded with the
<c>VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT</c> flag, it  must not
appear more than once in <c>pCommandBuffers</c>.
</description></item><item><description>

Any given element of <c>pCommandBuffers</c> must have been allocated
from a <c>VkCommandPool</c> that was created for the same queue family as
the <c>VkCommandPool</c> from which <c>commandBuffer</c> was allocated
</description></item><item><description>

If <c>vkCmdExecuteCommands</c> is being called within a render pass
instance, that render pass instance  must have been begun with the
<c>contents</c> parameter of <c>vkCmdBeginRenderPass</c> set to
<c>VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS</c>
</description></item><item><description>

If <c>vkCmdExecuteCommands</c> is being called within a render pass
instance, any given element of <c>pCommandBuffers</c> must have been
recorded with the <c>VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT</c>
</description></item><item><description>

If <c>vkCmdExecuteCommands</c> is being called within a render pass
instance, any given element of <c>pCommandBuffers</c> must have been
recorded with <c>VkCommandBufferInheritanceInfo</c>::<c>subpass</c> set to
the index of the subpass which the given command buffer will be executed
in
</description></item><item><description>

If <c>vkCmdExecuteCommands</c> is being called within a render pass
instance, the render passes specified in the
pname::pBeginInfo::<c>pInheritanceInfo</c>::<c>renderPass</c> members of
the <see cref="T:vkBeginCommandBuffer" /> commands used to begin recording each
element of <c>pCommandBuffers</c> must be
<a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#renderpass-compatibility">compatible</a> with the current render pass.
</description></item><item><description>

If <c>vkCmdExecuteCommands</c> is being called within a render pass
instance, and any given element of <c>pCommandBuffers</c> was recorded
with <c>VkCommandBufferInheritanceInfo</c>::<c>framebuffer</c> not equal
to <see cref="!:VK_NULL_HANDLE" />, that <c>VkFramebuffer</c> must match the
<c>VkFramebuffer</c> used in the current render pass instance
</description></item><item><description>

If <c>vkCmdExecuteCommands</c> is not being called within a render pass
instance, any given element of <c>pCommandBuffers</c> must not have been
recorded with the <c>VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT</c>
</description></item><item><description>

If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-inheritedQueries">inherited queries</a> feature
is not enabled, <c>commandBuffer</c> must not have any queries
<a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#queries-operation-active">active</a>
</description></item><item><description>

If <c>commandBuffer</c> has a <c>VK_QUERY_TYPE_OCCLUSION</c> query
<a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#queries-operation-active">active</a>, then each element of
<c>pCommandBuffers</c> must have been recorded with
<c>VkCommandBufferInheritanceInfo</c>::<c>occlusionQueryEnable</c> set to
<c>VK_TRUE</c>
</description></item><item><description>

If <c>commandBuffer</c> has a <c>VK_QUERY_TYPE_OCCLUSION</c> query
<a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#queries-operation-active">active</a>, then each element of
<c>pCommandBuffers</c> must have been recorded with
<c>VkCommandBufferInheritanceInfo</c>::<c>queryFlags</c> having all bits
set that are set for the query
</description></item><item><description>

If <c>commandBuffer</c> has a <c>VK_QUERY_TYPE_PIPELINE_STATISTICS</c>
query <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#queries-operation-active">active</a>, then each element of
<c>pCommandBuffers</c> must have been recorded with
<c>VkCommandBufferInheritanceInfo</c>::<c>pipelineStatistics</c> having
all bits set that are set in the <c>VkQueryPool</c> the query uses
</description></item><item><description>

Any given element of <c>pCommandBuffers</c> must not begin any query
types that are <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#queries-operation-active">active</a> in
<c>commandBuffer</c>
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>commandBuffer</c> must be a valid <c>VkCommandBuffer</c> handle
</description></item><item><description>
<c>pCommandBuffers</c> must be a pointer to an array of <c>commandBufferCount</c> valid <c>VkCommandBuffer</c> handles
</description></item><item><description>
<c>commandBuffer</c> must be in the  recording state
</description></item><item><description>
 The <c>VkCommandPool</c> that <c>commandBuffer</c> was allocated from  must support transfer, graphics, or compute operations
</description></item><item><description>
<c>commandBuffer</c> must be a primary <c>VkCommandBuffer</c>
</description></item><item><description>
<c>commandBufferCount</c> must be greater than <c>0</c>
</description></item><item><description>
 Both of <c>commandBuffer</c>, and the elements of <c>pCommandBuffers</c> must have been created, allocated, or retrieved from the same <c>VkDevice</c>
</description></item></list>




Host Synchronization
<list type="bullet"><item><description>
Host access to <c>commandBuffer</c> must  be externally synchronized
</description></item><item><description>
Host access to the <c>VkCommandPool</c> that <c>commandBuffer</c> was allocated from  must be externally synchronized
</description></item></list>




Command Properties
<list type="table">       <listheader><tr><term> Command Buffer Levels </term><term> Render Pass Scope </term><term> Supported Queue Types </term><term> Pipeline Type </term></tr></listheader>
<item><term>
Primary
</term><term>
Both
</term><term>
Transfer<br />
graphics<br />
compute
</term><term></term></item>
</list>



A secondary command buffer  must not be directly submitted to a queue.
Instead, secondary command buffers are recorded to execute as part of a
primary command buffer with the command:


<code> void vkCmdExecuteCommands(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    commandBufferCount,
    const VkCommandBuffer*                      pCommandBuffers); </code>

</remarks>
      <seealso cref="T:VkCommandBuffer" />
    </member>
    <member name="T:vkDebugMarkerSetObjectNameEXT" />
    <member name="T:vkDestroyQueryPool">
      <summary>Destroy a query pool object</summary>
      <remarks>


Valid Usage
<list type="bullet"><item><description>

All submitted commands that refer to <c>queryPool</c> must  have
completed execution
</description></item><item><description>

If <c>VkAllocationCallbacks</c> were provided when <c>queryPool</c> was
created, a compatible set of callbacks  must be provided here
</description></item><item><description>

If no <c>VkAllocationCallbacks</c> were provided when <c>queryPool</c> was
created, <c>pAllocator</c> must be <c>NULL</c>
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>device</c> must be a valid <c>VkDevice</c> handle
</description></item><item><description>
 If <c>queryPool</c> is not <see cref="!:VK_NULL_HANDLE" />, <c>queryPool</c> must be a valid <c>VkQueryPool</c> handle
</description></item><item><description>
 If <c>pAllocator</c> is not <c>NULL</c>, <c>pAllocator</c> must be a pointer to a valid <c>VkAllocationCallbacks</c> structure
</description></item><item><description>
 If <c>queryPool</c> is a valid handle, it  must have been created, allocated, or retrieved from <c>device</c>
</description></item></list>




Host Synchronization
<list type="bullet"><item><description>
Host access to <c>queryPool</c> must  be externally synchronized
</description></item></list>




To destroy a query pool, call:


<code> void vkDestroyQueryPool(
    VkDevice                                    device,
    VkQueryPool                                 queryPool,
    const VkAllocationCallbacks*                pAllocator); </code>

</remarks>
      <seealso cref="T:IVkAllocationCallbacks" />
      <seealso cref="T:VkDevice" />
      <seealso cref="T:VkQueryPool" />
    </member>
    <member name="T:vkCmdBlitImage">
      <summary>Copy regions of an image, potentially performing format conversion,</summary>
      <remarks>

<c>vkCmdBlitImage</c> must not be used for multisampled source or
destination images.
Use <see cref="T:vkCmdResolveImage" /> for this purpose.


As the sizes of the source and destination extents  can differ in any
dimension, texels in the source extent are scaled and filtered to the
destination extent.
Scaling occurs via the following operations:

<list type="bullet"><item><description>
For each destination texel, the integer coordinate of that texel is
converted to an unnormalized texture coordinate, using the effective
inverse of the equations described in
<a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#textures-unnormalized-to-integer">unnormalized to integer
conversion</a>:
<dl><dt></dt><dd>
 u<sub>base</sub> = i +  ½ 
</dd><dt></dt><dd>
 v<sub>base</sub> = j +  ½ 
</dd><dt></dt><dd>
 w<sub>base</sub> = k +  ½ 
</dd></dl>
</description></item><item><description>
These base coordinates are then offset by the first destination
offset:
<dl><dt></dt><dd>
 u<sub>offset</sub> = u<sub>base</sub> - x<sub>dst0</sub> 
</dd><dt></dt><dd>
 v<sub>offset</sub> = v<sub>base</sub> - y<sub>dst0</sub> 
</dd><dt></dt><dd>
 w<sub>offset</sub> = w<sub>base</sub> - z<sub>dst0</sub> 
</dd><dt></dt><dd>
 a<sub>offset</sub> = a - <c>baseArrayCount</c><sub>dst</sub> 
</dd></dl>
</description></item><item><description>
The scale is determined from the source and destination regions, and
applied to the offset coordinates:
<dl><dt></dt><dd>
 scale_u = (x<sub>src1</sub> - x<sub>src0</sub>) / (x<sub>dst1</sub> - x<sub>dst0</sub>) 
</dd><dt></dt><dd>
 scale_v = (y<sub>src1</sub> - y<sub>src0</sub>) / (y<sub>dst1</sub> - y<sub>dst0</sub>) 
</dd><dt></dt><dd>
 scale_w = (z<sub>src1</sub> - z<sub>src0</sub>) / (z<sub>dst1</sub> - z<sub>dst0</sub>) 
</dd><dt></dt><dd>
 u<sub>scaled</sub> = u<sub>offset</sub> * scale<sub>u</sub> 
</dd><dt></dt><dd>
 v<sub>scaled</sub> = v<sub>offset</sub> * scale<sub>v</sub> 
</dd><dt></dt><dd>
 w<sub>scaled</sub> = w<sub>offset</sub> * scale<sub>w</sub> 
</dd></dl>
</description></item><item><description>
Finally the source offset is added to the scaled coordinates, to
determine the final unnormalized coordinates used to sample from
<c>srcImage</c>:<br />
<dl><dt></dt><dd>
 u = u<sub>scaled</sub> +  x<sub>src0</sub> 
</dd><dt></dt><dd>
 v = v<sub>scaled</sub> +  y<sub>src0</sub> 
</dd><dt></dt><dd>
 w = w<sub>scaled</sub> +  z<sub>src0</sub> 
</dd><dt></dt><dd>
 q = <c>mipLevel</c> 
</dd><dt></dt><dd>
 a = a<sub>offset</sub> +  <c>baseArrayCount</c><sub>src</sub> 
</dd></dl>
</description></item></list>

These coordinates are used to sample from the source image, as described in
<a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#textures">Image Operations chapter</a>, with the filter mode equal to that
of <c>filter</c>, a mipmap mode of <c>VK_SAMPLER_MIPMAP_MODE_NEAREST</c> and
an address mode of <c>VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE</c>.
Implementations  must clamp at the edge of the source image, and  may
additionally clamp to the edge of the source region.

<list type="table"><tr><td><i title="Note"></i></td><td>
Note

Due to allowable rounding errors in the generation of the source texture
coordinates, it is not always possible to guarantee exactly which source
texels will be sampled for a given blit.
As rounding errors are implementation dependent, the exact results of a
blitting operation are also implementation dependent.

</td></tr></list>

Blits are done layer by layer starting with the <c>baseArrayLayer</c> member
of <c>srcSubresource</c> for the source and <c>dstSubresource</c> for the
destination.
<c>layerCount</c> layers are blitted to the destination image.


3D textures are blitted slice by slice.
Slices in the source region bounded by <c>srcOffsets</c>[0].<c>z</c> and
<c>srcOffsets</c>[1].<c>z</c> are copied to slices in the destination region
bounded by <c>dstOffsets</c>[0].<c>z</c> and <c>dstOffsets</c>[1].<c>z</c>.
For each destination slice, a source z coordinate is linearly interpolated
between <c>srcOffsets</c>[0].<c>z</c> and <c>srcOffsets</c>[1].<c>z</c>.
If the <c>filter</c> parameter is <c>VK_FILTER_LINEAR</c> then the value
sampled from the source image is taken by doing linear filtering using the
interpolated z coordinate.
If <c>filter</c> parameter is <c>VK_FILTER_NEAREST</c> then value sampled from
the source image is taken from the single nearest slice (with undefined
rounding mode).


The following filtering and conversion rules apply:

<list type="bullet"><item><description>
Integer formats  can only be converted to other integer formats with the
same signedness.
</description></item><item><description>
No format conversion is supported between depth/stencil images.
The formats  must match.
</description></item><item><description>
Format conversions on unorm, snorm, unscaled and packed float formats of
the copied aspect of the image are performed by first converting the
pixels to float values.
</description></item><item><description>
For sRGB source formats, nonlinear RGB values are converted to linear
representation prior to filtering.
</description></item><item><description>
After filtering, the float values are first clamped and then cast to the
destination image format.
In case of sRGB destination format, linear RGB values are converted to
nonlinear representation before writing the pixel to the image.
</description></item></list>

Signed and unsigned integers are converted by first clamping to the
representable range of the destination format, then casting the value.



Valid Usage
<list type="bullet"><item><description>

The source region specified by a given element of <c>pRegions</c> must
be a region that is contained within <c>srcImage</c>
</description></item><item><description>

The destination region specified by a given element of <c>pRegions</c> must be a region that is contained within <c>dstImage</c>
</description></item><item><description>

The union of all destination regions, specified by the elements of
<c>pRegions</c>,  must not overlap in memory with any texel that  may be
sampled during the blit operation
</description></item><item><description>
<c>srcImage</c> must use a format that supports
<c>VK_FORMAT_FEATURE_BLIT_SRC_BIT</c>, which is indicated by
<c>VkFormatProperties</c>::<c>linearTilingFeatures</c> (for linearly tiled
images) or <c>VkFormatProperties</c>::<c>optimalTilingFeatures</c> (for
optimally tiled images) - as returned by
<c>vkGetPhysicalDeviceFormatProperties</c>
</description></item><item><description>
<c>srcImage</c> must have been created with
<c>VK_IMAGE_USAGE_TRANSFER_SRC_BIT</c> usage flag
</description></item><item><description>

If <c>srcImage</c> is non-sparse then it  must be bound completely and
contiguously to a single <c>VkDeviceMemory</c> object
</description></item><item><description>
<c>srcImageLayout</c> must specify the layout of the image subresources
of <c>srcImage</c> specified in <c>pRegions</c> at the time this command
is executed on a <c>VkDevice</c>
</description></item><item><description>
<c>srcImageLayout</c> must be <c>VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL</c>
or <c>VK_IMAGE_LAYOUT_GENERAL</c>
</description></item><item><description>
<c>dstImage</c> must use a format that supports
<c>VK_FORMAT_FEATURE_BLIT_DST_BIT</c>, which is indicated by
<c>VkFormatProperties</c>::<c>linearTilingFeatures</c> (for linearly tiled
images) or <c>VkFormatProperties</c>::<c>optimalTilingFeatures</c> (for
optimally tiled images) - as returned by
<c>vkGetPhysicalDeviceFormatProperties</c>
</description></item><item><description>
<c>dstImage</c> must have been created with
<c>VK_IMAGE_USAGE_TRANSFER_DST_BIT</c> usage flag
</description></item><item><description>

If <c>dstImage</c> is non-sparse then it  must be bound completely and
contiguously to a single <c>VkDeviceMemory</c> object
</description></item><item><description>
<c>dstImageLayout</c> must specify the layout of the image subresources
of <c>dstImage</c> specified in <c>pRegions</c> at the time this command
is executed on a <c>VkDevice</c>
</description></item><item><description>
<c>dstImageLayout</c> must be <c>VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL</c>
or <c>VK_IMAGE_LAYOUT_GENERAL</c>
</description></item><item><description>

The sample count of <c>srcImage</c> and <c>dstImage</c> must both be
equal to <c>VK_SAMPLE_COUNT_1_BIT</c>
</description></item><item><description>

If either of <c>srcImage</c> or <c>dstImage</c> was created with a signed
integer <see cref="T:VkFormat" />, the other  must also have been created with a
signed integer <see cref="T:VkFormat" />
</description></item><item><description>

If either of <c>srcImage</c> or <c>dstImage</c> was created with an
unsigned integer <see cref="T:VkFormat" />, the other  must also have been created
with an unsigned integer <see cref="T:VkFormat" />
</description></item><item><description>

If either of <c>srcImage</c> or <c>dstImage</c> was created with a
depth/stencil format, the other  must have exactly the same format
</description></item><item><description>

If <c>srcImage</c> was created with a depth/stencil format, <c>filter</c> must be <c>VK_FILTER_NEAREST</c>
</description></item><item><description>
<c>srcImage</c> must have been created with a <c>samples</c> value of
<c>VK_SAMPLE_COUNT_1_BIT</c>
</description></item><item><description>
<c>dstImage</c> must have been created with a <c>samples</c> value of
<c>VK_SAMPLE_COUNT_1_BIT</c>
</description></item><item><description>

If <c>filter</c> is <c>VK_FILTER_LINEAR</c>, <c>srcImage</c> must be of a
format which supports linear filtering, as specified by the
<c>VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT</c> flag in
<c>VkFormatProperties</c>::<c>linearTilingFeatures</c> (for a linear
image) or <c>VkFormatProperties</c>::<c>optimalTilingFeatures</c>(for an
optimally tiled image) returned by
<c>vkGetPhysicalDeviceFormatProperties</c>
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>commandBuffer</c> must be a valid <c>VkCommandBuffer</c> handle
</description></item><item><description>
<c>srcImage</c> must be a valid <c>VkImage</c> handle
</description></item><item><description>
<c>srcImageLayout</c> must be a valid <see cref="T:VkImageLayout" /> value
</description></item><item><description>
<c>dstImage</c> must be a valid <c>VkImage</c> handle
</description></item><item><description>
<c>dstImageLayout</c> must be a valid <see cref="T:VkImageLayout" /> value
</description></item><item><description>
<c>pRegions</c> must be a pointer to an array of <c>regionCount</c> valid <c>VkImageBlit</c> structures
</description></item><item><description>
<c>filter</c> must be a valid <see cref="T:VkFilter" /> value
</description></item><item><description>
<c>commandBuffer</c> must be in the  recording state
</description></item><item><description>
 The <c>VkCommandPool</c> that <c>commandBuffer</c> was allocated from  must support graphics operations
</description></item><item><description>
 This command  must only be called outside of a render pass instance
</description></item><item><description>
<c>regionCount</c> must be greater than <c>0</c>
</description></item><item><description>
 Each of <c>commandBuffer</c>, <c>dstImage</c>, and <c>srcImage</c> must have been created, allocated, or retrieved from the same <c>VkDevice</c>
</description></item></list>




Host Synchronization
<list type="bullet"><item><description>
Host access to <c>commandBuffer</c> must  be externally synchronized
</description></item><item><description>
Host access to the <c>VkCommandPool</c> that <c>commandBuffer</c> was allocated from  must be externally synchronized
</description></item></list>




Command Properties
<list type="table">       <listheader><tr><term> Command Buffer Levels </term><term> Render Pass Scope </term><term> Supported Queue Types </term><term> Pipeline Type </term></tr></listheader>
<item><term>
Primary<br />
Secondary
</term><term>
Outside
</term><term>
Graphics
</term><term>
Transfer
</term></item>
</list>



To copy regions of a source image into a destination image, potentially
performing format conversion, arbitrary scaling, and filtering, call:


<code> void vkCmdBlitImage(
    VkCommandBuffer                             commandBuffer,
    VkImage                                     srcImage,
    VkImageLayout                               srcImageLayout,
    VkImage                                     dstImage,
    VkImageLayout                               dstImageLayout,
    uint32_t                                    regionCount,
    const VkImageBlit*                          pRegions,
    VkFilter                                    filter); </code>

</remarks>
      <seealso cref="T:VkCommandBuffer" />
      <seealso cref="T:VkFilter" />
      <seealso cref="T:VkImage" />
      <seealso cref="T:VkImageBlit" />
      <seealso cref="T:VkImageLayout" />
    </member>
    <member name="T:vkInvalidateMappedMemoryRanges">
      <summary>Invalidate ranges of mapped memory objects</summary>
      <remarks>

<c>vkInvalidateMappedMemoryRanges</c> guarantees that device writes to the
memory ranges described by <c>pMemoryRanges</c>, which have been made visible
to the <c>VK_ACCESS_HOST_WRITE_BIT</c> and <c>VK_ACCESS_HOST_READ_BIT</c><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-access-types">access types</a>, are made visible to the
host.
If a range of non-coherent memory is written by the host and then
invalidated without first being flushed, its contents are undefined.

<list type="table"><tr><td><i title="Note"></i></td><td>
Note

Mapping non-coherent memory does not implicitly invalidate the mapped
memory, and device writes that have not been invalidated  must be made
visible before the host reads or overwrites them.

</td></tr></list>


Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>device</c> must be a valid <c>VkDevice</c> handle
</description></item><item><description>
<c>pMemoryRanges</c> must be a pointer to an array of <c>memoryRangeCount</c> valid <c>VkMappedMemoryRange</c> structures
</description></item><item><description>
<c>memoryRangeCount</c> must be greater than <c>0</c>
</description></item></list>




Return Codes
<dl><dt>On success, this command returns</dt><dd>
<list type="bullet"><item><description>
<c>VK_SUCCESS</c>
</description></item></list>
</dd><dt>On failure, this command returns</dt><dd>
<list type="bullet"><item><description>
<c>VK_ERROR_OUT_OF_HOST_MEMORY</c>
</description></item><item><description>
<c>VK_ERROR_OUT_OF_DEVICE_MEMORY</c>
</description></item></list>
</dd></dl>




To invalidate ranges of non-coherent memory from the host caches, call:


<code> VkResult vkInvalidateMappedMemoryRanges(
    VkDevice                                    device,
    uint32_t                                    memoryRangeCount,
    const VkMappedMemoryRange*                  pMemoryRanges); </code>

</remarks>
      <seealso cref="T:VkDevice" />
      <seealso cref="T:IVkMappedMemoryRange" />
    </member>
    <member name="T:IVkDisplayEventInfoEXT" />
    <member name="T:VkDisplayEventInfoEXT32">
      <summary>See: <see cref="T:IVkDisplayEventInfoEXT" /></summary>
      <seealso cref="T:IVkDisplayEventInfoEXT" />
    </member>
    <member name="T:VkDisplayEventInfoEXT64">
      <summary>See: <see cref="T:IVkDisplayEventInfoEXT" /></summary>
      <seealso cref="T:IVkDisplayEventInfoEXT" />
    </member>
    <member name="T:VkObjectTablePushConstantEntryNVX" />
    <member name="T:IVkCmdProcessCommandsInfoNVX" />
    <member name="T:VkCmdProcessCommandsInfoNVX32">
      <summary>See: <see cref="T:IVkCmdProcessCommandsInfoNVX" /></summary>
      <seealso cref="T:IVkCmdProcessCommandsInfoNVX" />
    </member>
    <member name="T:VkCmdProcessCommandsInfoNVX64">
      <summary>See: <see cref="T:IVkCmdProcessCommandsInfoNVX" /></summary>
      <seealso cref="T:IVkCmdProcessCommandsInfoNVX" />
    </member>
    <member name="T:vkDestroyBufferView">
      <summary>Destroy a buffer view object</summary>
      <remarks>


Valid Usage
<list type="bullet"><item><description>

All submitted commands that refer to <c>bufferView</c> must  have
completed execution
</description></item><item><description>

If <c>VkAllocationCallbacks</c> were provided when <c>bufferView</c> was
created, a compatible set of callbacks  must be provided here
</description></item><item><description>

If no <c>VkAllocationCallbacks</c> were provided when <c>bufferView</c>
was created, <c>pAllocator</c> must be <c>NULL</c>
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>device</c> must be a valid <c>VkDevice</c> handle
</description></item><item><description>
 If <c>bufferView</c> is not <see cref="!:VK_NULL_HANDLE" />, <c>bufferView</c> must be a valid <c>VkBufferView</c> handle
</description></item><item><description>
 If <c>pAllocator</c> is not <c>NULL</c>, <c>pAllocator</c> must be a pointer to a valid <c>VkAllocationCallbacks</c> structure
</description></item><item><description>
 If <c>bufferView</c> is a valid handle, it  must have been created, allocated, or retrieved from <c>device</c>
</description></item></list>




Host Synchronization
<list type="bullet"><item><description>
Host access to <c>bufferView</c> must  be externally synchronized
</description></item></list>




To destroy a buffer view, call:


<code> void vkDestroyBufferView(
    VkDevice                                    device,
    VkBufferView                                bufferView,
    const VkAllocationCallbacks*                pAllocator); </code>

</remarks>
      <seealso cref="T:IVkAllocationCallbacks" />
      <seealso cref="T:VkBufferView" />
      <seealso cref="T:VkDevice" />
    </member>
    <member name="T:VkImageSubresource">
      <summary>Structure specifying a image subresource</summary>
      <remarks>


Valid Usage
<list type="bullet"><item><description>
<c>mipLevel</c> must be less than the <c>mipLevels</c> specified in
<see cref="T:IVkImageCreateInfo" /> when the image was created
</description></item><item><description>
<c>arrayLayer</c> must be less than the <c>arrayLayers</c> specified in
<see cref="T:IVkImageCreateInfo" /> when the image was created
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>aspectMask</c> must be a valid combination of <see cref="T:VkImageAspectFlags" /> values
</description></item><item><description>
<c>aspectMask</c> must not be <c>0</c>
</description></item></list>




The <c>VkImageSubresource</c> structure is defined as:


<code> typedef struct VkImageSubresource {
    VkImageAspectFlags    aspectMask;
    uint32_t              mipLevel;
    uint32_t              arrayLayer;
} VkImageSubresource; </code>

</remarks>
      <seealso cref="T:VkImageAspectFlags" />
      <seealso cref="T:VkSparseImageMemoryBind" />
      <seealso cref="T:vkGetImageSubresourceLayout" />
    </member>
    <member name="T:vkGetPhysicalDeviceSurfaceCapabilities2KHR" />
    <member name="T:vkDestroyPipeline">
      <summary>Destroy a pipeline object</summary>
      <remarks>


Valid Usage
<list type="bullet"><item><description>

All submitted commands that refer to <c>pipeline</c> must  have completed
execution
</description></item><item><description>

If <c>VkAllocationCallbacks</c> were provided when <c>pipeline</c> was
created, a compatible set of callbacks  must be provided here
</description></item><item><description>

If no <c>VkAllocationCallbacks</c> were provided when <c>pipeline</c> was
created, <c>pAllocator</c> must be <c>NULL</c>
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>device</c> must be a valid <c>VkDevice</c> handle
</description></item><item><description>
 If <c>pipeline</c> is not <see cref="!:VK_NULL_HANDLE" />, <c>pipeline</c> must be a valid <c>VkPipeline</c> handle
</description></item><item><description>
 If <c>pAllocator</c> is not <c>NULL</c>, <c>pAllocator</c> must be a pointer to a valid <c>VkAllocationCallbacks</c> structure
</description></item><item><description>
 If <c>pipeline</c> is a valid handle, it  must have been created, allocated, or retrieved from <c>device</c>
</description></item></list>




Host Synchronization
<list type="bullet"><item><description>
Host access to <c>pipeline</c> must  be externally synchronized
</description></item></list>




To destroy a graphics or compute pipeline, call:


<code> void vkDestroyPipeline(
    VkDevice                                    device,
    VkPipeline                                  pipeline,
    const VkAllocationCallbacks*                pAllocator); </code>

</remarks>
      <seealso cref="T:IVkAllocationCallbacks" />
      <seealso cref="T:VkDevice" />
      <seealso cref="T:VkPipeline" />
    </member>
    <member name="T:vkCreateQueryPool">
      <summary>Create a new query pool object</summary>
      <remarks>


Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>device</c> must be a valid <c>VkDevice</c> handle
</description></item><item><description>
<c>pCreateInfo</c> must be a pointer to a valid <c>VkQueryPoolCreateInfo</c> structure
</description></item><item><description>
 If <c>pAllocator</c> is not <c>NULL</c>, <c>pAllocator</c> must be a pointer to a valid <c>VkAllocationCallbacks</c> structure
</description></item><item><description>
<c>pQueryPool</c> must be a pointer to a <c>VkQueryPool</c> handle
</description></item></list>




Return Codes
<dl><dt>On success, this command returns</dt><dd>
<list type="bullet"><item><description>
<c>VK_SUCCESS</c>
</description></item></list>
</dd><dt>On failure, this command returns</dt><dd>
<list type="bullet"><item><description>
<c>VK_ERROR_OUT_OF_HOST_MEMORY</c>
</description></item><item><description>
<c>VK_ERROR_OUT_OF_DEVICE_MEMORY</c>
</description></item></list>
</dd></dl>




To create a query pool, call:


<code> VkResult vkCreateQueryPool(
    VkDevice                                    device,
    const VkQueryPoolCreateInfo*                pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkQueryPool*                                pQueryPool); </code>

</remarks>
      <seealso cref="T:IVkAllocationCallbacks" />
      <seealso cref="T:VkDevice" />
      <seealso cref="T:VkQueryPool" />
      <seealso cref="T:IVkQueryPoolCreateInfo" />
    </member>
    <member name="T:vkCmdSetEvent">
      <summary>Set an event object to signaled state</summary>
      <remarks>

When <see cref="T:vkCmdSetEvent" /> is submitted to a queue, it defines an execution
dependency on commands that were submitted before it, and defines an event
signal operation which sets the event to the signaled state.


The first <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-dependencies-scopes">synchronization scope</a>
includes every command previously submitted to the same queue, including
those in the same command buffer and batch.
The synchronization scope is limited to operations on the pipeline stages
determined by the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-pipeline-stages-masks">source stage
mask</a> specified by <c>stageMask</c>.


The second <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-dependencies-scopes">synchronization scope</a>
includes only the event signal operation.


If <c>event</c> is already in the signaled state when <see cref="T:vkCmdSetEvent" /> is
executed on the device, then <see cref="T:vkCmdSetEvent" /> has no effect, no event
signal operation occurs, and no execution dependency is generated.



Valid Usage
<list type="bullet"><item><description>
<c>stageMask</c> must not include <c>VK_PIPELINE_STAGE_HOST_BIT</c>
</description></item><item><description>

If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-geometryShader">geometry shaders</a> feature is
not enabled, <c>stageMask</c> must not contain
<c>VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT</c>
</description></item><item><description>

If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-tessellationShader">tessellation shaders</a>
feature is not enabled, <c>stageMask</c> must not contain
<c>VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT</c> or
<c>VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT</c>
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>commandBuffer</c> must be a valid <c>VkCommandBuffer</c> handle
</description></item><item><description>
<c>event</c> must be a valid <c>VkEvent</c> handle
</description></item><item><description>
<c>stageMask</c> must be a valid combination of <see cref="T:VkPipelineStageFlags" /> values
</description></item><item><description>
<c>stageMask</c> must not be <c>0</c>
</description></item><item><description>
<c>commandBuffer</c> must be in the  recording state
</description></item><item><description>
 The <c>VkCommandPool</c> that <c>commandBuffer</c> was allocated from  must support graphics, or compute operations
</description></item><item><description>
 This command  must only be called outside of a render pass instance
</description></item><item><description>
 Both of <c>commandBuffer</c>, and <c>event</c> must have been created, allocated, or retrieved from the same <c>VkDevice</c>
</description></item></list>




Host Synchronization
<list type="bullet"><item><description>
Host access to <c>commandBuffer</c> must  be externally synchronized
</description></item><item><description>
Host access to the <c>VkCommandPool</c> that <c>commandBuffer</c> was allocated from  must be externally synchronized
</description></item></list>




Command Properties
<list type="table">       <listheader><tr><term> Command Buffer Levels </term><term> Render Pass Scope </term><term> Supported Queue Types </term><term> Pipeline Type </term></tr></listheader>
<item><term>
Primary<br />
Secondary
</term><term>
Outside
</term><term>
Graphics<br />
compute
</term><term></term></item>
</list>



To set the state of an event to signaled from a device, call:


<code> void vkCmdSetEvent(
    VkCommandBuffer                             commandBuffer,
    VkEvent                                     event,
    VkPipelineStageFlags                        stageMask); </code>

</remarks>
      <seealso cref="T:VkCommandBuffer" />
      <seealso cref="T:VkEvent" />
      <seealso cref="T:VkPipelineStageFlags" />
    </member>
    <member name="T:vkRegisterDeviceEventEXT" />
    <member name="T:vkGetRenderAreaGranularity">
      <summary>Returns the granularity for optimal render area</summary>
      <remarks>

The conditions leading to an optimal <c>renderArea</c> are:

<list type="bullet"><item><description>
the <c>offset.x</c> member in <c>renderArea</c> is a multiple of the
<c>width</c> member of the returned <see cref="T:VkExtent2D" /> (the horizontal
granularity).
</description></item><item><description>
the <c>offset.y</c> member in <c>renderArea</c> is a multiple of the
<c>height</c> of the returned <see cref="T:VkExtent2D" /> (the vertical
granularity).
</description></item><item><description>
either the <c>offset.width</c> member in <c>renderArea</c> is a multiple
of the horizontal granularity or <c>offset.x</c>+<c>offset.width</c> is
equal to the <c>width</c> of the <c>framebuffer</c> in the
<see cref="T:IVkRenderPassBeginInfo" />.
</description></item><item><description>
either the <c>offset.height</c> member in <c>renderArea</c> is a multiple
of the vertical granularity or <c>offset.y</c>+<c>offset.height</c> is
equal to the <c>height</c> of the <c>framebuffer</c> in the
<see cref="T:IVkRenderPassBeginInfo" />.
</description></item></list>

Subpass dependencies are not affected by the render area, and apply to the
entire image subresources attached to the framebuffer.
Similarly, pipeline barriers are valid even if their effect extends outside
the render area.



Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>device</c> must be a valid <c>VkDevice</c> handle
</description></item><item><description>
<c>renderPass</c> must be a valid <c>VkRenderPass</c> handle
</description></item><item><description>
<c>pGranularity</c> must be a pointer to a <c>VkExtent2D</c> structure
</description></item><item><description>
<c>renderPass</c> must have been created, allocated, or retrieved from <c>device</c>
</description></item></list>




To query the render area granularity, call:


<code> void vkGetRenderAreaGranularity(
    VkDevice                                    device,
    VkRenderPass                                renderPass,
    VkExtent2D*                                 pGranularity); </code>

</remarks>
      <seealso cref="T:VkDevice" />
      <seealso cref="T:VkExtent2D" />
      <seealso cref="T:VkRenderPass" />
    </member>
    <member name="T:vkWaitForFences">
      <summary>Wait for one or more fences to become signaled</summary>
      <remarks>

If the condition is satisfied when <c>vkWaitForFences</c> is called, then
<c>vkWaitForFences</c> returns immediately.
If the condition is not satisfied at the time <c>vkWaitForFences</c> is
called, then <c>vkWaitForFences</c> will block and wait up to <c>timeout</c>
nanoseconds for the condition to become satisfied.


If <c>timeout</c> is zero, then <c>vkWaitForFences</c> does not wait, but
simply returns the current state of the fences.
<c>VK_TIMEOUT</c> will be returned in this case if the condition is not
satisfied, even though no actual wait was performed.


If the specified timeout period expires before the condition is satisfied,
<c>vkWaitForFences</c> returns <c>VK_TIMEOUT</c>.
If the condition is satisfied before <c>timeout</c> nanoseconds has expired,
<c>vkWaitForFences</c> returns <c>VK_SUCCESS</c>.


If device loss occurs (see <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#devsandqueues-lost-device">Lost Device</a>) before
the timeout has expired, <c>vkWaitForFences</c> must return in finite time
with either <c>VK_SUCCESS</c> or <c>VK_DEVICE_LOST</c>.

<list type="table"><tr><td><i title="Note"></i></td><td>
Note

While we guarantee that <c>vkWaitForFences</c> must return in finite time,
no guarantees are made that it returns immediately upon device loss.
However, the client can reasonably expect that the delay will be on the
order of seconds and that calling <c>vkWaitForFences</c> will not result in a
permanently (or seemingly permanently) dead process.

</td></tr></list>


Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>device</c> must be a valid <c>VkDevice</c> handle
</description></item><item><description>
<c>pFences</c> must be a pointer to an array of <c>fenceCount</c> valid <c>VkFence</c> handles
</description></item><item><description>
<c>fenceCount</c> must be greater than <c>0</c>
</description></item><item><description>
 Each element of <c>pFences</c> must have been created, allocated, or retrieved from <c>device</c>
</description></item></list>




Return Codes
<dl><dt>On success, this command returns</dt><dd>
<list type="bullet"><item><description>
<c>VK_SUCCESS</c>
</description></item><item><description>
<c>VK_TIMEOUT</c>
</description></item></list>
</dd><dt>On failure, this command returns</dt><dd>
<list type="bullet"><item><description>
<c>VK_ERROR_OUT_OF_HOST_MEMORY</c>
</description></item><item><description>
<c>VK_ERROR_OUT_OF_DEVICE_MEMORY</c>
</description></item><item><description>
<c>VK_ERROR_DEVICE_LOST</c>
</description></item></list>
</dd></dl>




To wait for one or more fences to enter the signaled state on the host,
call:


<code> VkResult vkWaitForFences(
    VkDevice                                    device,
    uint32_t                                    fenceCount,
    const VkFence*                              pFences,
    VkBool32                                    waitAll,
    uint64_t                                    timeout); </code>

</remarks>
      <seealso cref="T:VkDevice" />
      <seealso cref="T:VkFence" />
    </member>
    <member name="T:vkEndCommandBuffer">
      <summary>Finish recording a command buffer</summary>
      <remarks>

If there was an error during recording, the application will be notified by
an unsuccessful return code returned by <c>vkEndCommandBuffer</c>.
If the application wishes to further use the command buffer, the command
buffer  must be reset.
The command buffer  must have been in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#commandbuffers-lifecycle">recording state</a>, and is moved to the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#commandbuffers-lifecycle">executable state</a>.



Valid Usage
<list type="bullet"><item><description>
<c>commandBuffer</c> must be in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#commandbuffers-lifecycle">recording state</a>.
</description></item><item><description>

If <c>commandBuffer</c> is a primary command buffer, there  must not be
an active render pass instance
</description></item><item><description>

All queries made <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#queries-operation-active">active</a> during the
recording of <c>commandBuffer</c> must  have been made inactive
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>commandBuffer</c> must be a valid <c>VkCommandBuffer</c> handle
</description></item></list>




Host Synchronization
<list type="bullet"><item><description>
Host access to <c>commandBuffer</c> must  be externally synchronized
</description></item><item><description>
Host access to the <c>VkCommandPool</c> that <c>commandBuffer</c> was allocated from  must be externally synchronized
</description></item></list>




Return Codes
<dl><dt>On success, this command returns</dt><dd>
<list type="bullet"><item><description>
<c>VK_SUCCESS</c>
</description></item></list>
</dd><dt>On failure, this command returns</dt><dd>
<list type="bullet"><item><description>
<c>VK_ERROR_OUT_OF_HOST_MEMORY</c>
</description></item><item><description>
<c>VK_ERROR_OUT_OF_DEVICE_MEMORY</c>
</description></item></list>
</dd></dl>




To complete recording of a command buffer, call:


<code> VkResult vkEndCommandBuffer(
    VkCommandBuffer                             commandBuffer); </code>

</remarks>
      <seealso cref="T:VkCommandBuffer" />
    </member>
    <member name="T:IVkBufferCreateInfo">
      <summary>Structure specifying the parameters of a newly created buffer object</summary>
      <remarks>
<list type="table"><tr><td><i title="Note"></i></td><td>
editing-note

(Jon) Should the constraint on usage != 0 be converted to a Valid Usage
statement? See gitlab #854.

</td></tr></list>


Valid Usage
<list type="bullet"><item><description>
<c>size</c> must be greater than <c>0</c>
</description></item><item><description>

If <c>sharingMode</c> is <c>VK_SHARING_MODE_CONCURRENT</c>,
<c>pQueueFamilyIndices</c> must be a pointer to an array of
<c>queueFamilyIndexCount</c><c>uint32_t</c> values
</description></item><item><description>

If <c>sharingMode</c> is <c>VK_SHARING_MODE_CONCURRENT</c>,
<c>queueFamilyIndexCount</c> must be greater than <c>1</c>
</description></item><item><description>

If <c>sharingMode</c> is <c>VK_SHARING_MODE_CONCURRENT</c>, each element
of <c>pQueueFamilyIndices</c> must be unique and  must be less than
<c>pQueueFamilyPropertyCount</c> returned by
<see cref="T:vkGetPhysicalDeviceQueueFamilyProperties" /> for the
<c>physicalDevice</c> that was used to create <c>device</c>
</description></item><item><description>

If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-sparseBinding">sparse bindings</a> feature is
not enabled, <c>flags</c> must not contain
<c>VK_BUFFER_CREATE_SPARSE_BINDING_BIT</c>
</description></item><item><description>

If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-sparseResidencyBuffer">sparse buffer
residency</a> feature is not enabled, <c>flags</c> must not contain
<c>VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT</c>
</description></item><item><description>

If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-sparseResidencyAliased">sparse aliased
residency</a> feature is not enabled, <c>flags</c> must not contain
<c>VK_BUFFER_CREATE_SPARSE_ALIASED_BIT</c>
</description></item><item><description>

If <c>flags</c> contains <c>VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT</c> or
<c>VK_BUFFER_CREATE_SPARSE_ALIASED_BIT</c>, it  must also contain
<c>VK_BUFFER_CREATE_SPARSE_BINDING_BIT</c>
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>sType</c> must be <c>VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO</c>
</description></item><item><description>
<c>pNext</c> must be <c>NULL</c>
</description></item><item><description>
<c>flags</c> must be a valid combination of <see cref="T:VkBufferCreateFlags" /> values
</description></item><item><description>
<c>usage</c> must be a valid combination of <see cref="T:VkBufferUsageFlags" /> values
</description></item><item><description>
<c>usage</c> must not be <c>0</c>
</description></item><item><description>
<c>sharingMode</c> must be a valid <see cref="T:VkSharingMode" /> value
</description></item></list>




The <c>VkBufferCreateInfo</c> structure is defined as:


<code> typedef struct VkBufferCreateInfo {
    VkStructureType        sType;
    const void*            pNext;
    VkBufferCreateFlags    flags;
    VkDeviceSize           size;
    VkBufferUsageFlags     usage;
    VkSharingMode          sharingMode;
    uint32_t               queueFamilyIndexCount;
    const uint32_t*        pQueueFamilyIndices;
} VkBufferCreateInfo; </code>

</remarks>
      <seealso cref="T:VkBufferCreateFlags" />
      <seealso cref="T:VkBufferUsageFlags" />
      <seealso cref="T:VkSharingMode" />
      <seealso cref="T:VkStructureType" />
      <seealso cref="T:vkCreateBuffer" />
    </member>
    <member name="T:VkBufferCreateInfo32">
      <summary>See: <see cref="T:IVkBufferCreateInfo" /></summary>
      <seealso cref="T:IVkBufferCreateInfo" />
    </member>
    <member name="T:VkBufferCreateInfo64">
      <summary>See: <see cref="T:IVkBufferCreateInfo" /></summary>
      <seealso cref="T:IVkBufferCreateInfo" />
    </member>
    <member name="T:vkAcquireNextImageKHR" />
    <member name="T:vkCreateDevice">
      <summary>Create a new device instance</summary>
      <remarks>

<c>vkCreateDevice</c> verifies that extensions and features requested in the
<c>ppEnabledExtensionNames</c> and <c>pEnabledFeatures</c> members of
<c>pCreateInfo</c>, respectively, are supported by the implementation.
If any requested extension is not supported, <c>vkCreateDevice</c> must
return <c>VK_ERROR_EXTENSION_NOT_PRESENT</c>.
If any requested feature is not supported, <c>vkCreateDevice</c> must return
<c>VK_ERROR_FEATURE_NOT_PRESENT</c>.
Support for extensions  can be checked before creating a device by querying
<see cref="T:vkEnumerateDeviceExtensionProperties" />.
Support for features  can similarly be checked by querying
<see cref="T:vkGetPhysicalDeviceFeatures" />.


After verifying and enabling the extensions the <c>VkDevice</c> object is
created and returned to the application.
If a requested extension is only supported by a layer, both the layer and
the extension need to be specified at <c>vkCreateInstance</c> time for the
creation to succeed.


Multiple logical devices  can be created from the same physical device.
Logical device creation  may fail due to lack of device-specific resources
(in addition to the other errors).
If that occurs, <c>vkCreateDevice</c> will return
<c>VK_ERROR_TOO_MANY_OBJECTS</c>.



Valid Usage
<list type="bullet"><item><description>

All <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#extended-functionality-extensions-dependencies">required
extensions</a> for each extension in the
<see cref="T:IVkDeviceCreateInfo" />::<c>ppEnabledExtensionNames</c> list  must also
be present in that list.
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>physicalDevice</c> must be a valid <c>VkPhysicalDevice</c> handle
</description></item><item><description>
<c>pCreateInfo</c> must be a pointer to a valid <c>VkDeviceCreateInfo</c> structure
</description></item><item><description>
 If <c>pAllocator</c> is not <c>NULL</c>, <c>pAllocator</c> must be a pointer to a valid <c>VkAllocationCallbacks</c> structure
</description></item><item><description>
<c>pDevice</c> must be a pointer to a <c>VkDevice</c> handle
</description></item></list>




Return Codes
<dl><dt>On success, this command returns</dt><dd>
<list type="bullet"><item><description>
<c>VK_SUCCESS</c>
</description></item></list>
</dd><dt>On failure, this command returns</dt><dd>
<list type="bullet"><item><description>
<c>VK_ERROR_OUT_OF_HOST_MEMORY</c>
</description></item><item><description>
<c>VK_ERROR_OUT_OF_DEVICE_MEMORY</c>
</description></item><item><description>
<c>VK_ERROR_INITIALIZATION_FAILED</c>
</description></item><item><description>
<c>VK_ERROR_EXTENSION_NOT_PRESENT</c>
</description></item><item><description>
<c>VK_ERROR_FEATURE_NOT_PRESENT</c>
</description></item><item><description>
<c>VK_ERROR_TOO_MANY_OBJECTS</c>
</description></item><item><description>
<c>VK_ERROR_DEVICE_LOST</c>
</description></item></list>
</dd></dl>




A logical device is created as a  connection to a physical device.
To create a logical device, call:


<code> VkResult vkCreateDevice(
    VkPhysicalDevice                            physicalDevice,
    const VkDeviceCreateInfo*                   pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkDevice*                                   pDevice); </code>

</remarks>
      <seealso cref="T:IVkAllocationCallbacks" />
      <seealso cref="T:VkDevice" />
      <seealso cref="T:IVkDeviceCreateInfo" />
      <seealso cref="T:VkPhysicalDevice" />
    </member>
    <member name="T:vkSetHdrMetadataEXT" />
    <member name="T:IVkExternalSemaphorePropertiesKHX" />
    <member name="T:VkExternalSemaphorePropertiesKHX32">
      <summary>See: <see cref="T:IVkExternalSemaphorePropertiesKHX" /></summary>
      <seealso cref="T:IVkExternalSemaphorePropertiesKHX" />
    </member>
    <member name="T:VkExternalSemaphorePropertiesKHX64">
      <summary>See: <see cref="T:IVkExternalSemaphorePropertiesKHX" /></summary>
      <seealso cref="T:IVkExternalSemaphorePropertiesKHX" />
    </member>
    <member name="T:vkGetPhysicalDeviceExternalBufferPropertiesKHX" />
    <member name="T:IVkExportMemoryAllocateInfoKHX" />
    <member name="T:VkExportMemoryAllocateInfoKHX32">
      <summary>See: <see cref="T:IVkExportMemoryAllocateInfoKHX" /></summary>
      <seealso cref="T:IVkExportMemoryAllocateInfoKHX" />
    </member>
    <member name="T:VkExportMemoryAllocateInfoKHX64">
      <summary>See: <see cref="T:IVkExportMemoryAllocateInfoKHX" /></summary>
      <seealso cref="T:IVkExportMemoryAllocateInfoKHX" />
    </member>
    <member name="T:vkCreateSemaphore">
      <summary>Create a new queue semaphore object</summary>
      <remarks>

When created, the semaphore is in the unsignaled state.



Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>device</c> must be a valid <c>VkDevice</c> handle
</description></item><item><description>
<c>pCreateInfo</c> must be a pointer to a valid <c>VkSemaphoreCreateInfo</c> structure
</description></item><item><description>
 If <c>pAllocator</c> is not <c>NULL</c>, <c>pAllocator</c> must be a pointer to a valid <c>VkAllocationCallbacks</c> structure
</description></item><item><description>
<c>pSemaphore</c> must be a pointer to a <c>VkSemaphore</c> handle
</description></item></list>




Return Codes
<dl><dt>On success, this command returns</dt><dd>
<list type="bullet"><item><description>
<c>VK_SUCCESS</c>
</description></item></list>
</dd><dt>On failure, this command returns</dt><dd>
<list type="bullet"><item><description>
<c>VK_ERROR_OUT_OF_HOST_MEMORY</c>
</description></item><item><description>
<c>VK_ERROR_OUT_OF_DEVICE_MEMORY</c>
</description></item></list>
</dd></dl>




To create a semaphore, call:


<code> VkResult vkCreateSemaphore(
    VkDevice                                    device,
    const VkSemaphoreCreateInfo*                pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkSemaphore*                                pSemaphore); </code>

</remarks>
      <seealso cref="T:IVkAllocationCallbacks" />
      <seealso cref="T:VkDevice" />
      <seealso cref="T:VkSemaphore" />
      <seealso cref="T:IVkSemaphoreCreateInfo" />
    </member>
    <member name="T:IVkValidationFlagsEXT" />
    <member name="T:VkValidationFlagsEXT32">
      <summary>See: <see cref="T:IVkValidationFlagsEXT" /></summary>
      <seealso cref="T:IVkValidationFlagsEXT" />
    </member>
    <member name="T:VkValidationFlagsEXT64">
      <summary>See: <see cref="T:IVkValidationFlagsEXT" /></summary>
      <seealso cref="T:IVkValidationFlagsEXT" />
    </member>
    <member name="T:IVkPhysicalDeviceImageFormatInfo2KHR" />
    <member name="T:VkPhysicalDeviceImageFormatInfo2KHR32">
      <summary>See: <see cref="T:IVkPhysicalDeviceImageFormatInfo2KHR" /></summary>
      <seealso cref="T:IVkPhysicalDeviceImageFormatInfo2KHR" />
    </member>
    <member name="T:VkPhysicalDeviceImageFormatInfo2KHR64">
      <summary>See: <see cref="T:IVkPhysicalDeviceImageFormatInfo2KHR" /></summary>
      <seealso cref="T:IVkPhysicalDeviceImageFormatInfo2KHR" />
    </member>
    <member name="T:IVkPhysicalDeviceMemoryProperties2KHR" />
    <member name="T:VkPhysicalDeviceMemoryProperties2KHR32">
      <summary>See: <see cref="T:IVkPhysicalDeviceMemoryProperties2KHR" /></summary>
      <seealso cref="T:IVkPhysicalDeviceMemoryProperties2KHR" />
    </member>
    <member name="T:VkPhysicalDeviceMemoryProperties2KHR64">
      <summary>See: <see cref="T:IVkPhysicalDeviceMemoryProperties2KHR" /></summary>
      <seealso cref="T:IVkPhysicalDeviceMemoryProperties2KHR" />
    </member>
    <member name="T:vkAllocateCommandBuffers">
      <summary>Allocate command buffers from an existing command pool</summary>
      <remarks>

When command buffers are first allocated, they are in the
<a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#commandbuffers-lifecycle">initial state</a>.



Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>device</c> must be a valid <c>VkDevice</c> handle
</description></item><item><description>
<c>pAllocateInfo</c> must be a pointer to a valid <c>VkCommandBufferAllocateInfo</c> structure
</description></item><item><description>
<c>pCommandBuffers</c> must be a pointer to an array of <c>pAllocateInfo</c>::commandBufferCount <c>VkCommandBuffer</c> handles
</description></item></list>




Host Synchronization
<list type="bullet"><item><description>
Host access to <c>pAllocateInfo</c>::commandPool  must be externally synchronized
</description></item></list>




Return Codes
<dl><dt>On success, this command returns</dt><dd>
<list type="bullet"><item><description>
<c>VK_SUCCESS</c>
</description></item></list>
</dd><dt>On failure, this command returns</dt><dd>
<list type="bullet"><item><description>
<c>VK_ERROR_OUT_OF_HOST_MEMORY</c>
</description></item><item><description>
<c>VK_ERROR_OUT_OF_DEVICE_MEMORY</c>
</description></item></list>
</dd></dl>




To allocate command buffers, call:


<code> VkResult vkAllocateCommandBuffers(
    VkDevice                                    device,
    const VkCommandBufferAllocateInfo*          pAllocateInfo,
    VkCommandBuffer*                            pCommandBuffers); </code>

</remarks>
      <seealso cref="T:VkCommandBuffer" />
      <seealso cref="T:IVkCommandBufferAllocateInfo" />
      <seealso cref="T:VkDevice" />
    </member>
    <member name="T:vkCmdSetBlendConstants">
      <summary>Set the values of blend constants</summary>
      <remarks>


Valid Usage
<list type="bullet"><item><description>

The currently bound graphics pipeline  must have been created with the
<c>VK_DYNAMIC_STATE_BLEND_CONSTANTS</c> dynamic state enabled
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>commandBuffer</c> must be a valid <c>VkCommandBuffer</c> handle
</description></item><item><description>
<c>commandBuffer</c> must be in the  recording state
</description></item><item><description>
 The <c>VkCommandPool</c> that <c>commandBuffer</c> was allocated from  must support graphics operations
</description></item></list>




Host Synchronization
<list type="bullet"><item><description>
Host access to <c>commandBuffer</c> must  be externally synchronized
</description></item><item><description>
Host access to the <c>VkCommandPool</c> that <c>commandBuffer</c> was allocated from  must be externally synchronized
</description></item></list>




Command Properties
<list type="table">       <listheader><tr><term> Command Buffer Levels </term><term> Render Pass Scope </term><term> Supported Queue Types </term><term> Pipeline Type </term></tr></listheader>
<item><term>
Primary<br />
Secondary
</term><term>
Both
</term><term>
Graphics
</term><term></term></item>
</list>



Otherwise, to dynamically set and change the blend constant, call:


<code> void vkCmdSetBlendConstants(
    VkCommandBuffer                             commandBuffer,
    const float                                 blendConstants[4]); </code>

</remarks>
      <seealso cref="T:VkCommandBuffer" />
    </member>
    <member name="T:vkUpdateDescriptorSets">
      <summary>Update the contents of a descriptor set object</summary>
      <remarks>

The operations described by <c>pDescriptorWrites</c> are performed first,
followed by the operations described by <c>pDescriptorCopies</c>.
Within each array, the operations are performed in the order they appear in
the array.


Each element in the <c>pDescriptorWrites</c> array describes an operation
updating the descriptor set using descriptors for resources specified in the
structure.


Each element in the <c>pDescriptorCopies</c> array is a
<see cref="T:IVkCopyDescriptorSet" /> structure describing an operation copying
descriptors between sets.


If the <c>dstSet</c> member of any given element of <c>pDescriptorWrites</c>
or <c>pDescriptorCopies</c> is bound, accessed, or modified by any command
that was recorded to a command buffer which is currently in the
<a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#commandbuffers-lifecycle">recording or executable state</a>, that command
buffer becomes <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#commandbuffers-lifecycle">invalid</a>.



Valid Usage
<list type="bullet"><item><description>

The <c>dstSet</c> member of any given element of <c>pDescriptorWrites</c>
or <c>pDescriptorCopies</c> must not be used by any command that was
recorded to a command buffer which is in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#commandbuffers-lifecycle">pending state</a>.
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>device</c> must be a valid <c>VkDevice</c> handle
</description></item><item><description>
 If <c>descriptorWriteCount</c> is not <c>0</c>, <c>pDescriptorWrites</c> must be a pointer to an array of <c>descriptorWriteCount</c> valid <c>VkWriteDescriptorSet</c> structures
</description></item><item><description>
 If <c>descriptorCopyCount</c> is not <c>0</c>, <c>pDescriptorCopies</c> must be a pointer to an array of <c>descriptorCopyCount</c> valid <c>VkCopyDescriptorSet</c> structures
</description></item></list>




Host Synchronization
<list type="bullet"><item><description>
Host access to <c>pDescriptorWrites</c>[].dstSet  must be externally synchronized
</description></item><item><description>
Host access to <c>pDescriptorCopies</c>[].dstSet  must be externally synchronized
</description></item></list>




Once allocated, descriptor sets  can be updated with a combination of write
and copy operations.
To update descriptor sets, call:


<code> void vkUpdateDescriptorSets(
    VkDevice                                    device,
    uint32_t                                    descriptorWriteCount,
    const VkWriteDescriptorSet*                 pDescriptorWrites,
    uint32_t                                    descriptorCopyCount,
    const VkCopyDescriptorSet*                  pDescriptorCopies); </code>

</remarks>
      <seealso cref="T:IVkCopyDescriptorSet" />
      <seealso cref="T:VkDevice" />
      <seealso cref="T:IVkWriteDescriptorSet" />
    </member>
    <member name="T:VkSubresourceLayout">
      <summary>Structure specifying subresource layout</summary>
      <remarks>

For images created with linear tiling, <c>rowPitch</c>, <c>arrayPitch</c> and
<c>depthPitch</c> describe the layout of the image subresource in linear
memory.
For uncompressed formats, <c>rowPitch</c> is the number of bytes between
texels with the same x coordinate in adjacent rows (y coordinates differ by
one).
<c>arrayPitch</c> is the number of bytes between texels with the same x and y
coordinate in adjacent array layers of the image (array layer values differ
by one).
<c>depthPitch</c> is the number of bytes between texels with the same x and y
coordinate in adjacent slices of a 3D image (z coordinates differ by one).
Expressed as an addressing formula, the starting byte of a texel in the
image subresource has address:


<code> // (x,y,z,layer) are in texel coordinates
address(x,y,z,layer) = layer*arrayPitch + z*depthPitch + y*rowPitch + x*elementSize + offset </code>


For compressed formats, the <c>rowPitch</c> is the number of bytes between
compressed texel blocks in adjacent rows.
<c>arrayPitch</c> is the number of bytes between compressed texel blocks in
adjacent array layers.
<c>depthPitch</c> is the number of bytes between compressed texel blocks in
adjacent slices of a 3D image.


<code> // (x,y,z,layer) are in compressed texel block coordinates
address(x,y,z,layer) = layer*arrayPitch + z*depthPitch + y*rowPitch + x*compressedTexelBlockByteSize + offset; </code>


<c>arrayPitch</c> is undefined for images that were not created as arrays.
<c>depthPitch</c> is defined only for 3D images.


For color formats, the <c>aspectMask</c> member of <c>VkImageSubresource</c> must be <c>VK_IMAGE_ASPECT_COLOR_BIT</c>.
For depth/stencil formats, <c>aspectMask</c> must be either
<c>VK_IMAGE_ASPECT_DEPTH_BIT</c> or <c>VK_IMAGE_ASPECT_STENCIL_BIT</c>.
On implementations that store depth and stencil aspects separately, querying
each of these image subresource layouts will return a different <c>offset</c>
and <c>size</c> representing the region of memory used for that aspect.
On implementations that store depth and stencil aspects interleaved, the
same <c>offset</c> and <c>size</c> are returned and represent the interleaved
memory allocation.



Information about the layout of the image subresource is returned in a
<c>VkSubresourceLayout</c> structure:


<code> typedef struct VkSubresourceLayout {
    VkDeviceSize    offset;
    VkDeviceSize    size;
    VkDeviceSize    rowPitch;
    VkDeviceSize    arrayPitch;
    VkDeviceSize    depthPitch;
} VkSubresourceLayout; </code>

</remarks>
      <seealso cref="T:vkGetImageSubresourceLayout" />
    </member>
    <member name="T:vkCmdSetLineWidth">
      <summary>Set the dynamic line width state</summary>
      <remarks>


Valid Usage
<list type="bullet"><item><description>

The currently bound graphics pipeline  must have been created with the
<c>VK_DYNAMIC_STATE_LINE_WIDTH</c> dynamic state enabled
</description></item><item><description>

If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-wideLines">wide lines</a> feature is not
enabled, <c>lineWidth</c> must be <c>1.0</c>
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>commandBuffer</c> must be a valid <c>VkCommandBuffer</c> handle
</description></item><item><description>
<c>commandBuffer</c> must be in the  recording state
</description></item><item><description>
 The <c>VkCommandPool</c> that <c>commandBuffer</c> was allocated from  must support graphics operations
</description></item></list>




Host Synchronization
<list type="bullet"><item><description>
Host access to <c>commandBuffer</c> must  be externally synchronized
</description></item><item><description>
Host access to the <c>VkCommandPool</c> that <c>commandBuffer</c> was allocated from  must be externally synchronized
</description></item></list>




Command Properties
<list type="table">       <listheader><tr><term> Command Buffer Levels </term><term> Render Pass Scope </term><term> Supported Queue Types </term><term> Pipeline Type </term></tr></listheader>
<item><term>
Primary<br />
Secondary
</term><term>
Both
</term><term>
Graphics
</term><term></term></item>
</list>



The line width is specified by the
<see cref="T:IVkPipelineRasterizationStateCreateInfo" />::<c>lineWidth</c> property of
the currently active pipeline, if the pipeline was not created with
<c>VK_DYNAMIC_STATE_LINE_WIDTH</c> enabled.


Otherwise, the line width is set by calling <c>vkCmdSetLineWidth</c>:


<code> void vkCmdSetLineWidth(
    VkCommandBuffer                             commandBuffer,
    float                                       lineWidth); </code>

</remarks>
      <seealso cref="T:VkCommandBuffer" />
    </member>
    <member name="T:vkCreateImage">
      <summary>Create a new image object</summary>
      <remarks>


Valid Usage
<list type="bullet"><item><description>

If the <c>flags</c> member of <c>pCreateInfo</c> includes
<c>VK_IMAGE_CREATE_SPARSE_BINDING_BIT</c>, creating this <c>VkImage</c> must not cause the total required sparse memory for all currently valid
sparse resources on the device to exceed
<c>VkPhysicalDeviceLimits</c>::<c>sparseAddressSpaceSize</c>
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>device</c> must be a valid <c>VkDevice</c> handle
</description></item><item><description>
<c>pCreateInfo</c> must be a pointer to a valid <c>VkImageCreateInfo</c> structure
</description></item><item><description>
 If <c>pAllocator</c> is not <c>NULL</c>, <c>pAllocator</c> must be a pointer to a valid <c>VkAllocationCallbacks</c> structure
</description></item><item><description>
<c>pImage</c> must be a pointer to a <c>VkImage</c> handle
</description></item></list>




Return Codes
<dl><dt>On success, this command returns</dt><dd>
<list type="bullet"><item><description>
<c>VK_SUCCESS</c>
</description></item></list>
</dd><dt>On failure, this command returns</dt><dd>
<list type="bullet"><item><description>
<c>VK_ERROR_OUT_OF_HOST_MEMORY</c>
</description></item><item><description>
<c>VK_ERROR_OUT_OF_DEVICE_MEMORY</c>
</description></item></list>
</dd></dl>




To create images, call:


<code> VkResult vkCreateImage(
    VkDevice                                    device,
    const VkImageCreateInfo*                    pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkImage*                                    pImage); </code>

</remarks>
      <seealso cref="T:IVkAllocationCallbacks" />
      <seealso cref="T:VkDevice" />
      <seealso cref="T:VkImage" />
      <seealso cref="T:IVkImageCreateInfo" />
    </member>
    <member name="T:PFN_vkAllocationFunction">
      <summary>Application-defined memory allocation function</summary>
      <remarks>

If <c>pfnAllocation</c> is unable to allocate the requested memory, it  must
return <c>NULL</c>.
If the allocation was successful, it  must return a valid pointer to memory
allocation containing at least <c>size</c> bytes, and with the pointer value
being a multiple of <c>alignment</c>.

<list type="table"><tr><td><i title="Note"></i></td><td>
Note

Correct Vulkan operation  cannot be assumed if the application does not
follow these rules.


For example, <c>pfnAllocation</c> (or <c>pfnReallocation</c>) could cause
termination of running Vulkan instance(s) on a failed allocation for
debugging purposes, either directly or indirectly.
In these circumstances, it  cannot be assumed that any part of any affected
VkInstance objects are going to operate correctly (even
<see cref="T:vkDestroyInstance" />), and the application  must ensure it cleans up
properly via other means (e.g. process termination).

</td></tr></list>

If <c>pfnAllocation</c> returns <c>NULL</c>, and if the implementation is unable
to continue correct processing of the current command without the requested
allocation, it  must treat this as a run-time error, and generate
<c>VK_ERROR_OUT_OF_HOST_MEMORY</c> at the appropriate time for the command in
which the condition was detected, as described in <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#fundamentals-errorcodes">Return Codes</a>.


If the implementation is able to continue correct processing of the current
command without the requested allocation, then it  may do so, and  must not
generate <c>VK_ERROR_OUT_OF_HOST_MEMORY</c> as a result of this failed
allocation.



The type of <c>pfnAllocation</c> is:


<code> typedef void* (VKAPI_PTR *PFN_vkAllocationFunction)(
    void*                                       pUserData,
    size_t                                      size,
    size_t                                      alignment,
    VkSystemAllocationScope                     allocationScope); </code>

</remarks>
      <seealso cref="T:IVkAllocationCallbacks" />
    </member>
    <member name="T:vkCmdBindIndexBuffer">
      <summary>Bind an index buffer to a command buffer</summary>
      <remarks>


Valid Usage
<list type="bullet"><item><description>
<c>offset</c> must be less than the size of <c>buffer</c>
</description></item><item><description>

The sum of <c>offset</c> and the address of the range of
<c>VkDeviceMemory</c> object that is backing <c>buffer</c>,  must be a
multiple of the type indicated by <c>indexType</c>
</description></item><item><description>
<c>buffer</c> must have been created with the
<c>VK_BUFFER_USAGE_INDEX_BUFFER_BIT</c> flag
</description></item><item><description>

If <c>buffer</c> is non-sparse then it  must be bound completely and
contiguously to a single <c>VkDeviceMemory</c> object
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>commandBuffer</c> must be a valid <c>VkCommandBuffer</c> handle
</description></item><item><description>
<c>buffer</c> must be a valid <c>VkBuffer</c> handle
</description></item><item><description>
<c>indexType</c> must be a valid <see cref="T:VkIndexType" /> value
</description></item><item><description>
<c>commandBuffer</c> must be in the  recording state
</description></item><item><description>
 The <c>VkCommandPool</c> that <c>commandBuffer</c> was allocated from  must support graphics operations
</description></item><item><description>
 Both of <c>buffer</c>, and <c>commandBuffer</c> must have been created, allocated, or retrieved from the same <c>VkDevice</c>
</description></item></list>




Host Synchronization
<list type="bullet"><item><description>
Host access to <c>commandBuffer</c> must  be externally synchronized
</description></item><item><description>
Host access to the <c>VkCommandPool</c> that <c>commandBuffer</c> was allocated from  must be externally synchronized
</description></item></list>




Command Properties
<list type="table">       <listheader><tr><term> Command Buffer Levels </term><term> Render Pass Scope </term><term> Supported Queue Types </term><term> Pipeline Type </term></tr></listheader>
<item><term>
Primary<br />
Secondary
</term><term>
Both
</term><term>
Graphics
</term><term></term></item>
</list>



To bind an index buffer to a command buffer, call:


<code> void vkCmdBindIndexBuffer(
    VkCommandBuffer                             commandBuffer,
    VkBuffer                                    buffer,
    VkDeviceSize                                offset,
    VkIndexType                                 indexType); </code>

</remarks>
      <seealso cref="T:VkBuffer" />
      <seealso cref="T:VkCommandBuffer" />
      <seealso cref="T:VkIndexType" />
    </member>
    <member name="T:VkMemoryHeap">
      <summary>Structure specifying a memory heap</summary>
      <remarks>

The <c>VkMemoryHeap</c> structure is defined as:


<code> typedef struct VkMemoryHeap {
    VkDeviceSize         size;
    VkMemoryHeapFlags    flags;
} VkMemoryHeap; </code>

</remarks>
      <seealso cref="T:VkMemoryHeapFlags" />
      <seealso cref="T:VkPhysicalDeviceMemoryProperties" />
    </member>
    <member name="T:vkCmdCopyBuffer">
      <summary>Copy data between buffer regions</summary>
      <remarks>

Each region in <c>pRegions</c> is copied from the source buffer to the same
region of the destination buffer.
<c>srcBuffer</c> and <c>dstBuffer</c> can  be the same buffer or alias the
same memory, but the result is undefined if the copy regions overlap in
memory.



Valid Usage
<list type="bullet"><item><description>

The <c>size</c> member of a given element of <c>pRegions</c> must be
greater than <c>0</c>
</description></item><item><description>

The <c>srcOffset</c> member of a given element of <c>pRegions</c> must be
less than the size of <c>srcBuffer</c>
</description></item><item><description>

The <c>dstOffset</c> member of a given element of <c>pRegions</c> must be
less than the size of <c>dstBuffer</c>
</description></item><item><description>

The <c>size</c> member of a given element of <c>pRegions</c> must be less
than or equal to the size of <c>srcBuffer</c> minus <c>srcOffset</c>
</description></item><item><description>

The <c>size</c> member of a given element of <c>pRegions</c> must be less
than or equal to the size of <c>dstBuffer</c> minus <c>dstOffset</c>
</description></item><item><description>

The union of the source regions, and the union of the destination
regions, specified by the elements of <c>pRegions</c>,  must not overlap
in memory
</description></item><item><description>
<c>srcBuffer</c> must have been created with
<c>VK_BUFFER_USAGE_TRANSFER_SRC_BIT</c> usage flag
</description></item><item><description>

If <c>srcBuffer</c> is non-sparse then it  must be bound completely and
contiguously to a single <c>VkDeviceMemory</c> object
</description></item><item><description>
<c>dstBuffer</c> must have been created with
<c>VK_BUFFER_USAGE_TRANSFER_DST_BIT</c> usage flag
</description></item><item><description>

If <c>dstBuffer</c> is non-sparse then it  must be bound completely and
contiguously to a single <c>VkDeviceMemory</c> object
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>commandBuffer</c> must be a valid <c>VkCommandBuffer</c> handle
</description></item><item><description>
<c>srcBuffer</c> must be a valid <c>VkBuffer</c> handle
</description></item><item><description>
<c>dstBuffer</c> must be a valid <c>VkBuffer</c> handle
</description></item><item><description>
<c>pRegions</c> must be a pointer to an array of <c>regionCount</c><c>VkBufferCopy</c> structures
</description></item><item><description>
<c>commandBuffer</c> must be in the  recording state
</description></item><item><description>
 The <c>VkCommandPool</c> that <c>commandBuffer</c> was allocated from  must support transfer, graphics, or compute operations
</description></item><item><description>
 This command  must only be called outside of a render pass instance
</description></item><item><description>
<c>regionCount</c> must be greater than <c>0</c>
</description></item><item><description>
 Each of <c>commandBuffer</c>, <c>dstBuffer</c>, and <c>srcBuffer</c> must have been created, allocated, or retrieved from the same <c>VkDevice</c>
</description></item></list>




Host Synchronization
<list type="bullet"><item><description>
Host access to <c>commandBuffer</c> must  be externally synchronized
</description></item><item><description>
Host access to the <c>VkCommandPool</c> that <c>commandBuffer</c> was allocated from  must be externally synchronized
</description></item></list>




Command Properties
<list type="table">       <listheader><tr><term> Command Buffer Levels </term><term> Render Pass Scope </term><term> Supported Queue Types </term><term> Pipeline Type </term></tr></listheader>
<item><term>
Primary<br />
Secondary
</term><term>
Outside
</term><term>
Transfer<br />
graphics<br />
compute
</term><term>
Transfer
</term></item>
</list>



To copy data between buffer objects, call:


<code> void vkCmdCopyBuffer(
    VkCommandBuffer                             commandBuffer,
    VkBuffer                                    srcBuffer,
    VkBuffer                                    dstBuffer,
    uint32_t                                    regionCount,
    const VkBufferCopy*                         pRegions); </code>

</remarks>
      <seealso cref="T:VkBuffer" />
      <seealso cref="T:VkBufferCopy" />
      <seealso cref="T:VkCommandBuffer" />
    </member>
    <member name="T:vkGetPhysicalDeviceSurfaceFormatsKHR" />
    <member name="T:vkEnumeratePhysicalDevices">
      <summary>Enumerates the physical devices accessible to a Vulkan instance</summary>
      <remarks>

If <c>pPhysicalDevices</c> is <c>NULL</c>, then the number of physical devices
available is returned in <c>pPhysicalDeviceCount</c>.
Otherwise, <c>pPhysicalDeviceCount</c> must point to a variable set by the
user to the number of elements in the <c>pPhysicalDevices</c> array, and on
return the variable is overwritten with the number of handles actually
written to <c>pPhysicalDevices</c>.
If <c>pPhysicalDeviceCount</c> is less than the number of physical devices
available, at most <c>pPhysicalDeviceCount</c> structures will be written.
If <c>pPhysicalDeviceCount</c> is smaller than the number of physical devices
available, <c>VK_INCOMPLETE</c> will be returned instead of <c>VK_SUCCESS</c>,
to indicate that not all the available physical devices were returned.



Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>instance</c> must be a valid <c>VkInstance</c> handle
</description></item><item><description>
<c>pPhysicalDeviceCount</c> must be a pointer to a <c>uint32_t</c> value
</description></item><item><description>
 If the value referenced by <c>pPhysicalDeviceCount</c> is not <c>0</c>, and <c>pPhysicalDevices</c> is not <c>NULL</c>, <c>pPhysicalDevices</c> must be a pointer to an array of <c>pPhysicalDeviceCount</c><c>VkPhysicalDevice</c> handles
</description></item></list>




Return Codes
<dl><dt>On success, this command returns</dt><dd>
<list type="bullet"><item><description>
<c>VK_SUCCESS</c>
</description></item><item><description>
<c>VK_INCOMPLETE</c>
</description></item></list>
</dd><dt>On failure, this command returns</dt><dd>
<list type="bullet"><item><description>
<c>VK_ERROR_OUT_OF_HOST_MEMORY</c>
</description></item><item><description>
<c>VK_ERROR_OUT_OF_DEVICE_MEMORY</c>
</description></item><item><description>
<c>VK_ERROR_INITIALIZATION_FAILED</c>
</description></item></list>
</dd></dl>




To retrieve a list of physical device objects representing the physical
devices installed in the system, call:


<code> VkResult vkEnumeratePhysicalDevices(
    VkInstance                                  instance,
    uint32_t*                                   pPhysicalDeviceCount,
    VkPhysicalDevice*                           pPhysicalDevices); </code>

</remarks>
      <seealso cref="T:VkInstance" />
      <seealso cref="T:VkPhysicalDevice" />
    </member>
    <member name="T:IVkExternalBufferPropertiesKHX" />
    <member name="T:VkExternalBufferPropertiesKHX32">
      <summary>See: <see cref="T:IVkExternalBufferPropertiesKHX" /></summary>
      <seealso cref="T:IVkExternalBufferPropertiesKHX" />
    </member>
    <member name="T:VkExternalBufferPropertiesKHX64">
      <summary>See: <see cref="T:IVkExternalBufferPropertiesKHX" /></summary>
      <seealso cref="T:IVkExternalBufferPropertiesKHX" />
    </member>
    <member name="T:VkStencilOpState">
      <summary>Structure specifying stencil operation state</summary>
      <remarks>


Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>failOp</c> must be a valid <see cref="T:VkStencilOp" /> value
</description></item><item><description>
<c>passOp</c> must be a valid <see cref="T:VkStencilOp" /> value
</description></item><item><description>
<c>depthFailOp</c> must be a valid <see cref="T:VkStencilOp" /> value
</description></item><item><description>
<c>compareOp</c> must be a valid <see cref="T:VkCompareOp" /> value
</description></item></list>




The <c>VkStencilOpState</c> structure is defined as:


<code> typedef struct VkStencilOpState {
    VkStencilOp    failOp;
    VkStencilOp    passOp;
    VkStencilOp    depthFailOp;
    VkCompareOp    compareOp;
    uint32_t       compareMask;
    uint32_t       writeMask;
    uint32_t       reference;
} VkStencilOpState; </code>

</remarks>
      <seealso cref="T:VkCompareOp" />
      <seealso cref="T:IVkPipelineDepthStencilStateCreateInfo" />
      <seealso cref="T:VkStencilOp" />
    </member>
    <member name="T:VkMemoryRequirements">
      <summary>Structure specifying memory requirements</summary>
      <remarks>

The <c>VkMemoryRequirements</c> structure is defined as:


<code> typedef struct VkMemoryRequirements {
    VkDeviceSize    size;
    VkDeviceSize    alignment;
    uint32_t        memoryTypeBits;
} VkMemoryRequirements; </code>

</remarks>
      <seealso cref="T:vkGetBufferMemoryRequirements" />
      <seealso cref="T:vkGetImageMemoryRequirements" />
    </member>
    <member name="T:vkGetPhysicalDeviceMemoryProperties2KHR" />
    <member name="T:vkGetPhysicalDeviceSparseImageFormatProperties">
      <summary>Retrieve properties of an image format applied to sparse images</summary>
      <remarks>

If <c>pProperties</c> is <c>NULL</c>, then the number of sparse format properties
available is returned in <c>pPropertyCount</c>.
Otherwise, <c>pPropertyCount</c> must point to a variable set by the user to
the number of elements in the <c>pProperties</c> array, and on return the
variable is overwritten with the number of structures actually written to
<c>pProperties</c>.
If <c>pPropertyCount</c> is less than the number of sparse format properties
available, at most <c>pPropertyCount</c> structures will be written.


If <c>VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT</c> is not supported for the given
arguments, <c>pPropertyCount</c> will be set to zero upon return, and no data
will be written to <c>pProperties</c>.


Multiple aspects are returned for depth/stencil images that are implemented
as separate planes by the implementation.
The depth and stencil data planes each have unique
<c>VkSparseImageFormatProperties</c> data.


Depth/stencil images with depth and stencil data interleaved into a single
plane will return a single <c>VkSparseImageFormatProperties</c> structure
with the <c>aspectMask</c> set to <c>VK_IMAGE_ASPECT_DEPTH_BIT</c> |
<c>VK_IMAGE_ASPECT_STENCIL_BIT</c>.



Valid Usage
<list type="bullet"><item><description>
<c>samples</c> must be a bit value that is set in
<c>VkImageFormatProperties</c>::<c>sampleCounts</c> returned by
<c>vkGetPhysicalDeviceImageFormatProperties</c> with <c>format</c>,
<c>type</c>, <c>tiling</c>, and <c>usage</c> equal to those in this command
and <c>flags</c> equal to the value that is set in
<c>VkImageCreateInfo</c>::<c>flags</c> when the image is created
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>physicalDevice</c> must be a valid <c>VkPhysicalDevice</c> handle
</description></item><item><description>
<c>format</c> must be a valid <see cref="T:VkFormat" /> value
</description></item><item><description>
<c>type</c> must be a valid <see cref="T:VkImageType" /> value
</description></item><item><description>
<c>samples</c> must be a valid <see cref="T:VkSampleCountFlags" /> value
</description></item><item><description>
<c>usage</c> must be a valid combination of <see cref="T:VkImageUsageFlags" /> values
</description></item><item><description>
<c>usage</c> must not be <c>0</c>
</description></item><item><description>
<c>tiling</c> must be a valid <see cref="T:VkImageTiling" /> value
</description></item><item><description>
<c>pPropertyCount</c> must be a pointer to a <c>uint32_t</c> value
</description></item><item><description>
 If the value referenced by <c>pPropertyCount</c> is not <c>0</c>, and <c>pProperties</c> is not <c>NULL</c>, <c>pProperties</c> must be a pointer to an array of <c>pPropertyCount</c><c>VkSparseImageFormatProperties</c> structures
</description></item></list>




<c>vkGetPhysicalDeviceSparseImageFormatProperties</c> returns an array of
<see cref="T:VkSparseImageFormatProperties" />.
Each element will describe properties for one set of image aspects that are
bound simultaneously in the image.
This is usually one element for each aspect in the image, but for
interleaved depth/stencil images there is only one element describing the
combined aspects.


<code> void vkGetPhysicalDeviceSparseImageFormatProperties(
    VkPhysicalDevice                            physicalDevice,
    VkFormat                                    format,
    VkImageType                                 type,
    VkSampleCountFlagBits                       samples,
    VkImageUsageFlags                           usage,
    VkImageTiling                               tiling,
    uint32_t*                                   pPropertyCount,
    VkSparseImageFormatProperties*              pProperties); </code>

</remarks>
      <seealso cref="T:VkFormat" />
      <seealso cref="T:VkImageTiling" />
      <seealso cref="T:VkImageType" />
      <seealso cref="T:VkImageUsageFlags" />
      <seealso cref="T:VkPhysicalDevice" />
      <seealso cref="T:VkSampleCountFlags" />
      <seealso cref="T:VkSparseImageFormatProperties" />
    </member>
    <member name="T:vkGetPhysicalDeviceExternalImageFormatPropertiesNV" />
    <member name="T:IVkDebugReportCallbackCreateInfoEXT" />
    <member name="T:VkDebugReportCallbackCreateInfoEXT32">
      <summary>See: <see cref="T:IVkDebugReportCallbackCreateInfoEXT" /></summary>
      <seealso cref="T:IVkDebugReportCallbackCreateInfoEXT" />
    </member>
    <member name="T:VkDebugReportCallbackCreateInfoEXT64">
      <summary>See: <see cref="T:IVkDebugReportCallbackCreateInfoEXT" /></summary>
      <seealso cref="T:IVkDebugReportCallbackCreateInfoEXT" />
    </member>
    <member name="T:VkDescriptorBufferInfo">
      <summary>Structure specifying descriptor buffer info</summary>
      <remarks>
<list type="table"><tr><td><i title="Note"></i></td><td>
Note

When setting <c>range</c> to <c>VK_WHOLE_SIZE</c>, the effective range  must
not be larger than the maximum range for the descriptor type
(<a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-limits-maxUniformBufferRange">maxUniformBufferRange</a> or
<a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-limits-maxStorageBufferRange">maxStorageBufferRange</a>).
This means that <c>VK_WHOLE_SIZE</c> is not typically useful in the common
case where uniform buffer descriptors are suballocated from a buffer that is
much larger than <c>maxUniformBufferRange</c>.

</td></tr></list>

For <c>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC</c> and
<c>VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC</c> descriptor types,
<c>offset</c> is the base offset from which the dynamic offset is applied and
<c>range</c> is the static size used for all dynamic offsets.



Valid Usage
<list type="bullet"><item><description>
<c>offset</c> must be less than the size of <c>buffer</c>
</description></item><item><description>

If <c>range</c> is not equal to <c>VK_WHOLE_SIZE</c>, <c>range</c> must be
greater than <c>0</c>
</description></item><item><description>

If <c>range</c> is not equal to <c>VK_WHOLE_SIZE</c>, <c>range</c> must be
less than or equal to the size of <c>buffer</c> minus <c>offset</c>
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>buffer</c> must be a valid <c>VkBuffer</c> handle
</description></item></list>




The <c>VkDescriptorBufferInfo</c> structure is defined as:


<code> typedef struct VkDescriptorBufferInfo {
    VkBuffer        buffer;
    VkDeviceSize    offset;
    VkDeviceSize    range;
} VkDescriptorBufferInfo; </code>

</remarks>
      <seealso cref="T:VkBuffer" />
      <seealso cref="T:IVkWriteDescriptorSet" />
    </member>
    <member name="T:vkCmdSetViewport">
      <summary>Set the viewport on a command buffer</summary>
      <remarks>

The viewport parameters taken from element  i of <c>pViewports</c>
replace the current state for the viewport index  <c>firstViewport</c>
+  i, for  i in  [0, <c>viewportCount</c>).



Valid Usage
<list type="bullet"><item><description>

The currently bound graphics pipeline  must have been created with the
<c>VK_DYNAMIC_STATE_VIEWPORT</c> dynamic state enabled
</description></item><item><description>
<c>firstViewport</c> must be less than
<c>VkPhysicalDeviceLimits</c>::<c>maxViewports</c>
</description></item><item><description>

The sum of <c>firstViewport</c> and <c>viewportCount</c> must be between
<c>1</c> and <c>VkPhysicalDeviceLimits</c>::<c>maxViewports</c>, inclusive
</description></item><item><description>

If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-multiViewport">multiple viewports</a> feature is
not enabled, <c>firstViewport</c> must be <c>0</c>
</description></item><item><description>

If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-multiViewport">multiple viewports</a> feature is
not enabled, <c>viewportCount</c> must be <c>1</c>
</description></item><item><description>
<c>pViewports</c> must be a pointer to an array of <c>viewportCount</c>
valid <c>VkViewport</c> structures
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>commandBuffer</c> must be a valid <c>VkCommandBuffer</c> handle
</description></item><item><description>
<c>commandBuffer</c> must be in the  recording state
</description></item><item><description>
 The <c>VkCommandPool</c> that <c>commandBuffer</c> was allocated from  must support graphics operations
</description></item><item><description>
<c>viewportCount</c> must be greater than <c>0</c>
</description></item></list>




Host Synchronization
<list type="bullet"><item><description>
Host access to <c>commandBuffer</c> must  be externally synchronized
</description></item><item><description>
Host access to the <c>VkCommandPool</c> that <c>commandBuffer</c> was allocated from  must be externally synchronized
</description></item></list>




Command Properties
<list type="table">       <listheader><tr><term> Command Buffer Levels </term><term> Render Pass Scope </term><term> Supported Queue Types </term><term> Pipeline Type </term></tr></listheader>
<item><term>
Primary<br />
Secondary
</term><term>
Both
</term><term>
Graphics
</term><term></term></item>
</list>



If the bound pipeline state object was not created with the
<c>VK_DYNAMIC_STATE_VIEWPORT</c> dynamic state enabled, viewport
transformation parameters are specified using the <c>pViewports</c> member of
<c>VkPipelineViewportStateCreateInfo</c> in the pipeline state object.
If the pipeline state object was created with the
<c>VK_DYNAMIC_STATE_VIEWPORT</c> dynamic state enabled, the viewport
transformation parameters are dynamically set and changed with the command:


<code> void vkCmdSetViewport(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    firstViewport,
    uint32_t                                    viewportCount,
    const VkViewport*                           pViewports); </code>

</remarks>
      <seealso cref="T:VkCommandBuffer" />
      <seealso cref="T:VkViewport" />
    </member>
    <member name="T:IVkDeviceGroupSwapchainCreateInfoKHX" />
    <member name="T:VkDeviceGroupSwapchainCreateInfoKHX32">
      <summary>See: <see cref="T:IVkDeviceGroupSwapchainCreateInfoKHX" /></summary>
      <seealso cref="T:IVkDeviceGroupSwapchainCreateInfoKHX" />
    </member>
    <member name="T:VkDeviceGroupSwapchainCreateInfoKHX64">
      <summary>See: <see cref="T:IVkDeviceGroupSwapchainCreateInfoKHX" /></summary>
      <seealso cref="T:IVkDeviceGroupSwapchainCreateInfoKHX" />
    </member>
    <member name="T:IVkDisplayPresentInfoKHR" />
    <member name="T:VkDisplayPresentInfoKHR32">
      <summary>See: <see cref="T:IVkDisplayPresentInfoKHR" /></summary>
      <seealso cref="T:IVkDisplayPresentInfoKHR" />
    </member>
    <member name="T:VkDisplayPresentInfoKHR64">
      <summary>See: <see cref="T:IVkDisplayPresentInfoKHR" /></summary>
      <seealso cref="T:IVkDisplayPresentInfoKHR" />
    </member>
    <member name="T:vkDestroySemaphore">
      <summary>Destroy a semaphore object</summary>
      <remarks>


Valid Usage
<list type="bullet"><item><description>

All submitted batches that refer to <c>semaphore</c> must  have completed
execution
</description></item><item><description>

If <c>VkAllocationCallbacks</c> were provided when <c>semaphore</c> was
created, a compatible set of callbacks  must be provided here
</description></item><item><description>

If no <c>VkAllocationCallbacks</c> were provided when <c>semaphore</c> was
created, <c>pAllocator</c> must be <c>NULL</c>
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>device</c> must be a valid <c>VkDevice</c> handle
</description></item><item><description>
 If <c>semaphore</c> is not <see cref="!:VK_NULL_HANDLE" />, <c>semaphore</c> must be a valid <c>VkSemaphore</c> handle
</description></item><item><description>
 If <c>pAllocator</c> is not <c>NULL</c>, <c>pAllocator</c> must be a pointer to a valid <c>VkAllocationCallbacks</c> structure
</description></item><item><description>
 If <c>semaphore</c> is a valid handle, it  must have been created, allocated, or retrieved from <c>device</c>
</description></item></list>




Host Synchronization
<list type="bullet"><item><description>
Host access to <c>semaphore</c> must  be externally synchronized
</description></item></list>




To destroy a semaphore, call:


<code> void vkDestroySemaphore(
    VkDevice                                    device,
    VkSemaphore                                 semaphore,
    const VkAllocationCallbacks*                pAllocator); </code>

</remarks>
      <seealso cref="T:IVkAllocationCallbacks" />
      <seealso cref="T:VkDevice" />
      <seealso cref="T:VkSemaphore" />
    </member>
    <member name="T:vkQueueSubmit">
      <summary>Submits a sequence of semaphores or command buffers to a queue</summary>
      <remarks>
<list type="table"><tr><td><i title="Note"></i></td><td>
Note

Submission can be a high overhead operation, and applications  should
attempt to batch work together into as few calls to <c>vkQueueSubmit</c> as
possible.

</td></tr></list>

<c>vkQueueSubmit</c> is a <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#devsandqueues-submission">queue submission
command</a>, with each batch defined by an element of <c>pSubmits</c> as an
instance of the <see cref="T:IVkSubmitInfo" /> structure.
Batches begin execution in the order they appear in <c>pSubmits</c>, but  may
complete out of order.


Fence and semaphore operations submitted with <see cref="T:vkQueueSubmit" /> have
additional ordering constraints compared to other submission commands, with
dependencies involving previous and subsequent queue operations.
Information about these additional constraints can be found in the
<a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-semaphores">semaphore</a> and <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-fences">fence</a> sections of <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization">the synchronization chapter</a>.


Details on the interaction of <c>pWaitDstStageMask</c> with synchronization
are described in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-semaphores-waiting">semaphore wait
operation</a> section of <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization">the synchronization chapter</a>.


The order that batches appear in <c>pSubmits</c> is used to determine
<a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-submission-order">submission order</a>, and thus all the
<a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-implicit">implicit ordering guarantees</a> that respect it.
Other than these implicit ordering guarantees and any <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization">explicit synchronization primitives</a>, these batches  may overlap or
otherwise execute out of order.


If any command buffer submitted to this queue is in the
<a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#commandbuffers-lifecycle">executable state</a>, it is moved to the
<a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#commandbuffers-lifecycle">pending state</a>.
Once execution of all submissions of a command buffer complete, it moves
from the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#commandbuffers-lifecycle">pending state</a>, back to the
<a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#commandbuffers-lifecycle">executable state</a>.
If a command buffer was recorded with the
<c>VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT</c> flag, it instead moves
back to the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#commandbuffers-lifecycle">invalid state</a>.


If <c>vkQueueSubmit</c> fails, it  may return
<c>VK_ERROR_OUT_OF_HOST_MEMORY</c> or <c>VK_ERROR_OUT_OF_DEVICE_MEMORY</c>.
If it does, the implementation  must ensure that the state and contents of
any resources or synchronization primitives referenced by the submitted
command buffers and any semaphores referenced by <c>pSubmits</c> is
unaffected by the call or its failure.
If <c>vkQueueSubmit</c> fails in such a way that the implementation  can not
make that guarantee, the implementation  must return
<c>VK_ERROR_DEVICE_LOST</c>.
See <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#devsandqueues-lost-device">Lost Device</a>.



Valid Usage
<list type="bullet"><item><description>

If <c>fence</c> is not <see cref="!:VK_NULL_HANDLE" />, <c>fence</c> must  be
unsignaled
</description></item><item><description>

If <c>fence</c> is not <see cref="!:VK_NULL_HANDLE" />, <c>fence</c> must  not be
associated with any other queue command that has not yet completed
execution on that queue
</description></item><item><description>

Any calls to <see cref="T:vkCmdSetEvent" />, <see cref="T:vkCmdResetEvent" /> or
<see cref="T:vkCmdWaitEvents" /> that have been recorded into any of the command
buffer elements of the <c>pCommandBuffers</c> member of any element of
<c>pSubmits</c>,  must not reference any <see cref="T:VkEvent" /> that is referenced
by any of those commands in a command buffer that has been submitted to
another queue and is still in the  pending state.
</description></item><item><description>

Any stage flag included in any element of the <c>pWaitDstStageMask</c>
member of any element of <c>pSubmits</c> must be a pipeline stage
supported by one of the capabilities of <c>queue</c>, as specified in the
<a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-pipeline-stages-supported">table of supported pipeline
stages</a>.
</description></item><item><description>

Any given element of the <c>pSignalSemaphores</c> member of any element
of <c>pSubmits</c> must  be unsignaled when the semaphore signal
operation it defines is executed on the device
</description></item><item><description>

When a semaphore unsignal operation defined by any element of the
<c>pWaitSemaphores</c> member of any element of <c>pSubmits</c> executes
on <c>queue</c>, no other queue  must be waiting on the same semaphore.
</description></item><item><description>

All elements of the <c>pWaitSemaphores</c> member of all elements of
<c>pSubmits</c> must be semaphores that are signaled, or have
<a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-semaphores-signaling">semaphore signal operations</a>
previously submitted for execution.
</description></item><item><description>

Any given element of the <c>pCommandBuffers</c> member of any element of
<c>pSubmits</c> must be in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#commandbuffers-lifecycle">pending or
executable state</a>.
</description></item><item><description>

If any given element of the <c>pCommandBuffers</c> member of any element
of <c>pSubmits</c> was not recorded with the
<c>VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT</c>, it  must not be in
the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#commandbuffers-lifecycle">pending state</a>.
</description></item><item><description>

Any <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#commandbuffers-secondary">secondary command buffers recorded</a>
into any given element of the <c>pCommandBuffers</c> member of any
element of <c>pSubmits</c> must be in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#commandbuffers-lifecycle">pending or executable state</a>.
</description></item><item><description>

If any <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#commandbuffers-secondary">secondary command buffers recorded</a>
into any given element of the <c>pCommandBuffers</c> member of any
element of <c>pSubmits</c> was not recorded with the
<c>VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT</c>, it  must not be in
the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#commandbuffers-lifecycle">pending state</a>.
</description></item><item><description>

Any given element of the <c>pCommandBuffers</c> member of any element of
<c>pSubmits</c> must have been allocated from a <c>VkCommandPool</c> that
was created for the same queue family <c>queue</c> belongs to.
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>queue</c> must be a valid <c>VkQueue</c> handle
</description></item><item><description>
 If <c>submitCount</c> is not <c>0</c>, <c>pSubmits</c> must be a pointer to an array of <c>submitCount</c> valid <c>VkSubmitInfo</c> structures
</description></item><item><description>
 If <c>fence</c> is not <see cref="!:VK_NULL_HANDLE" />, <c>fence</c> must be a valid <c>VkFence</c> handle
</description></item><item><description>
 Both of <c>fence</c>, and <c>queue</c> that are valid handles  must have been created, allocated, or retrieved from the same <c>VkDevice</c>
</description></item></list>




Host Synchronization
<list type="bullet"><item><description>
Host access to <c>queue</c> must  be externally synchronized
</description></item><item><description>
Host access to <c>pSubmits</c>[].pWaitSemaphores[]  must be externally synchronized
</description></item><item><description>
Host access to <c>pSubmits</c>[].pSignalSemaphores[]  must be externally synchronized
</description></item><item><description>
Host access to <c>fence</c> must  be externally synchronized
</description></item></list>




Command Properties
<list type="table">       <listheader><tr><term> Command Buffer Levels </term><term> Render Pass Scope </term><term> Supported Queue Types </term><term> Pipeline Type </term></tr></listheader>
<item><term>
-
</term><term>
-
</term><term>
Any
</term><term>
-
</term></item>
</list>



Return Codes
<dl><dt>On success, this command returns</dt><dd>
<list type="bullet"><item><description>
<c>VK_SUCCESS</c>
</description></item></list>
</dd><dt>On failure, this command returns</dt><dd>
<list type="bullet"><item><description>
<c>VK_ERROR_OUT_OF_HOST_MEMORY</c>
</description></item><item><description>
<c>VK_ERROR_OUT_OF_DEVICE_MEMORY</c>
</description></item><item><description>
<c>VK_ERROR_DEVICE_LOST</c>
</description></item></list>
</dd></dl>




To submit command buffers to a queue, call:


<code> VkResult vkQueueSubmit(
    VkQueue                                     queue,
    uint32_t                                    submitCount,
    const VkSubmitInfo*                         pSubmits,
    VkFence                                     fence); </code>

</remarks>
      <seealso cref="T:VkFence" />
      <seealso cref="T:VkQueue" />
      <seealso cref="T:IVkSubmitInfo" />
    </member>
    <member name="T:VkImageSubresourceRange">
      <summary>Structure specifying a image subresource range</summary>
      <remarks>

The number of mipmap levels and array layers  must be a subset of the image
subresources in the image.
If an application wants to use all mip levels or layers in an image after
the <c>baseMipLevel</c> or <c>baseArrayLayer</c>, it  can set <c>levelCount</c>
and <c>layerCount</c> to the special values <c>VK_REMAINING_MIP_LEVELS</c> and
<c>VK_REMAINING_ARRAY_LAYERS</c> without knowing the exact number of mip
levels or layers.


For cube and cube array image views, the layers of the image view starting
at <c>baseArrayLayer</c> correspond to faces in the order +X, -X, +Y, -Y, +Z,
-Z.
For cube arrays, each set of six sequential layers is a single cube, so the
number of cube maps in a cube map array view is  <c>layerCount</c> / 6, and
image array layer  (<c>baseArrayLayer</c> +  i) is face index
 (i mod 6) of cube  i / 6.
If the number of layers in the view, whether set explicitly in
<c>layerCount</c> or implied by <c>VK_REMAINING_ARRAY_LAYERS</c>, is not a
multiple of 6, behavior when indexing the last cube is undefined.


<c>aspectMask</c> must be only <c>VK_IMAGE_ASPECT_COLOR_BIT</c>,
<c>VK_IMAGE_ASPECT_DEPTH_BIT</c> or <c>VK_IMAGE_ASPECT_STENCIL_BIT</c> if
<c>format</c> is a color, depth-only or stencil-only format, respectively.
If using a depth/stencil format with both depth and stencil components,
<c>aspectMask</c> must include at least one of
<c>VK_IMAGE_ASPECT_DEPTH_BIT</c> and <c>VK_IMAGE_ASPECT_STENCIL_BIT</c>, and
 can include both.


When using an imageView of a depth/stencil image to populate a descriptor
set (e.g. for sampling in the shader, or for use as an input attachment),
the <c>aspectMask</c> must only include one bit and selects whether the
imageView is used for depth reads (i.e. using a floating-point sampler or
input attachment in the shader) or stencil reads (i.e. using an unsigned
integer sampler or input attachment in the shader).
When an imageView of a depth/stencil image is used as a depth/stencil
framebuffer attachment, the <c>aspectMask</c> is ignored and both depth and
stencil image subresources are used.


The <c>components</c> member is of type <see cref="T:VkComponentMapping" />, and
describes a remapping from components of the image to components of the
vector returned by shader image instructions.
This remapping  must be identity for storage image descriptors, input
attachment descriptors, and framebuffer attachments.



Valid Usage
<list type="bullet"><item><description>

If <c>levelCount</c> is not <c>VK_REMAINING_MIP_LEVELS</c>,
 <c>levelCount</c> must be non-zero and  (<c>baseMipLevel</c>
+  <c>levelCount</c>) must be less than or equal to the
<c>mipLevels</c> specified in <see cref="T:IVkImageCreateInfo" /> when the image was
created
</description></item><item><description>

If <c>layerCount</c> is not <c>VK_REMAINING_ARRAY_LAYERS</c>,
 <c>layerCount</c> must be non-zero and  (<c>baseArrayLayer</c>
+  <c>layerCount</c>) must be less than or equal to the
<c>arrayLayers</c> specified in <see cref="T:IVkImageCreateInfo" /> when the image
was created
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>aspectMask</c> must be a valid combination of <see cref="T:VkImageAspectFlags" /> values
</description></item><item><description>
<c>aspectMask</c> must not be <c>0</c>
</description></item></list>




The <c>VkImageSubresourceRange</c> structure is defined as:


<code> typedef struct VkImageSubresourceRange {
    VkImageAspectFlags    aspectMask;
    uint32_t              baseMipLevel;
    uint32_t              levelCount;
    uint32_t              baseArrayLayer;
    uint32_t              layerCount;
} VkImageSubresourceRange; </code>

</remarks>
      <seealso cref="T:VkImageAspectFlags" />
      <seealso cref="T:IVkImageMemoryBarrier" />
      <seealso cref="T:IVkImageViewCreateInfo" />
      <seealso cref="T:vkCmdClearColorImage" />
      <seealso cref="T:vkCmdClearDepthStencilImage" />
    </member>
    <member name="T:vkGetPhysicalDeviceSurfaceSupportKHR" />
    <member name="T:vkGetSwapchainCounterEXT" />
    <member name="T:IVkBufferViewCreateInfo">
      <summary>Structure specifying parameters of a newly created buffer view</summary>
      <remarks>


Valid Usage
<list type="bullet"><item><description>
<c>offset</c> must be less than the size of <c>buffer</c>
</description></item><item><description>
<c>offset</c> must be a multiple of
<c>VkPhysicalDeviceLimits</c>::<c>minTexelBufferOffsetAlignment</c>
</description></item><item><description>

If <c>range</c> is not equal to <c>VK_WHOLE_SIZE</c>, <c>range</c> must be
greater than <c>0</c>
</description></item><item><description>

If <c>range</c> is not equal to <c>VK_WHOLE_SIZE</c>, <c>range</c> must be
a multiple of the element size of <c>format</c>
</description></item><item><description>

If <c>range</c> is not equal to <c>VK_WHOLE_SIZE</c>, <c>range</c> divided
by the element size of <c>format</c> must be less than or equal to
<c>VkPhysicalDeviceLimits</c>::<c>maxTexelBufferElements</c>
</description></item><item><description>

If <c>range</c> is not equal to <c>VK_WHOLE_SIZE</c>, the sum of
<c>offset</c> and <c>range</c> must be less than or equal to the size of
<c>buffer</c>
</description></item><item><description>
<c>buffer</c> must have been created with a <c>usage</c> value containing
at least one of <c>VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT</c> or
<c>VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT</c>
</description></item><item><description>

If <c>buffer</c> was created with <c>usage</c> containing
<c>VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT</c>, <c>format</c> must be
supported for uniform texel buffers, as specified by the
<c>VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT</c> flag in
<c>VkFormatProperties</c>::<c>bufferFeatures</c> returned by
<c>vkGetPhysicalDeviceFormatProperties</c>
</description></item><item><description>

If <c>buffer</c> was created with <c>usage</c> containing
<c>VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT</c>, <c>format</c> must be
supported for storage texel buffers, as specified by the
<c>VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT</c> flag in
<c>VkFormatProperties</c>::<c>bufferFeatures</c> returned by
<c>vkGetPhysicalDeviceFormatProperties</c>
</description></item><item><description>

If <c>buffer</c> is non-sparse then it  must be bound completely and
contiguously to a single <c>VkDeviceMemory</c> object
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>sType</c> must be <c>VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO</c>
</description></item><item><description>
<c>pNext</c> must be <c>NULL</c>
</description></item><item><description>
<c>flags</c> must be <c>0</c>
</description></item><item><description>
<c>buffer</c> must be a valid <c>VkBuffer</c> handle
</description></item><item><description>
<c>format</c> must be a valid <see cref="T:VkFormat" /> value
</description></item></list>




The <c>VkBufferViewCreateInfo</c> structure is defined as:


<code> typedef struct VkBufferViewCreateInfo {
    VkStructureType            sType;
    const void*                pNext;
    VkBufferViewCreateFlags    flags;
    VkBuffer                   buffer;
    VkFormat                   format;
    VkDeviceSize               offset;
    VkDeviceSize               range;
} VkBufferViewCreateInfo; </code>

</remarks>
      <seealso cref="T:VkBuffer" />
      <seealso cref="T:VkBufferViewCreateFlags" />
      <seealso cref="T:VkFormat" />
      <seealso cref="T:VkStructureType" />
      <seealso cref="T:vkCreateBufferView" />
    </member>
    <member name="T:VkBufferViewCreateInfo32">
      <summary>See: <see cref="T:IVkBufferViewCreateInfo" /></summary>
      <seealso cref="T:IVkBufferViewCreateInfo" />
    </member>
    <member name="T:VkBufferViewCreateInfo64">
      <summary>See: <see cref="T:IVkBufferViewCreateInfo" /></summary>
      <seealso cref="T:IVkBufferViewCreateInfo" />
    </member>
    <member name="T:vkCmdDrawIndexedIndirectCountAMD" />
    <member name="T:vkCmdBeginRenderPass">
      <summary>Begin a new render pass</summary>
      <remarks>

After beginning a render pass instance, the command buffer is ready to
record the commands for the first subpass of that render pass.



Valid Usage
<list type="bullet"><item><description>

If any of the <c>initialLayout</c> or <c>finalLayout</c> member of the
<c>VkAttachmentDescription</c> structures or the <c>layout</c> member of
the <c>VkAttachmentReference</c> structures specified when creating the
render pass specified in the <c>renderPass</c> member of
<c>pRenderPassBegin</c> is <c>VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL</c>
then the corresponding attachment image subresource of the framebuffer
specified in the <c>framebuffer</c> member of <c>pRenderPassBegin</c> must have been created with <c>VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT</c>
set
</description></item><item><description>

If any of the <c>initialLayout</c> or <c>finalLayout</c> member of the
<c>VkAttachmentDescription</c> structures or the <c>layout</c> member of
the <c>VkAttachmentReference</c> structures specified when creating the
render pass specified in the <c>renderPass</c> member of
<c>pRenderPassBegin</c> is
<c>VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL</c> or
<c>VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL</c> then the
corresponding attachment image subresource of the framebuffer specified
in the <c>framebuffer</c> member of <c>pRenderPassBegin</c> must have
been created with <c>VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT</c> set
</description></item><item><description>

If any of the <c>initialLayout</c> or <c>finalLayout</c> member of the
<c>VkAttachmentDescription</c> structures or the <c>layout</c> member of
the <c>VkAttachmentReference</c> structures specified when creating the
render pass specified in the <c>renderPass</c> member of
<c>pRenderPassBegin</c> is <c>VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL</c>
then the corresponding attachment image subresource of the framebuffer
specified in the <c>framebuffer</c> member of <c>pRenderPassBegin</c> must have been created with <c>VK_IMAGE_USAGE_SAMPLED_BIT</c> or
<c>VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT</c> set
</description></item><item><description>

If any of the <c>initialLayout</c> or <c>finalLayout</c> member of the
<c>VkAttachmentDescription</c> structures or the <c>layout</c> member of
the <c>VkAttachmentReference</c> structures specified when creating the
render pass specified in the <c>renderPass</c> member of
<c>pRenderPassBegin</c> is <c>VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL</c>
then the corresponding attachment image subresource of the framebuffer
specified in the <c>framebuffer</c> member of <c>pRenderPassBegin</c> must have been created with <c>VK_IMAGE_USAGE_TRANSFER_SRC_BIT</c> set
</description></item><item><description>

If any of the <c>initialLayout</c> or <c>finalLayout</c> member of the
<c>VkAttachmentDescription</c> structures or the <c>layout</c> member of
the <c>VkAttachmentReference</c> structures specified when creating the
render pass specified in the <c>renderPass</c> member of
<c>pRenderPassBegin</c> is <c>VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL</c>
then the corresponding attachment image subresource of the framebuffer
specified in the <c>framebuffer</c> member of <c>pRenderPassBegin</c> must have been created with <c>VK_IMAGE_USAGE_TRANSFER_DST_BIT</c> set
</description></item><item><description>

If any of the <c>initialLayout</c> members of the
<c>VkAttachmentDescription</c> structures specified when creating the
render pass specified in the <c>renderPass</c> member of
<c>pRenderPassBegin</c> is not <c>VK_IMAGE_LAYOUT_UNDEFINED</c>, then each
such <c>initialLayout</c> must be equal to the current layout of the
corresponding attachment image subresource of the framebuffer specified
in the <c>framebuffer</c> member of <c>pRenderPassBegin</c>
</description></item><item><description>

The <c>srcStageMask</c> and <c>dstStageMask</c> members of any element of
the <c>pDependencies</c> member of <see cref="T:IVkRenderPassCreateInfo" /> used to
create <c>renderpass</c> must be supported by the capabilities of the
queue family identified by the <c>queueFamilyIndex</c> member of the
<see cref="T:IVkCommandPoolCreateInfo" /> used to create the command pool which
<c>commandBuffer</c> was allocated from.
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>commandBuffer</c> must be a valid <c>VkCommandBuffer</c> handle
</description></item><item><description>
<c>pRenderPassBegin</c> must be a pointer to a valid <c>VkRenderPassBeginInfo</c> structure
</description></item><item><description>
<c>contents</c> must be a valid <see cref="T:VkSubpassContents" /> value
</description></item><item><description>
<c>commandBuffer</c> must be in the  recording state
</description></item><item><description>
 The <c>VkCommandPool</c> that <c>commandBuffer</c> was allocated from  must support graphics operations
</description></item><item><description>
 This command  must only be called outside of a render pass instance
</description></item><item><description>
<c>commandBuffer</c> must be a primary <c>VkCommandBuffer</c>
</description></item></list>




Host Synchronization
<list type="bullet"><item><description>
Host access to <c>commandBuffer</c> must  be externally synchronized
</description></item><item><description>
Host access to the <c>VkCommandPool</c> that <c>commandBuffer</c> was allocated from  must be externally synchronized
</description></item></list>




Command Properties
<list type="table">       <listheader><tr><term> Command Buffer Levels </term><term> Render Pass Scope </term><term> Supported Queue Types </term><term> Pipeline Type </term></tr></listheader>
<item><term>
Primary
</term><term>
Outside
</term><term>
Graphics
</term><term>
Graphics
</term></item>
</list>



To begin a render pass instance, call:


<code> void vkCmdBeginRenderPass(
    VkCommandBuffer                             commandBuffer,
    const VkRenderPassBeginInfo*                pRenderPassBegin,
    VkSubpassContents                           contents); </code>

</remarks>
      <seealso cref="T:VkCommandBuffer" />
      <seealso cref="T:IVkRenderPassBeginInfo" />
      <seealso cref="T:VkSubpassContents" />
    </member>
    <member name="T:IVkExternalMemoryImageCreateInfoNV" />
    <member name="T:VkExternalMemoryImageCreateInfoNV32">
      <summary>See: <see cref="T:IVkExternalMemoryImageCreateInfoNV" /></summary>
      <seealso cref="T:IVkExternalMemoryImageCreateInfoNV" />
    </member>
    <member name="T:VkExternalMemoryImageCreateInfoNV64">
      <summary>See: <see cref="T:IVkExternalMemoryImageCreateInfoNV" /></summary>
      <seealso cref="T:IVkExternalMemoryImageCreateInfoNV" />
    </member>
    <member name="T:IVkFramebufferCreateInfo">
      <summary>Structure specifying parameters of a newly created framebuffer</summary>
      <remarks>

Image subresources used as attachments  must not be used via any
non-attachment usage for the duration of a render pass instance.

<list type="table"><tr><td><i title="Note"></i></td><td>
Note

This restriction means that the render pass has full knowledge of all uses
of all of the attachments, so that the implementation is able to make
correct decisions about when and how to perform layout transitions, when to
overlap execution of subpasses, etc.

</td></tr></list>

It is legal for a subpass to use no color or depth/stencil attachments, and
rather use shader side effects such as image stores and atomics to produce
an output.
In this case, the subpass continues to use the <c>width</c>, <c>height</c>,
and <c>layers</c> of the framebuffer to define the dimensions of the
rendering area, and the <c>rasterizationSamples</c> from each pipeline&amp;#8217;s
<see cref="T:IVkPipelineMultisampleStateCreateInfo" /> to define the number of samples
used in rasterization; however, if
<see cref="T:VkPhysicalDeviceFeatures" />::<c>variableMultisampleRate</c> is
<c>VK_FALSE</c>, then all pipelines to be bound with a given zero-attachment
subpass  must have the same value for
<see cref="T:IVkPipelineMultisampleStateCreateInfo" />::<c>rasterizationSamples</c>.



Valid Usage
<list type="bullet"><item><description>
<c>attachmentCount</c> must be equal to the attachment count specified
in <c>renderPass</c>
</description></item><item><description>

Any given element of <c>pAttachments</c> that is used as a color
attachment or resolve attachment by <c>renderPass</c> must have been
created with a <c>usage</c> value including
<c>VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT</c>
</description></item><item><description>

Any given element of <c>pAttachments</c> that is used as a depth/stencil
attachment by <c>renderPass</c> must have been created with a
<c>usage</c> value including
<c>VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT</c>
</description></item><item><description>

Any given element of <c>pAttachments</c> that is used as an input
attachment by <c>renderPass</c> must have been created with a
<c>usage</c> value including <c>VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT</c>
</description></item><item><description>

Any given element of <c>pAttachments</c> must have been created with an
<see cref="T:VkFormat" /> value that matches the <see cref="T:VkFormat" /> specified by the
corresponding <c>VkAttachmentDescription</c> in <c>renderPass</c>
</description></item><item><description>

Any given element of <c>pAttachments</c> must have been created with a
<c>samples</c> value that matches the <c>samples</c> value specified by
the corresponding <c>VkAttachmentDescription</c> in <c>renderPass</c>
</description></item><item><description>

Any given element of <c>pAttachments</c> must  have dimensions at least
as large as the corresponding framebuffer dimension
</description></item><item><description>

Any given element of <c>pAttachments</c> must  only specify a single mip
level
</description></item><item><description>

Any given element of <c>pAttachments</c> must  have been created with the
identity swizzle
</description></item><item><description>
<c>width</c> must be greater than <c>0</c>.
</description></item><item><description>
<c>width</c> must be less than or equal to
<c>VkPhysicalDeviceLimits</c>::<c>maxFramebufferWidth</c>
</description></item><item><description>
<c>height</c> must be greater than <c>0</c>.
</description></item><item><description>
<c>height</c> must be less than or equal to
<c>VkPhysicalDeviceLimits</c>::<c>maxFramebufferHeight</c>
</description></item><item><description>
<c>layers</c> must be greater than <c>0</c>.
</description></item><item><description>
<c>layers</c> must be less than or equal to
<c>VkPhysicalDeviceLimits</c>::<c>maxFramebufferLayers</c>
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>sType</c> must be <c>VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO</c>
</description></item><item><description>
<c>pNext</c> must be <c>NULL</c>
</description></item><item><description>
<c>flags</c> must be <c>0</c>
</description></item><item><description>
<c>renderPass</c> must be a valid <c>VkRenderPass</c> handle
</description></item><item><description>
 If <c>attachmentCount</c> is not <c>0</c>, <c>pAttachments</c> must be a pointer to an array of <c>attachmentCount</c> valid <c>VkImageView</c> handles
</description></item><item><description>
 Both of <c>renderPass</c>, and the elements of <c>pAttachments</c> that are valid handles  must have been created, allocated, or retrieved from the same <c>VkDevice</c>
</description></item></list>




The <c>VkFramebufferCreateInfo</c> structure is defined as:


<code> typedef struct VkFramebufferCreateInfo {
    VkStructureType             sType;
    const void*                 pNext;
    VkFramebufferCreateFlags    flags;
    VkRenderPass                renderPass;
    uint32_t                    attachmentCount;
    const VkImageView*          pAttachments;
    uint32_t                    width;
    uint32_t                    height;
    uint32_t                    layers;
} VkFramebufferCreateInfo; </code>

</remarks>
      <seealso cref="T:VkFramebufferCreateFlags" />
      <seealso cref="T:VkImageView" />
      <seealso cref="T:VkRenderPass" />
      <seealso cref="T:VkStructureType" />
      <seealso cref="T:vkCreateFramebuffer" />
    </member>
    <member name="T:VkFramebufferCreateInfo32">
      <summary>See: <see cref="T:IVkFramebufferCreateInfo" /></summary>
      <seealso cref="T:IVkFramebufferCreateInfo" />
    </member>
    <member name="T:VkFramebufferCreateInfo64">
      <summary>See: <see cref="T:IVkFramebufferCreateInfo" /></summary>
      <seealso cref="T:IVkFramebufferCreateInfo" />
    </member>
    <member name="T:vkDestroyFence">
      <summary>Destroy a fence object</summary>
      <remarks>


Valid Usage
<list type="bullet"><item><description>

All <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#devsandqueues-submission">queue submission</a> commands that refer
to <c>fence</c> must  have completed execution
</description></item><item><description>

If <c>VkAllocationCallbacks</c> were provided when <c>fence</c> was
created, a compatible set of callbacks  must be provided here
</description></item><item><description>

If no <c>VkAllocationCallbacks</c> were provided when <c>fence</c> was
created, <c>pAllocator</c> must be <c>NULL</c>
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>device</c> must be a valid <c>VkDevice</c> handle
</description></item><item><description>
 If <c>fence</c> is not <see cref="!:VK_NULL_HANDLE" />, <c>fence</c> must be a valid <c>VkFence</c> handle
</description></item><item><description>
 If <c>pAllocator</c> is not <c>NULL</c>, <c>pAllocator</c> must be a pointer to a valid <c>VkAllocationCallbacks</c> structure
</description></item><item><description>
 If <c>fence</c> is a valid handle, it  must have been created, allocated, or retrieved from <c>device</c>
</description></item></list>




Host Synchronization
<list type="bullet"><item><description>
Host access to <c>fence</c> must  be externally synchronized
</description></item></list>




To destroy a fence, call:


<code> void vkDestroyFence(
    VkDevice                                    device,
    VkFence                                     fence,
    const VkAllocationCallbacks*                pAllocator); </code>

</remarks>
      <seealso cref="T:IVkAllocationCallbacks" />
      <seealso cref="T:VkDevice" />
      <seealso cref="T:VkFence" />
    </member>
    <member name="T:VkExtent2D">
      <summary>Structure specifying a two-dimensional extent</summary>
      <remarks>

A two-dimensional extent is defined by the structure:


<code> typedef struct VkExtent2D {
    uint32_t    width;
    uint32_t    height;
} VkExtent2D; </code>

</remarks>
      <seealso cref="T:VkRect2D" />
      <seealso cref="T:vkGetRenderAreaGranularity" />
    </member>
    <member name="T:vkEnumeratePhysicalDeviceGroupsKHX" />
    <member name="T:vkGetInstanceProcAddr">
      <summary>Return a function pointer for a command</summary>
      <remarks>

<c>vkGetInstanceProcAddr</c> itself is obtained in a platform- and loader-
specific manner.
Typically, the loader library will export this command as a function symbol,
so applications  can link against the loader library, or load it dynamically
and look up the symbol using platform-specific APIs.
Loaders are encouraged to export function symbols for all other core Vulkan
commands as well; if this is done, then applications that use only the core
Vulkan commands have no need to use <c>vkGetInstanceProcAddr</c>.


The table below defines the various use cases for
<c>vkGetInstanceProcAddr</c> and expected return value ("fp" is function
pointer) for each case.


The returned function pointer is of type <see cref="T:PFN_vkVoidFunction" />, and must
be cast to the type of the command being queried.

<para>Table 1. vkGetInstanceProcAddr behavior</para><list type="table">      <listheader><tr><term><c>instance</c></term><term><c>pName</c></term><term>return value</term></tr></listheader>
<item><term>
*
</term><term>
<c>NULL</c>
</term><term>
undefined
</term></item><item><term>
invalid instance
</term><term>
*
</term><term>
undefined
</term></item><item><term>
<c>NULL</c>
</term><term>
<see cref="T:vkEnumerateInstanceExtensionProperties" />
</term><term>
fp
</term></item><item><term>
<c>NULL</c>
</term><term>
<see cref="T:vkEnumerateInstanceLayerProperties" />
</term><term>
fp
</term></item><item><term>
<c>NULL</c>
</term><term>
<see cref="T:vkCreateInstance" />
</term><term>
fp
</term></item><item><term>
<c>NULL</c>
</term><term>
* (any <c>pName</c> not covered above)
</term><term>
<c>NULL</c>
</term></item><item><term>
instance
</term><term>
core Vulkan command
</term><term>
fp<sup>1</sup>
</term></item><item><term>
instance
</term><term>
enabled instance extension commands for <c>instance</c>
</term><term>
fp<sup>1</sup>
</term></item><item><term>
instance
</term><term>
available device extension<sup>2</sup> commands for <c>instance</c>
</term><term>
fp<sup>1</sup>
</term></item><item><term>
instance
</term><term>
* (any <c>pName</c> not covered above)
</term><term>
<c>NULL</c>
</term></item>
</list>
<dl><dt>1</dt><dd>
The returned function pointer  must only be called with a dispatchable
object (the first parameter) that is <c>instance</c> or a child of
<c>instance</c>.
e.g. <c>VkInstance</c>, <c>VkPhysicalDevice</c>, <c>VkDevice</c>,
<c>VkQueue</c>, or <c>VkCommandBuffer</c>.
</dd><dt>2</dt><dd>
An &amp;#8220;available extension&amp;#8221; is an extension function supported by any of
the loader, driver or layer.
</dd></dl>


Valid Usage (Implicit)
<list type="bullet"><item><description>
 If <c>instance</c> is not <c>NULL</c>, <c>instance</c> must be a valid <c>VkInstance</c> handle
</description></item><item><description>
<c>pName</c> must  be a null-terminated UTF-8 string
</description></item></list>




Vulkan commands are not necessarily exposed statically on a platform.
Function pointers for all Vulkan commands  can be obtained with the command:


<code> PFN_vkVoidFunction vkGetInstanceProcAddr(
    VkInstance                                  instance,
    const char*                                 pName); </code>

</remarks>
      <seealso cref="T:PFN_vkVoidFunction" />
      <seealso cref="T:VkInstance" />
    </member>
    <member name="T:VkRectLayerKHR" />
    <member name="T:PFN_vkFreeFunction">
      <summary>Application-defined memory free function</summary>
      <remarks>

<c>pMemory</c> may be <c>NULL</c>, which the callback  must handle safely.
If <c>pMemory</c> is non-<c>NULL</c>, it  must be a pointer previously allocated
by <c>pfnAllocation</c> or <c>pfnReallocation</c>.
The application  should free this memory.



The type of <c>pfnFree</c> is:


<code> typedef void (VKAPI_PTR *PFN_vkFreeFunction)(
    void*                                       pUserData,
    void*                                       pMemory); </code>

</remarks>
      <seealso cref="T:IVkAllocationCallbacks" />
    </member>
    <member name="T:vkBindImageMemory2KHX" />
    <member name="T:IVkPhysicalDeviceSurfaceInfo2KHR" />
    <member name="T:VkPhysicalDeviceSurfaceInfo2KHR32">
      <summary>See: <see cref="T:IVkPhysicalDeviceSurfaceInfo2KHR" /></summary>
      <seealso cref="T:IVkPhysicalDeviceSurfaceInfo2KHR" />
    </member>
    <member name="T:VkPhysicalDeviceSurfaceInfo2KHR64">
      <summary>See: <see cref="T:IVkPhysicalDeviceSurfaceInfo2KHR" /></summary>
      <seealso cref="T:IVkPhysicalDeviceSurfaceInfo2KHR" />
    </member>
    <member name="T:VkExternalMemoryPropertiesKHX" />
    <member name="T:vkGetPhysicalDeviceProperties2KHR" />
    <member name="T:vkCmdResolveImage">
      <summary>Resolve regions of an image</summary>
      <remarks>

During the resolve the samples corresponding to each pixel location in the
source are converted to a single sample before being written to the
destination.
If the source formats are floating-point or normalized types, the sample
values for each pixel are resolved in an implementation-dependent manner.
If the source formats are integer types, a single sample&amp;#8217;s value is selected
for each pixel.


<c>srcOffset</c> and <c>dstOffset</c> select the initial x, y, and z offsets
in texels of the sub-regions of the source and destination image data.
<c>extent</c> is the size in texels of the source image to resolve in
<c>width</c>, <c>height</c> and <c>depth</c>.


Resolves are done layer by layer starting with <c>baseArrayLayer</c> member
of <c>srcSubresource</c> for the source and <c>dstSubresource</c> for the
destination.
<c>layerCount</c> layers are resolved to the destination image.



Valid Usage
<list type="bullet"><item><description>

The source region specified by a given element of <c>pRegions</c> must
be a region that is contained within <c>srcImage</c>
</description></item><item><description>

The destination region specified by a given element of <c>pRegions</c> must be a region that is contained within <c>dstImage</c>
</description></item><item><description>

The union of all source regions, and the union of all destination
regions, specified by the elements of <c>pRegions</c>,  must not overlap
in memory
</description></item><item><description>

If <c>srcImage</c> is non-sparse then it  must be bound completely and
contiguously to a single <c>VkDeviceMemory</c> object
</description></item><item><description>
<c>srcImage</c> must have a sample count equal to any valid sample count
value other than <c>VK_SAMPLE_COUNT_1_BIT</c>
</description></item><item><description>

If <c>dstImage</c> is non-sparse then it  must be bound completely and
contiguously to a single <c>VkDeviceMemory</c> object
</description></item><item><description>
<c>dstImage</c> must have a sample count equal to
<c>VK_SAMPLE_COUNT_1_BIT</c>
</description></item><item><description>
<c>srcImageLayout</c> must specify the layout of the image subresources
of <c>srcImage</c> specified in <c>pRegions</c> at the time this command
is executed on a <c>VkDevice</c>
</description></item><item><description>
<c>srcImageLayout</c> must be <c>VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL</c>
or <c>VK_IMAGE_LAYOUT_GENERAL</c>
</description></item><item><description>
<c>dstImageLayout</c> must specify the layout of the image subresources
of <c>dstImage</c> specified in <c>pRegions</c> at the time this command
is executed on a <c>VkDevice</c>
</description></item><item><description>
<c>dstImageLayout</c> must be <c>VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL</c>
or <c>VK_IMAGE_LAYOUT_GENERAL</c>
</description></item><item><description>

If <c>dstImage</c> was created with <c>tiling</c> equal to
<c>VK_IMAGE_TILING_LINEAR</c>, <c>dstImage</c> must have been created
with a <c>format</c> that supports being a color attachment, as specified
by the <c>VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT</c> flag in
<c>VkFormatProperties</c>::<c>linearTilingFeatures</c> returned by
<c>vkGetPhysicalDeviceFormatProperties</c>
</description></item><item><description>

If <c>dstImage</c> was created with <c>tiling</c> equal to
<c>VK_IMAGE_TILING_OPTIMAL</c>, <c>dstImage</c> must have been created
with a <c>format</c> that supports being a color attachment, as specified
by the <c>VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT</c> flag in
<c>VkFormatProperties</c>::<c>optimalTilingFeatures</c> returned by
<c>vkGetPhysicalDeviceFormatProperties</c>
</description></item><item><description>
<c>srcImage</c> and <c>dstImage</c> must  have been created with the same
image format
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>commandBuffer</c> must be a valid <c>VkCommandBuffer</c> handle
</description></item><item><description>
<c>srcImage</c> must be a valid <c>VkImage</c> handle
</description></item><item><description>
<c>srcImageLayout</c> must be a valid <see cref="T:VkImageLayout" /> value
</description></item><item><description>
<c>dstImage</c> must be a valid <c>VkImage</c> handle
</description></item><item><description>
<c>dstImageLayout</c> must be a valid <see cref="T:VkImageLayout" /> value
</description></item><item><description>
<c>pRegions</c> must be a pointer to an array of <c>regionCount</c> valid <c>VkImageResolve</c> structures
</description></item><item><description>
<c>commandBuffer</c> must be in the  recording state
</description></item><item><description>
 The <c>VkCommandPool</c> that <c>commandBuffer</c> was allocated from  must support graphics operations
</description></item><item><description>
 This command  must only be called outside of a render pass instance
</description></item><item><description>
<c>regionCount</c> must be greater than <c>0</c>
</description></item><item><description>
 Each of <c>commandBuffer</c>, <c>dstImage</c>, and <c>srcImage</c> must have been created, allocated, or retrieved from the same <c>VkDevice</c>
</description></item></list>




Host Synchronization
<list type="bullet"><item><description>
Host access to <c>commandBuffer</c> must  be externally synchronized
</description></item><item><description>
Host access to the <c>VkCommandPool</c> that <c>commandBuffer</c> was allocated from  must be externally synchronized
</description></item></list>




Command Properties
<list type="table">       <listheader><tr><term> Command Buffer Levels </term><term> Render Pass Scope </term><term> Supported Queue Types </term><term> Pipeline Type </term></tr></listheader>
<item><term>
Primary<br />
Secondary
</term><term>
Outside
</term><term>
Graphics
</term><term>
Transfer
</term></item>
</list>



To resolve a multisample image to a non-multisample image, call:


<code> void vkCmdResolveImage(
    VkCommandBuffer                             commandBuffer,
    VkImage                                     srcImage,
    VkImageLayout                               srcImageLayout,
    VkImage                                     dstImage,
    VkImageLayout                               dstImageLayout,
    uint32_t                                    regionCount,
    const VkImageResolve*                       pRegions); </code>

</remarks>
      <seealso cref="T:VkCommandBuffer" />
      <seealso cref="T:VkImage" />
      <seealso cref="T:VkImageLayout" />
      <seealso cref="T:VkImageResolve" />
    </member>
    <member name="T:VkDrawIndirectCommand">
      <summary>Structure specifying a draw indirect command</summary>
      <remarks>

The members of <c>VkDrawIndirectCommand</c> have the same meaning as the
similarly named parameters of <see cref="T:vkCmdDraw" />.



Valid Usage
<list type="bullet"><item><description>

For a given vertex buffer binding, any attribute data fetched  must be
entirely contained within the corresponding vertex buffer binding, as
described in <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#fxvertex-input">../../html/vkspec.html#fxvertex-input</a>
</description></item><item><description>

If the
<a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-drawIndirectFirstInstance">drawIndirectFirstInstance</a>
feature is not enabled, <c>firstInstance</c> must be <c>0</c>
</description></item></list>




The <c>VkDrawIndirectCommand</c> structure is defined as:


<code> typedef struct VkDrawIndirectCommand {
    uint32_t    vertexCount;
    uint32_t    instanceCount;
    uint32_t    firstVertex;
    uint32_t    firstInstance;
} VkDrawIndirectCommand; </code>

</remarks>
      <seealso cref="T:vkCmdDrawIndirect" />
    </member>
    <member name="T:vkCmdDrawIndexedIndirect">
      <summary>Perform an indexed indirect draw</summary>
      <remarks>

<c>vkCmdDrawIndexedIndirect</c> behaves similarly to <see cref="T:vkCmdDrawIndexed" />
except that the parameters are read by the device from a buffer during
execution.
<c>drawCount</c> draws are executed by the command, with parameters taken
from <c>buffer</c> starting at <c>offset</c> and increasing by <c>stride</c>
bytes for each successive draw.
The parameters of each draw are encoded in an array of
<see cref="T:VkDrawIndexedIndirectCommand" /> structures.
If <c>drawCount</c> is less than or equal to one, <c>stride</c> is ignored.



Valid Usage
<list type="bullet"><item><description>

If <c>buffer</c> is non-sparse then it  must be bound completely and
contiguously to a single <c>VkDeviceMemory</c> object
</description></item><item><description>
<c>offset</c> must be a multiple of <c>4</c>
</description></item><item><description>

If <c>drawCount</c> is greater than <c>1</c>, <c>stride</c> must be a multiple
of <c>4</c> and  must be greater than or equal to
sizeof(<c>VkDrawIndexedIndirectCommand</c>)
</description></item><item><description>

If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-multiDrawIndirect">multi-draw indirect</a>
feature is not enabled, <c>drawCount</c> must be <c>0</c> or <c>1</c>
</description></item><item><description>

If the
<a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-drawIndirectFirstInstance">drawIndirectFirstInstance</a>
feature is not enabled, all the <c>firstInstance</c> members of the
<c>VkDrawIndexedIndirectCommand</c> structures accessed by this command
 must be <c>0</c>
</description></item><item><description>

The current render pass  must be <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#renderpass-compatibility">compatible</a>
with the <c>renderPass</c> member of the
<c>VkGraphicsPipelineCreateInfo</c> structure specified when creating the
<c>VkPipeline</c> currently bound to
<c>VK_PIPELINE_BIND_POINT_GRAPHICS</c>.
</description></item><item><description>

The subpass index of the current render pass  must be equal to the
<c>subpass</c> member of the <c>VkGraphicsPipelineCreateInfo</c> structure
specified when creating the <c>VkPipeline</c> currently bound to
<c>VK_PIPELINE_BIND_POINT_GRAPHICS</c>.
</description></item><item><description>

For each set  n that is statically used by the <c>VkPipeline</c>
currently bound to <c>VK_PIPELINE_BIND_POINT_GRAPHICS</c>, a descriptor
set  must have been bound to  n at
<c>VK_PIPELINE_BIND_POINT_GRAPHICS</c>, with a <c>VkPipelineLayout</c>
that is compatible for set  n, with the <c>VkPipelineLayout</c> used to
create the current <c>VkPipeline</c>, as described in
<a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#descriptorsets-compatibility">../../html/vkspec.html#descriptorsets-compatibility</a>
</description></item><item><description>

For each push constant that is statically used by the <c>VkPipeline</c>
currently bound to <c>VK_PIPELINE_BIND_POINT_GRAPHICS</c>, a push
constant value  must have been set for
<c>VK_PIPELINE_BIND_POINT_GRAPHICS</c>, with a <c>VkPipelineLayout</c>
that is compatible for push constants, with the <c>VkPipelineLayout</c>
used to create the current <c>VkPipeline</c>, as described in
<a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#descriptorsets-compatibility">../../html/vkspec.html#descriptorsets-compatibility</a>
</description></item><item><description>

Descriptors in each bound descriptor set, specified via
<c>vkCmdBindDescriptorSets</c>,  must be valid if they are statically
used by the currently bound <c>VkPipeline</c> object, specified via
<c>vkCmdBindPipeline</c>
</description></item><item><description>

All vertex input bindings accessed via vertex input variables declared
in the vertex shader entry point&amp;#8217;s interface  must have valid buffers
bound
</description></item><item><description>

A valid graphics pipeline  must be bound to the current command buffer
with <c>VK_PIPELINE_BIND_POINT_GRAPHICS</c>
</description></item><item><description>

If the <c>VkPipeline</c> object currently bound to
<c>VK_PIPELINE_BIND_POINT_GRAPHICS</c> requires any dynamic state, that
state  must have been set on the current command buffer
</description></item><item><description>

If <c>drawCount</c> is equal to <c>1</c>,  (<c>offset</c> + 
sizeof(<c>VkDrawIndexedIndirectCommand</c>)) must be less than or equal
to the size of <c>buffer</c>
</description></item><item><description>

If <c>drawCount</c> is greater than <c>1</c>,  (<c>stride</c> ×
(<c>drawCount</c> - 1) +  <c>offset</c> + 
sizeof(<c>VkDrawIndexedIndirectCommand</c>)) must be less than or equal
to the size of <c>buffer</c>
</description></item><item><description>
<c>drawCount</c> must be less than or equal to
<c>VkPhysicalDeviceLimits</c>::<c>maxDrawIndirectCount</c>
</description></item><item><description>

Every input attachment used by the current subpass  must be bound to the
pipeline via a descriptor set
</description></item><item><description>

If any <c>VkSampler</c> object that is accessed from a shader by the
<c>VkPipeline</c> currently bound to
<c>VK_PIPELINE_BIND_POINT_GRAPHICS</c> uses unnormalized coordinates, it
 must not be used to sample from any <c>VkImage</c> with a
<c>VkImageView</c> of the type <c>VK_IMAGE_VIEW_TYPE_3D</c>,
<c>VK_IMAGE_VIEW_TYPE_CUBE</c>, <c>VK_IMAGE_VIEW_TYPE_1D_ARRAY</c>,
<c>VK_IMAGE_VIEW_TYPE_2D_ARRAY</c> or
<c>VK_IMAGE_VIEW_TYPE_CUBE_ARRAY</c>, in any shader stage
</description></item><item><description>

If any <c>VkSampler</c> object that is accessed from a shader by the
<c>VkPipeline</c> currently bound to
<c>VK_PIPELINE_BIND_POINT_GRAPHICS</c> uses unnormalized coordinates, it
 must not be used with any of the SPIR-V <c>OpImageSample*</c> or
<c>OpImageSparseSample*</c> instructions with <c>ImplicitLod</c>, <c>Dref</c> or
<c>Proj</c> in their name, in any shader stage
</description></item><item><description>

If any <c>VkSampler</c> object that is accessed from a shader by the
<c>VkPipeline</c> currently bound to
<c>VK_PIPELINE_BIND_POINT_GRAPHICS</c> uses unnormalized coordinates, it
 must not be used with any of the SPIR-V <c>OpImageSample*</c> or
<c>OpImageSparseSample*</c> instructions that includes a LOD bias or any
offset values, in any shader stage
</description></item><item><description>

If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-robustBufferAccess">robust buffer access</a>
feature is not enabled, and any shader stage in the <c>VkPipeline</c>
object currently bound to <c>VK_PIPELINE_BIND_POINT_GRAPHICS</c> accesses
a uniform buffer, it  must not access values outside of the range of
that buffer specified in the currently bound descriptor set
</description></item><item><description>

If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-robustBufferAccess">robust buffer access</a>
feature is not enabled, and any shader stage in the <c>VkPipeline</c>
object currently bound to <c>VK_PIPELINE_BIND_POINT_GRAPHICS</c> accesses
a storage buffer, it  must not access values outside of the range of
that buffer specified in the currently bound descriptor set
</description></item><item><description>

Any <c>VkImageView</c> being sampled with <c>VK_FILTER_LINEAR</c> as a
result of this command  must be of a format which supports linear
filtering, as specified by the
<c>VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT</c> flag in
<c>VkFormatProperties</c>::<c>linearTilingFeatures</c> (for a linear
image) or <c>VkFormatProperties</c>::<c>optimalTilingFeatures</c>(for an
optimally tiled image) returned by
<c>vkGetPhysicalDeviceFormatProperties</c>
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>commandBuffer</c> must be a valid <c>VkCommandBuffer</c> handle
</description></item><item><description>
<c>buffer</c> must be a valid <c>VkBuffer</c> handle
</description></item><item><description>
<c>commandBuffer</c> must be in the  recording state
</description></item><item><description>
 The <c>VkCommandPool</c> that <c>commandBuffer</c> was allocated from  must support graphics operations
</description></item><item><description>
 This command  must only be called inside of a render pass instance
</description></item><item><description>
 Both of <c>buffer</c>, and <c>commandBuffer</c> must have been created, allocated, or retrieved from the same <c>VkDevice</c>
</description></item></list>




Host Synchronization
<list type="bullet"><item><description>
Host access to <c>commandBuffer</c> must  be externally synchronized
</description></item><item><description>
Host access to the <c>VkCommandPool</c> that <c>commandBuffer</c> was allocated from  must be externally synchronized
</description></item></list>




Command Properties
<list type="table">       <listheader><tr><term> Command Buffer Levels </term><term> Render Pass Scope </term><term> Supported Queue Types </term><term> Pipeline Type </term></tr></listheader>
<item><term>
Primary<br />
Secondary
</term><term>
Inside
</term><term>
Graphics
</term><term>
Graphics
</term></item>
</list>



To record an indexed indirect draw, call:


<code> void vkCmdDrawIndexedIndirect(
    VkCommandBuffer                             commandBuffer,
    VkBuffer                                    buffer,
    VkDeviceSize                                offset,
    uint32_t                                    drawCount,
    uint32_t                                    stride); </code>

</remarks>
      <seealso cref="T:VkBuffer" />
      <seealso cref="T:VkCommandBuffer" />
    </member>
    <member name="T:IVkCommandPoolCreateInfo">
      <summary>Structure specifying parameters of a newly created command pool</summary>
      <remarks>


Valid Usage
<list type="bullet"><item><description>
<c>queueFamilyIndex</c> must be the index of a queue family available in
the calling command&amp;#8217;s <c>device</c> parameter
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>sType</c> must be <c>VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO</c>
</description></item><item><description>
<c>pNext</c> must be <c>NULL</c>
</description></item><item><description>
<c>flags</c> must be a valid combination of <see cref="T:VkCommandPoolCreateFlags" /> values
</description></item></list>




The <c>VkCommandPoolCreateInfo</c> structure is defined as:


<code> typedef struct VkCommandPoolCreateInfo {
    VkStructureType             sType;
    const void*                 pNext;
    VkCommandPoolCreateFlags    flags;
    uint32_t                    queueFamilyIndex;
} VkCommandPoolCreateInfo; </code>

</remarks>
      <seealso cref="T:VkCommandPoolCreateFlags" />
      <seealso cref="T:VkStructureType" />
      <seealso cref="T:vkCreateCommandPool" />
    </member>
    <member name="T:VkCommandPoolCreateInfo32">
      <summary>See: <see cref="T:IVkCommandPoolCreateInfo" /></summary>
      <seealso cref="T:IVkCommandPoolCreateInfo" />
    </member>
    <member name="T:VkCommandPoolCreateInfo64">
      <summary>See: <see cref="T:IVkCommandPoolCreateInfo" /></summary>
      <seealso cref="T:IVkCommandPoolCreateInfo" />
    </member>
    <member name="T:vkCmdResetQueryPool">
      <summary>Reset queries in a query pool</summary>
      <remarks>

When executed on a queue, this command sets the status of query indices
 [<c>firstQuery</c>, <c>firstQuery</c> +  <c>queryCount</c> - 1] to
unavailable.



Valid Usage
<list type="bullet"><item><description>
<c>firstQuery</c> must be less than the number of queries in
<c>queryPool</c>
</description></item><item><description>

The sum of <c>firstQuery</c> and <c>queryCount</c> must be less than or
equal to the number of queries in <c>queryPool</c>
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>commandBuffer</c> must be a valid <c>VkCommandBuffer</c> handle
</description></item><item><description>
<c>queryPool</c> must be a valid <c>VkQueryPool</c> handle
</description></item><item><description>
<c>commandBuffer</c> must be in the  recording state
</description></item><item><description>
 The <c>VkCommandPool</c> that <c>commandBuffer</c> was allocated from  must support graphics, or compute operations
</description></item><item><description>
 This command  must only be called outside of a render pass instance
</description></item><item><description>
 Both of <c>commandBuffer</c>, and <c>queryPool</c> must have been created, allocated, or retrieved from the same <c>VkDevice</c>
</description></item></list>




Host Synchronization
<list type="bullet"><item><description>
Host access to <c>commandBuffer</c> must  be externally synchronized
</description></item><item><description>
Host access to the <c>VkCommandPool</c> that <c>commandBuffer</c> was allocated from  must be externally synchronized
</description></item></list>




Command Properties
<list type="table">       <listheader><tr><term> Command Buffer Levels </term><term> Render Pass Scope </term><term> Supported Queue Types </term><term> Pipeline Type </term></tr></listheader>
<item><term>
Primary<br />
Secondary
</term><term>
Outside
</term><term>
Graphics<br />
compute
</term><term></term></item>
</list>



To reset a range of queries in a query pool, call:


<code> void vkCmdResetQueryPool(
    VkCommandBuffer                             commandBuffer,
    VkQueryPool                                 queryPool,
    uint32_t                                    firstQuery,
    uint32_t                                    queryCount); </code>

</remarks>
      <seealso cref="T:VkCommandBuffer" />
      <seealso cref="T:VkQueryPool" />
    </member>
    <member name="T:IVkDedicatedAllocationBufferCreateInfoNV" />
    <member name="T:VkDedicatedAllocationBufferCreateInfoNV32">
      <summary>See: <see cref="T:IVkDedicatedAllocationBufferCreateInfoNV" /></summary>
      <seealso cref="T:IVkDedicatedAllocationBufferCreateInfoNV" />
    </member>
    <member name="T:VkDedicatedAllocationBufferCreateInfoNV64">
      <summary>See: <see cref="T:IVkDedicatedAllocationBufferCreateInfoNV" /></summary>
      <seealso cref="T:IVkDedicatedAllocationBufferCreateInfoNV" />
    </member>
    <member name="T:vkBindBufferMemory2KHX" />
    <member name="T:vkGetDeviceGroupSurfacePresentModesKHX" />
    <member name="T:IVkPipelineLayoutCreateInfo">
      <summary>Structure specifying the parameters of a newly created pipeline layout object</summary>
      <remarks>


Valid Usage
<list type="bullet"><item><description>
<c>setLayoutCount</c> must be less than or equal to
<c>VkPhysicalDeviceLimits</c>::<c>maxBoundDescriptorSets</c>
</description></item><item><description>

The total number of descriptors of the type
<c>VK_DESCRIPTOR_TYPE_SAMPLER</c> and
<c>VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER</c> accessible to any given
shader stage across all elements of <c>pSetLayouts</c> must be less than
or equal to
<c>VkPhysicalDeviceLimits</c>::<c>maxPerStageDescriptorSamplers</c>
</description></item><item><description>

The total number of descriptors of the type
<c>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER</c> and
<c>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC</c> accessible to any given
shader stage across all elements of <c>pSetLayouts</c> must be less than
or equal to
<c>VkPhysicalDeviceLimits</c>::<c>maxPerStageDescriptorUniformBuffers</c>
</description></item><item><description>

The total number of descriptors of the type
<c>VK_DESCRIPTOR_TYPE_STORAGE_BUFFER</c> and
<c>VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC</c> accessible to any given
shader stage across all elements of <c>pSetLayouts</c> must be less than
or equal to
<c>VkPhysicalDeviceLimits</c>::<c>maxPerStageDescriptorStorageBuffers</c>
</description></item><item><description>

The total number of descriptors of the type
<c>VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER</c>,
<c>VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE</c>, and
<c>VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER</c> accessible to any given
shader stage across all elements of <c>pSetLayouts</c> must be less than
or equal to
<c>VkPhysicalDeviceLimits</c>::<c>maxPerStageDescriptorSampledImages</c>
</description></item><item><description>

The total number of descriptors of the type
<c>VK_DESCRIPTOR_TYPE_STORAGE_IMAGE</c>, and
<c>VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER</c> accessible to any given
shader stage across all elements of <c>pSetLayouts</c> must be less than
or equal to
<c>VkPhysicalDeviceLimits</c>::<c>maxPerStageDescriptorStorageImages</c>
</description></item><item><description>

Any two elements of <c>pPushConstantRanges</c> must not include the same
stage in <c>stageFlags</c>
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>sType</c> must be <c>VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO</c>
</description></item><item><description>
<c>pNext</c> must be <c>NULL</c>
</description></item><item><description>
<c>flags</c> must be <c>0</c>
</description></item><item><description>
 If <c>setLayoutCount</c> is not <c>0</c>, <c>pSetLayouts</c> must be a pointer to an array of <c>setLayoutCount</c> valid <c>VkDescriptorSetLayout</c> handles
</description></item><item><description>
 If <c>pushConstantRangeCount</c> is not <c>0</c>, <c>pPushConstantRanges</c> must be a pointer to an array of <c>pushConstantRangeCount</c> valid <c>VkPushConstantRange</c> structures
</description></item></list>




The <see cref="T:IVkPipelineLayoutCreateInfo" /> structure is defined as:


<code> typedef struct VkPipelineLayoutCreateInfo {
    VkStructureType                 sType;
    const void*                     pNext;
    VkPipelineLayoutCreateFlags     flags;
    uint32_t                        setLayoutCount;
    const VkDescriptorSetLayout*    pSetLayouts;
    uint32_t                        pushConstantRangeCount;
    const VkPushConstantRange*      pPushConstantRanges;
} VkPipelineLayoutCreateInfo; </code>

</remarks>
      <seealso cref="T:VkDescriptorSetLayout" />
      <seealso cref="T:VkPipelineLayoutCreateFlags" />
      <seealso cref="T:VkPushConstantRange" />
      <seealso cref="T:VkStructureType" />
      <seealso cref="T:vkCreatePipelineLayout" />
    </member>
    <member name="T:VkPipelineLayoutCreateInfo32">
      <summary>See: <see cref="T:IVkPipelineLayoutCreateInfo" /></summary>
      <seealso cref="T:IVkPipelineLayoutCreateInfo" />
    </member>
    <member name="T:VkPipelineLayoutCreateInfo64">
      <summary>See: <see cref="T:IVkPipelineLayoutCreateInfo" /></summary>
      <seealso cref="T:IVkPipelineLayoutCreateInfo" />
    </member>
    <member name="T:IVkPhysicalDeviceMultiviewPropertiesKHX" />
    <member name="T:VkPhysicalDeviceMultiviewPropertiesKHX32">
      <summary>See: <see cref="T:IVkPhysicalDeviceMultiviewPropertiesKHX" /></summary>
      <seealso cref="T:IVkPhysicalDeviceMultiviewPropertiesKHX" />
    </member>
    <member name="T:VkPhysicalDeviceMultiviewPropertiesKHX64">
      <summary>See: <see cref="T:IVkPhysicalDeviceMultiviewPropertiesKHX" /></summary>
      <seealso cref="T:IVkPhysicalDeviceMultiviewPropertiesKHX" />
    </member>
    <member name="T:IVkPipelineDepthStencilStateCreateInfo">
      <summary>Structure specifying parameters of a newly created pipeline depth stencil state</summary>
      <remarks>


Valid Usage
<list type="bullet"><item><description>

If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-depthBounds">depth bounds testing</a> feature is
not enabled, <c>depthBoundsTestEnable</c> must be <c>VK_FALSE</c>
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>sType</c> must be <c>VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO</c>
</description></item><item><description>
<c>pNext</c> must be <c>NULL</c>
</description></item><item><description>
<c>flags</c> must be <c>0</c>
</description></item><item><description>
<c>depthCompareOp</c> must be a valid <see cref="T:VkCompareOp" /> value
</description></item><item><description>
<c>front</c> must be a valid <c>VkStencilOpState</c> structure
</description></item><item><description>
<c>back</c> must be a valid <c>VkStencilOpState</c> structure
</description></item></list>




The <c>VkPipelineDepthStencilStateCreateInfo</c> structure is defined as:


<code> typedef struct VkPipelineDepthStencilStateCreateInfo {
    VkStructureType                           sType;
    const void*                               pNext;
    VkPipelineDepthStencilStateCreateFlags    flags;
    VkBool32                                  depthTestEnable;
    VkBool32                                  depthWriteEnable;
    VkCompareOp                               depthCompareOp;
    VkBool32                                  depthBoundsTestEnable;
    VkBool32                                  stencilTestEnable;
    VkStencilOpState                          front;
    VkStencilOpState                          back;
    float                                     minDepthBounds;
    float                                     maxDepthBounds;
} VkPipelineDepthStencilStateCreateInfo; </code>

</remarks>
      <seealso cref="T:VkCompareOp" />
      <seealso cref="T:IVkGraphicsPipelineCreateInfo" />
      <seealso cref="T:VkPipelineDepthStencilStateCreateFlags" />
      <seealso cref="T:VkStencilOpState" />
      <seealso cref="T:VkStructureType" />
    </member>
    <member name="T:VkPipelineDepthStencilStateCreateInfo32">
      <summary>See: <see cref="T:IVkPipelineDepthStencilStateCreateInfo" /></summary>
      <seealso cref="T:IVkPipelineDepthStencilStateCreateInfo" />
    </member>
    <member name="T:VkPipelineDepthStencilStateCreateInfo64">
      <summary>See: <see cref="T:IVkPipelineDepthStencilStateCreateInfo" /></summary>
      <seealso cref="T:IVkPipelineDepthStencilStateCreateInfo" />
    </member>
    <member name="T:IVkPipelineTessellationStateCreateInfo">
      <summary>Structure specifying parameters of a newly created pipeline tessellation state</summary>
      <remarks>


Valid Usage
<list type="bullet"><item><description>
<c>patchControlPoints</c> must be greater than zero and less than or
equal to <c>VkPhysicalDeviceLimits</c>::<c>maxTessellationPatchSize</c>
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>sType</c> must be <c>VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO</c>
</description></item><item><description>
<c>pNext</c> must be <c>NULL</c>
</description></item><item><description>
<c>flags</c> must be <c>0</c>
</description></item></list>




The <c>VkPipelineTessellationStateCreateInfo</c> structure is defined as:


<code> typedef struct VkPipelineTessellationStateCreateInfo {
    VkStructureType                           sType;
    const void*                               pNext;
    VkPipelineTessellationStateCreateFlags    flags;
    uint32_t                                  patchControlPoints;
} VkPipelineTessellationStateCreateInfo; </code>

</remarks>
      <seealso cref="T:IVkGraphicsPipelineCreateInfo" />
      <seealso cref="T:VkPipelineTessellationStateCreateFlags" />
      <seealso cref="T:VkStructureType" />
    </member>
    <member name="T:VkPipelineTessellationStateCreateInfo32">
      <summary>See: <see cref="T:IVkPipelineTessellationStateCreateInfo" /></summary>
      <seealso cref="T:IVkPipelineTessellationStateCreateInfo" />
    </member>
    <member name="T:VkPipelineTessellationStateCreateInfo64">
      <summary>See: <see cref="T:IVkPipelineTessellationStateCreateInfo" /></summary>
      <seealso cref="T:IVkPipelineTessellationStateCreateInfo" />
    </member>
    <member name="T:vkGetImageSparseMemoryRequirements">
      <summary>Query the memory requirements for a sparse image</summary>
      <remarks>

If <c>pSparseMemoryRequirements</c> is <c>NULL</c>, then the number of sparse
memory requirements available is returned in
<c>pSparseMemoryRequirementCount</c>.
Otherwise, <c>pSparseMemoryRequirementCount</c> must point to a variable set
by the user to the number of elements in the <c>pSparseMemoryRequirements</c>
array, and on return the variable is overwritten with the number of
structures actually written to <c>pSparseMemoryRequirements</c>.
If <c>pSparseMemoryRequirementCount</c> is less than the number of sparse
memory requirements available, at most <c>pSparseMemoryRequirementCount</c>
structures will be written.


If the image was not created with <c>VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT</c>
then <c>pSparseMemoryRequirementCount</c> will be set to zero and
<c>pSparseMemoryRequirements</c> will not be written to.

<list type="table"><tr><td><i title="Note"></i></td><td>
Note

It is legal for an implementation to report a larger value in
<c>VkMemoryRequirements</c>::<c>size</c> than would be obtained by adding
together memory sizes for all <c>VkSparseImageMemoryRequirements</c> returned
by <c>vkGetImageSparseMemoryRequirements</c>.
This  may occur when the hardware requires unused padding in the address
range describing the resource.

</td></tr></list>


Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>device</c> must be a valid <c>VkDevice</c> handle
</description></item><item><description>
<c>image</c> must be a valid <c>VkImage</c> handle
</description></item><item><description>
<c>pSparseMemoryRequirementCount</c> must be a pointer to a <c>uint32_t</c> value
</description></item><item><description>
 If the value referenced by <c>pSparseMemoryRequirementCount</c> is not <c>0</c>, and <c>pSparseMemoryRequirements</c> is not <c>NULL</c>, <c>pSparseMemoryRequirements</c> must be a pointer to an array of <c>pSparseMemoryRequirementCount</c><c>VkSparseImageMemoryRequirements</c> structures
</description></item><item><description>
<c>image</c> must have been created, allocated, or retrieved from <c>device</c>
</description></item></list>




To query sparse memory requirements for an image, call:


<code> void vkGetImageSparseMemoryRequirements(
    VkDevice                                    device,
    VkImage                                     image,
    uint32_t*                                   pSparseMemoryRequirementCount,
    VkSparseImageMemoryRequirements*            pSparseMemoryRequirements); </code>

</remarks>
      <seealso cref="T:VkDevice" />
      <seealso cref="T:VkImage" />
      <seealso cref="T:VkSparseImageMemoryRequirements" />
    </member>
    <member name="T:VkCommandBuffer">
      <summary>Opaque handle to a command buffer object</summary>
      <remarks>

Command buffers are objects used to record commands which  can be
subsequently submitted to a device queue for execution.
There are two levels of command buffers -  primary command buffers, which
 can execute secondary command buffers, and which are submitted to queues,
and  secondary command buffers, which  can be executed by primary command
buffers, and which are not directly submitted to queues.


Command buffers are represented by <c>VkCommandBuffer</c> handles:


<code> VK_DEFINE_HANDLE(VkCommandBuffer) </code>

</remarks>
      <seealso cref="T:IVkSubmitInfo" />
      <seealso cref="T:vkAllocateCommandBuffers" />
      <seealso cref="T:vkBeginCommandBuffer" />
      <seealso cref="T:vkCmdBeginQuery" />
      <seealso cref="T:vkCmdBeginRenderPass" />
      <seealso cref="T:vkCmdBindDescriptorSets" />
      <seealso cref="T:vkCmdBindIndexBuffer" />
      <seealso cref="T:vkCmdBindPipeline" />
      <seealso cref="T:vkCmdBindVertexBuffers" />
      <seealso cref="T:vkCmdBlitImage" />
      <seealso cref="T:vkCmdClearAttachments" />
      <seealso cref="T:vkCmdClearColorImage" />
      <seealso cref="T:vkCmdClearDepthStencilImage" />
      <seealso cref="T:vkCmdCopyBuffer" />
      <seealso cref="T:vkCmdCopyBufferToImage" />
      <seealso cref="T:vkCmdCopyImage" />
      <seealso cref="T:vkCmdCopyImageToBuffer" />
      <seealso cref="T:vkCmdCopyQueryPoolResults" />
      <seealso cref="T:vkCmdDispatch" />
      <seealso cref="T:vkCmdDispatchIndirect" />
      <seealso cref="T:vkCmdDraw" />
      <seealso cref="T:vkCmdDrawIndexed" />
      <seealso cref="T:vkCmdDrawIndexedIndirect" />
      <seealso cref="T:vkCmdDrawIndirect" />
      <seealso cref="T:vkCmdEndQuery" />
      <seealso cref="T:vkCmdEndRenderPass" />
      <seealso cref="T:vkCmdExecuteCommands" />
      <seealso cref="T:vkCmdFillBuffer" />
      <seealso cref="T:vkCmdNextSubpass" />
      <seealso cref="T:vkCmdPipelineBarrier" />
      <seealso cref="T:vkCmdPushConstants" />
      <seealso cref="T:vkCmdResetEvent" />
      <seealso cref="T:vkCmdResetQueryPool" />
      <seealso cref="T:vkCmdResolveImage" />
      <seealso cref="T:vkCmdSetBlendConstants" />
      <seealso cref="T:vkCmdSetDepthBias" />
      <seealso cref="T:vkCmdSetDepthBounds" />
      <seealso cref="T:vkCmdSetEvent" />
      <seealso cref="T:vkCmdSetLineWidth" />
      <seealso cref="T:vkCmdSetScissor" />
      <seealso cref="T:vkCmdSetStencilCompareMask" />
      <seealso cref="T:vkCmdSetStencilReference" />
      <seealso cref="T:vkCmdSetStencilWriteMask" />
      <seealso cref="T:vkCmdSetViewport" />
      <seealso cref="T:vkCmdUpdateBuffer" />
      <seealso cref="T:vkCmdWaitEvents" />
      <seealso cref="T:vkCmdWriteTimestamp" />
      <seealso cref="T:vkEndCommandBuffer" />
      <seealso cref="T:vkFreeCommandBuffers" />
      <seealso cref="T:vkResetCommandBuffer" />
    </member>
    <member name="T:vkDestroyDescriptorPool">
      <summary>Destroy a descriptor pool object</summary>
      <remarks>

When a pool is destroyed, all descriptor sets allocated from the pool are
implicitly freed and become invalid.
Descriptor sets allocated from a given pool do not need to be freed before
destroying that descriptor pool.



Valid Usage
<list type="bullet"><item><description>

All submitted commands that refer to <c>descriptorPool</c> (via any
allocated descriptor sets)  must have completed execution
</description></item><item><description>

If <c>VkAllocationCallbacks</c> were provided when <c>descriptorPool</c>
was created, a compatible set of callbacks  must be provided here
</description></item><item><description>

If no <c>VkAllocationCallbacks</c> were provided when
<c>descriptorPool</c> was created, <c>pAllocator</c> must be <c>NULL</c>
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>device</c> must be a valid <c>VkDevice</c> handle
</description></item><item><description>
 If <c>descriptorPool</c> is not <see cref="!:VK_NULL_HANDLE" />, <c>descriptorPool</c> must be a valid <c>VkDescriptorPool</c> handle
</description></item><item><description>
 If <c>pAllocator</c> is not <c>NULL</c>, <c>pAllocator</c> must be a pointer to a valid <c>VkAllocationCallbacks</c> structure
</description></item><item><description>
 If <c>descriptorPool</c> is a valid handle, it  must have been created, allocated, or retrieved from <c>device</c>
</description></item></list>




Host Synchronization
<list type="bullet"><item><description>
Host access to <c>descriptorPool</c> must  be externally synchronized
</description></item></list>




To destroy a descriptor pool, call:


<code> void vkDestroyDescriptorPool(
    VkDevice                                    device,
    VkDescriptorPool                            descriptorPool,
    const VkAllocationCallbacks*                pAllocator); </code>

</remarks>
      <seealso cref="T:IVkAllocationCallbacks" />
      <seealso cref="T:VkDescriptorPool" />
      <seealso cref="T:VkDevice" />
    </member>
    <member name="T:vkAllocateDescriptorSets">
      <summary>Allocate one or more descriptor sets</summary>
      <remarks>

The allocated descriptor sets are returned in <c>pDescriptorSets</c>.


When a descriptor set is allocated, the initial state is largely
uninitialized and all descriptors are undefined.
However, the descriptor set  can be bound in a command buffer without
causing errors or exceptions.
All entries that are statically used by a pipeline in a drawing or
dispatching command  must have been populated before the descriptor set is
bound for use by that command.
Entries that are not statically used by a pipeline  can have uninitialized
descriptors or descriptors of resources that have been destroyed, and
executing a draw or dispatch with such a descriptor set bound does not cause
undefined behavior.
This means applications need not populate unused entries with dummy
descriptors.


If an allocation fails due to fragmentation, an indeterminate error is
returned with an unspecified error code.
Any returned error other than
<c>VK_ERROR_FRAGMENTED_POOL</c> does not imply its usual meaning:
applications  should assume that the allocation failed due to fragmentation,
and create a new descriptor pool.

<list type="table"><tr><td><i title="Note"></i></td><td>
Note

Applications  should check for a negative return value when allocating new
descriptor sets, assume that any error
effectively means <c>VK_ERROR_FRAGMENTED_POOL</c>, and try to create a new
descriptor pool.
If <c>VK_ERROR_FRAGMENTED_POOL</c> is the actual return value, it adds
certainty to that decision.


The reason for this is that <c>VK_ERROR_FRAGMENTED_POOL</c> was only added in
a later revision of the 1.0 specification, and so drivers  may return other
errors if they were written against earlier revisions.
To ensure full compatibility with earlier patch revisions, these other
errors are allowed.

</td></tr></list>


Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>device</c> must be a valid <c>VkDevice</c> handle
</description></item><item><description>
<c>pAllocateInfo</c> must be a pointer to a valid <c>VkDescriptorSetAllocateInfo</c> structure
</description></item><item><description>
<c>pDescriptorSets</c> must be a pointer to an array of <c>pAllocateInfo</c>::descriptorSetCount <c>VkDescriptorSet</c> handles
</description></item></list>




Host Synchronization
<list type="bullet"><item><description>
Host access to <c>pAllocateInfo</c>::descriptorPool  must be externally synchronized
</description></item></list>




Return Codes
<dl><dt>On success, this command returns</dt><dd>
<list type="bullet"><item><description>
<c>VK_SUCCESS</c>
</description></item></list>
</dd><dt>On failure, this command returns</dt><dd>
<list type="bullet"><item><description>
<c>VK_ERROR_OUT_OF_HOST_MEMORY</c>
</description></item><item><description>
<c>VK_ERROR_OUT_OF_DEVICE_MEMORY</c>
</description></item><item><description>
<c>VK_ERROR_FRAGMENTED_POOL</c>
</description></item></list>
</dd></dl>




To allocate descriptor sets from a descriptor pool, call:


<code> VkResult vkAllocateDescriptorSets(
    VkDevice                                    device,
    const VkDescriptorSetAllocateInfo*          pAllocateInfo,
    VkDescriptorSet*                            pDescriptorSets); </code>

</remarks>
      <seealso cref="T:VkDescriptorSet" />
      <seealso cref="T:IVkDescriptorSetAllocateInfo" />
      <seealso cref="T:VkDevice" />
    </member>
    <member name="T:vkCmdCopyBufferToImage">
      <summary>Copy data from a buffer into an image</summary>
      <remarks>

Each region in <c>pRegions</c> is copied from the specified region of the
source buffer to the specified region of the destination image.



Valid Usage
<list type="bullet"><item><description>

The buffer region specified by a given element of <c>pRegions</c> must
be a region that is contained within <c>srcBuffer</c>
</description></item><item><description>

The image region specified by a given element of <c>pRegions</c> must be
a region that is contained within <c>dstImage</c>
</description></item><item><description>

The union of all source regions, and the union of all destination
regions, specified by the elements of <c>pRegions</c>,  must not overlap
in memory
</description></item><item><description>
<c>srcBuffer</c> must have been created with
<c>VK_BUFFER_USAGE_TRANSFER_SRC_BIT</c> usage flag
</description></item><item><description>

If <c>srcBuffer</c> is non-sparse then it  must be bound completely and
contiguously to a single <c>VkDeviceMemory</c> object
</description></item><item><description>
<c>dstImage</c> must have been created with
<c>VK_IMAGE_USAGE_TRANSFER_DST_BIT</c> usage flag
</description></item><item><description>

If <c>dstImage</c> is non-sparse then it  must be bound completely and
contiguously to a single <c>VkDeviceMemory</c> object
</description></item><item><description>
<c>dstImage</c> must have a sample count equal to
<c>VK_SAMPLE_COUNT_1_BIT</c>
</description></item><item><description>
<c>dstImageLayout</c> must specify the layout of the image subresources
of <c>dstImage</c> specified in <c>pRegions</c> at the time this command
is executed on a <c>VkDevice</c>
</description></item><item><description>
<c>dstImageLayout</c> must be <c>VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL</c>
or <c>VK_IMAGE_LAYOUT_GENERAL</c>
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>commandBuffer</c> must be a valid <c>VkCommandBuffer</c> handle
</description></item><item><description>
<c>srcBuffer</c> must be a valid <c>VkBuffer</c> handle
</description></item><item><description>
<c>dstImage</c> must be a valid <c>VkImage</c> handle
</description></item><item><description>
<c>dstImageLayout</c> must be a valid <see cref="T:VkImageLayout" /> value
</description></item><item><description>
<c>pRegions</c> must be a pointer to an array of <c>regionCount</c> valid <c>VkBufferImageCopy</c> structures
</description></item><item><description>
<c>commandBuffer</c> must be in the  recording state
</description></item><item><description>
 The <c>VkCommandPool</c> that <c>commandBuffer</c> was allocated from  must support transfer, graphics, or compute operations
</description></item><item><description>
 This command  must only be called outside of a render pass instance
</description></item><item><description>
<c>regionCount</c> must be greater than <c>0</c>
</description></item><item><description>
 Each of <c>commandBuffer</c>, <c>dstImage</c>, and <c>srcBuffer</c> must have been created, allocated, or retrieved from the same <c>VkDevice</c>
</description></item></list>




Host Synchronization
<list type="bullet"><item><description>
Host access to <c>commandBuffer</c> must  be externally synchronized
</description></item><item><description>
Host access to the <c>VkCommandPool</c> that <c>commandBuffer</c> was allocated from  must be externally synchronized
</description></item></list>




Command Properties
<list type="table">       <listheader><tr><term> Command Buffer Levels </term><term> Render Pass Scope </term><term> Supported Queue Types </term><term> Pipeline Type </term></tr></listheader>
<item><term>
Primary<br />
Secondary
</term><term>
Outside
</term><term>
Transfer<br />
graphics<br />
compute
</term><term>
Transfer
</term></item>
</list>



To copy data from a buffer object to an image object, call:


<code> void vkCmdCopyBufferToImage(
    VkCommandBuffer                             commandBuffer,
    VkBuffer                                    srcBuffer,
    VkImage                                     dstImage,
    VkImageLayout                               dstImageLayout,
    uint32_t                                    regionCount,
    const VkBufferImageCopy*                    pRegions); </code>

</remarks>
      <seealso cref="T:VkBuffer" />
      <seealso cref="T:VkBufferImageCopy" />
      <seealso cref="T:VkCommandBuffer" />
      <seealso cref="T:VkImage" />
      <seealso cref="T:VkImageLayout" />
    </member>
    <member name="T:vkGetPhysicalDeviceFormatProperties2KHR" />
    <member name="T:vkQueueWaitIdle">
      <summary>Wait for a queue to become idle</summary>
      <remarks>

<c>vkQueueWaitIdle</c> is equivalent to submitting a fence to a queue and
waiting with an infinite timeout for that fence to signal.



Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>queue</c> must be a valid <c>VkQueue</c> handle
</description></item></list>




Command Properties
<list type="table">       <listheader><tr><term> Command Buffer Levels </term><term> Render Pass Scope </term><term> Supported Queue Types </term><term> Pipeline Type </term></tr></listheader>
<item><term>
-
</term><term>
-
</term><term>
Any
</term><term>
-
</term></item>
</list>



Return Codes
<dl><dt>On success, this command returns</dt><dd>
<list type="bullet"><item><description>
<c>VK_SUCCESS</c>
</description></item></list>
</dd><dt>On failure, this command returns</dt><dd>
<list type="bullet"><item><description>
<c>VK_ERROR_OUT_OF_HOST_MEMORY</c>
</description></item><item><description>
<c>VK_ERROR_OUT_OF_DEVICE_MEMORY</c>
</description></item><item><description>
<c>VK_ERROR_DEVICE_LOST</c>
</description></item></list>
</dd></dl>




To wait on the host for the completion of outstanding queue operations for a
given queue, call:


<code> VkResult vkQueueWaitIdle(
    VkQueue                                     queue); </code>

</remarks>
      <seealso cref="T:VkQueue" />
    </member>
    <member name="T:vkCreateImageView">
      <summary>Create an image view from an existing image</summary>
      <remarks>

Some of the image creation parameters are inherited by the view.
The remaining parameters are contained in the <c>pCreateInfo</c>.



Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>device</c> must be a valid <c>VkDevice</c> handle
</description></item><item><description>
<c>pCreateInfo</c> must be a pointer to a valid <c>VkImageViewCreateInfo</c> structure
</description></item><item><description>
 If <c>pAllocator</c> is not <c>NULL</c>, <c>pAllocator</c> must be a pointer to a valid <c>VkAllocationCallbacks</c> structure
</description></item><item><description>
<c>pView</c> must be a pointer to a <c>VkImageView</c> handle
</description></item></list>




Return Codes
<dl><dt>On success, this command returns</dt><dd>
<list type="bullet"><item><description>
<c>VK_SUCCESS</c>
</description></item></list>
</dd><dt>On failure, this command returns</dt><dd>
<list type="bullet"><item><description>
<c>VK_ERROR_OUT_OF_HOST_MEMORY</c>
</description></item><item><description>
<c>VK_ERROR_OUT_OF_DEVICE_MEMORY</c>
</description></item></list>
</dd></dl>




To create an image view, call:


<code> VkResult vkCreateImageView(
    VkDevice                                    device,
    const VkImageViewCreateInfo*                pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkImageView*                                pView); </code>

</remarks>
      <seealso cref="T:IVkAllocationCallbacks" />
      <seealso cref="T:VkDevice" />
      <seealso cref="T:VkImageView" />
      <seealso cref="T:IVkImageViewCreateInfo" />
    </member>
    <member name="T:IVkPhysicalDeviceExternalSemaphoreInfoKHX" />
    <member name="T:VkPhysicalDeviceExternalSemaphoreInfoKHX32">
      <summary>See: <see cref="T:IVkPhysicalDeviceExternalSemaphoreInfoKHX" /></summary>
      <seealso cref="T:IVkPhysicalDeviceExternalSemaphoreInfoKHX" />
    </member>
    <member name="T:VkPhysicalDeviceExternalSemaphoreInfoKHX64">
      <summary>See: <see cref="T:IVkPhysicalDeviceExternalSemaphoreInfoKHX" /></summary>
      <seealso cref="T:IVkPhysicalDeviceExternalSemaphoreInfoKHX" />
    </member>
    <member name="T:vkCreateDescriptorSetLayout">
      <summary>Create a new descriptor set layout</summary>
      <remarks>


Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>device</c> must be a valid <c>VkDevice</c> handle
</description></item><item><description>
<c>pCreateInfo</c> must be a pointer to a valid <c>VkDescriptorSetLayoutCreateInfo</c> structure
</description></item><item><description>
 If <c>pAllocator</c> is not <c>NULL</c>, <c>pAllocator</c> must be a pointer to a valid <c>VkAllocationCallbacks</c> structure
</description></item><item><description>
<c>pSetLayout</c> must be a pointer to a <c>VkDescriptorSetLayout</c> handle
</description></item></list>




Return Codes
<dl><dt>On success, this command returns</dt><dd>
<list type="bullet"><item><description>
<c>VK_SUCCESS</c>
</description></item></list>
</dd><dt>On failure, this command returns</dt><dd>
<list type="bullet"><item><description>
<c>VK_ERROR_OUT_OF_HOST_MEMORY</c>
</description></item><item><description>
<c>VK_ERROR_OUT_OF_DEVICE_MEMORY</c>
</description></item></list>
</dd></dl>




To create descriptor set layout objects, call:


<code> VkResult vkCreateDescriptorSetLayout(
    VkDevice                                    device,
    const VkDescriptorSetLayoutCreateInfo*      pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkDescriptorSetLayout*                      pSetLayout); </code>

</remarks>
      <seealso cref="T:IVkAllocationCallbacks" />
      <seealso cref="T:VkDescriptorSetLayout" />
      <seealso cref="T:IVkDescriptorSetLayoutCreateInfo" />
      <seealso cref="T:VkDevice" />
    </member>
    <member name="T:IVkDeviceGeneratedCommandsFeaturesNVX" />
    <member name="T:VkDeviceGeneratedCommandsFeaturesNVX32">
      <summary>See: <see cref="T:IVkDeviceGeneratedCommandsFeaturesNVX" /></summary>
      <seealso cref="T:IVkDeviceGeneratedCommandsFeaturesNVX" />
    </member>
    <member name="T:VkDeviceGeneratedCommandsFeaturesNVX64">
      <summary>See: <see cref="T:IVkDeviceGeneratedCommandsFeaturesNVX" /></summary>
      <seealso cref="T:IVkDeviceGeneratedCommandsFeaturesNVX" />
    </member>
    <member name="T:IVkPipelineRasterizationStateRasterizationOrderAMD" />
    <member name="T:VkPipelineRasterizationStateRasterizationOrderAMD32">
      <summary>See: <see cref="T:IVkPipelineRasterizationStateRasterizationOrderAMD" /></summary>
      <seealso cref="T:IVkPipelineRasterizationStateRasterizationOrderAMD" />
    </member>
    <member name="T:VkPipelineRasterizationStateRasterizationOrderAMD64">
      <summary>See: <see cref="T:IVkPipelineRasterizationStateRasterizationOrderAMD" /></summary>
      <seealso cref="T:IVkPipelineRasterizationStateRasterizationOrderAMD" />
    </member>
    <member name="T:IVkPipelineCoverageModulationStateCreateInfoNV" />
    <member name="T:VkPipelineCoverageModulationStateCreateInfoNV32">
      <summary>See: <see cref="T:IVkPipelineCoverageModulationStateCreateInfoNV" /></summary>
      <seealso cref="T:IVkPipelineCoverageModulationStateCreateInfoNV" />
    </member>
    <member name="T:VkPipelineCoverageModulationStateCreateInfoNV64">
      <summary>See: <see cref="T:IVkPipelineCoverageModulationStateCreateInfoNV" /></summary>
      <seealso cref="T:IVkPipelineCoverageModulationStateCreateInfoNV" />
    </member>
    <member name="T:vkTrimCommandPoolKHR" />
    <member name="T:vkGetPhysicalDeviceSurfaceCapabilitiesKHR" />
    <member name="T:vkCmdClearColorImage">
      <summary>Clear regions of a color image</summary>
      <remarks>

Each specified range in <c>pRanges</c> is cleared to the value specified by
<c>pColor</c>.



Valid Usage
<list type="bullet"><item><description>
<c>image</c> must have been created with
<c>VK_IMAGE_USAGE_TRANSFER_DST_BIT</c> usage flag
</description></item><item><description>

If <c>image</c> is non-sparse then it  must be bound completely and
contiguously to a single <c>VkDeviceMemory</c> object
</description></item><item><description>
<c>imageLayout</c> must specify the layout of the image subresource
ranges of <c>image</c> specified in <c>pRanges</c> at the time this
command is executed on a <c>VkDevice</c>
</description></item><item><description>
<c>imageLayout</c> must be <c>VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL</c> or
<c>VK_IMAGE_LAYOUT_GENERAL</c>
</description></item><item><description>

The image range of any given element of <c>pRanges</c> must be an image
subresource range that is contained within <c>image</c>
</description></item><item><description>
<c>image</c> must  not have a compressed or depth/stencil format
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>commandBuffer</c> must be a valid <c>VkCommandBuffer</c> handle
</description></item><item><description>
<c>image</c> must be a valid <c>VkImage</c> handle
</description></item><item><description>
<c>imageLayout</c> must be a valid <see cref="T:VkImageLayout" /> value
</description></item><item><description>
<c>pColor</c> must be a pointer to a valid <c>VkClearColorValue</c> union
</description></item><item><description>
<c>pRanges</c> must be a pointer to an array of <c>rangeCount</c> valid <c>VkImageSubresourceRange</c> structures
</description></item><item><description>
<c>commandBuffer</c> must be in the  recording state
</description></item><item><description>
 The <c>VkCommandPool</c> that <c>commandBuffer</c> was allocated from  must support graphics, or compute operations
</description></item><item><description>
 This command  must only be called outside of a render pass instance
</description></item><item><description>
<c>rangeCount</c> must be greater than <c>0</c>
</description></item><item><description>
 Both of <c>commandBuffer</c>, and <c>image</c> must have been created, allocated, or retrieved from the same <c>VkDevice</c>
</description></item></list>




Host Synchronization
<list type="bullet"><item><description>
Host access to <c>commandBuffer</c> must  be externally synchronized
</description></item><item><description>
Host access to the <c>VkCommandPool</c> that <c>commandBuffer</c> was allocated from  must be externally synchronized
</description></item></list>




Command Properties
<list type="table">       <listheader><tr><term> Command Buffer Levels </term><term> Render Pass Scope </term><term> Supported Queue Types </term><term> Pipeline Type </term></tr></listheader>
<item><term>
Primary<br />
Secondary
</term><term>
Outside
</term><term>
Graphics<br />
compute
</term><term>
Transfer
</term></item>
</list>



To clear one or more subranges of a color image, call:


<code> void vkCmdClearColorImage(
    VkCommandBuffer                             commandBuffer,
    VkImage                                     image,
    VkImageLayout                               imageLayout,
    const VkClearColorValue*                    pColor,
    uint32_t                                    rangeCount,
    const VkImageSubresourceRange*              pRanges); </code>

</remarks>
      <seealso cref="T:VkClearColorValue" />
      <seealso cref="T:VkCommandBuffer" />
      <seealso cref="T:VkImage" />
      <seealso cref="T:VkImageLayout" />
      <seealso cref="T:VkImageSubresourceRange" />
    </member>
    <member name="T:vkGetPhysicalDeviceExternalSemaphorePropertiesKHX" />
    <member name="T:vkGetSemaphoreFdKHX" />
    <member name="T:vkCmdSetViewportWScalingNV" />
    <member name="T:VkDevice">
      <summary>Opaque handle to a device object</summary>
      <remarks>

Logical devices are represented by <c>VkDevice</c> handles:


<code> VK_DEFINE_HANDLE(VkDevice) </code>

</remarks>
      <seealso cref="T:vkAllocateCommandBuffers" />
      <seealso cref="T:vkAllocateDescriptorSets" />
      <seealso cref="T:vkAllocateMemory" />
      <seealso cref="T:vkBindBufferMemory" />
      <seealso cref="T:vkBindImageMemory" />
      <seealso cref="T:vkCreateBuffer" />
      <seealso cref="T:vkCreateBufferView" />
      <seealso cref="T:vkCreateCommandPool" />
      <seealso cref="T:vkCreateComputePipelines" />
      <seealso cref="T:vkCreateDescriptorPool" />
      <seealso cref="T:vkCreateDescriptorSetLayout" />
      <seealso cref="T:vkCreateDevice" />
      <seealso cref="T:vkCreateEvent" />
      <seealso cref="T:vkCreateFence" />
      <seealso cref="T:vkCreateFramebuffer" />
      <seealso cref="T:vkCreateGraphicsPipelines" />
      <seealso cref="T:vkCreateImage" />
      <seealso cref="T:vkCreateImageView" />
      <seealso cref="T:vkCreatePipelineCache" />
      <seealso cref="T:vkCreatePipelineLayout" />
      <seealso cref="T:vkCreateQueryPool" />
      <seealso cref="T:vkCreateRenderPass" />
      <seealso cref="T:vkCreateSampler" />
      <seealso cref="T:vkCreateSemaphore" />
      <seealso cref="T:vkCreateShaderModule" />
      <seealso cref="T:vkDestroyBuffer" />
      <seealso cref="T:vkDestroyBufferView" />
      <seealso cref="T:vkDestroyCommandPool" />
      <seealso cref="T:vkDestroyDescriptorPool" />
      <seealso cref="T:vkDestroyDescriptorSetLayout" />
      <seealso cref="T:vkDestroyDevice" />
      <seealso cref="T:vkDestroyEvent" />
      <seealso cref="T:vkDestroyFence" />
      <seealso cref="T:vkDestroyFramebuffer" />
      <seealso cref="T:vkDestroyImage" />
      <seealso cref="T:vkDestroyImageView" />
      <seealso cref="T:vkDestroyPipeline" />
      <seealso cref="T:vkDestroyPipelineCache" />
      <seealso cref="T:vkDestroyPipelineLayout" />
      <seealso cref="T:vkDestroyQueryPool" />
      <seealso cref="T:vkDestroyRenderPass" />
      <seealso cref="T:vkDestroySampler" />
      <seealso cref="T:vkDestroySemaphore" />
      <seealso cref="T:vkDestroyShaderModule" />
      <seealso cref="T:vkDeviceWaitIdle" />
      <seealso cref="T:vkFlushMappedMemoryRanges" />
      <seealso cref="T:vkFreeCommandBuffers" />
      <seealso cref="T:vkFreeDescriptorSets" />
      <seealso cref="T:vkFreeMemory" />
      <seealso cref="T:vkGetBufferMemoryRequirements" />
      <seealso cref="T:vkGetDeviceMemoryCommitment" />
      <seealso cref="T:vkGetDeviceProcAddr" />
      <seealso cref="T:vkGetDeviceQueue" />
      <seealso cref="T:vkGetEventStatus" />
      <seealso cref="T:vkGetFenceStatus" />
      <seealso cref="T:vkGetImageMemoryRequirements" />
      <seealso cref="T:vkGetImageSparseMemoryRequirements" />
      <seealso cref="T:vkGetImageSubresourceLayout" />
      <seealso cref="T:vkGetPipelineCacheData" />
      <seealso cref="T:vkGetQueryPoolResults" />
      <seealso cref="T:vkGetRenderAreaGranularity" />
      <seealso cref="T:vkInvalidateMappedMemoryRanges" />
      <seealso cref="T:vkMapMemory" />
      <seealso cref="T:vkMergePipelineCaches" />
      <seealso cref="T:vkResetCommandPool" />
      <seealso cref="T:vkResetDescriptorPool" />
      <seealso cref="T:vkResetEvent" />
      <seealso cref="T:vkResetFences" />
      <seealso cref="T:vkSetEvent" />
      <seealso cref="T:vkUnmapMemory" />
      <seealso cref="T:vkUpdateDescriptorSets" />
      <seealso cref="T:vkWaitForFences" />
    </member>
    <member name="T:vkCmdResetEvent">
      <summary>Reset an event object to non-signaled state</summary>
      <remarks>

When <see cref="T:vkCmdResetEvent" /> is submitted to a queue, it defines an execution
dependency on commands that were submitted before it, and defines an event
unsignal operation which resets the event to the unsignaled state.


The first <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-dependencies-scopes">synchronization scope</a>
includes every command previously submitted to the same queue, including
those in the same command buffer and batch.
The synchronization scope is limited to operations on the pipeline stages
determined by the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-pipeline-stages-masks">source stage
mask</a> specified by <c>stageMask</c>.


The second <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-dependencies-scopes">synchronization scope</a>
includes only the event unsignal operation.


If <c>event</c> is already in the unsignaled state when <see cref="T:vkCmdResetEvent" />
is executed on the device, then <see cref="T:vkCmdResetEvent" /> has no effect, no
event unsignal operation occurs, and no execution dependency is generated.



Valid Usage
<list type="bullet"><item><description>
<c>stageMask</c> must not include <c>VK_PIPELINE_STAGE_HOST_BIT</c>
</description></item><item><description>

If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-geometryShader">geometry shaders</a> feature is
not enabled, <c>stageMask</c> must not contain
<c>VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT</c>
</description></item><item><description>

If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-tessellationShader">tessellation shaders</a>
feature is not enabled, <c>stageMask</c> must not contain
<c>VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT</c> or
<c>VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT</c>
</description></item><item><description>

When this command executes, <c>event</c> must not be waited on by a
<c>vkCmdWaitEvents</c> command that is currently executing
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>commandBuffer</c> must be a valid <c>VkCommandBuffer</c> handle
</description></item><item><description>
<c>event</c> must be a valid <c>VkEvent</c> handle
</description></item><item><description>
<c>stageMask</c> must be a valid combination of <see cref="T:VkPipelineStageFlags" /> values
</description></item><item><description>
<c>stageMask</c> must not be <c>0</c>
</description></item><item><description>
<c>commandBuffer</c> must be in the  recording state
</description></item><item><description>
 The <c>VkCommandPool</c> that <c>commandBuffer</c> was allocated from  must support graphics, or compute operations
</description></item><item><description>
 This command  must only be called outside of a render pass instance
</description></item><item><description>
 Both of <c>commandBuffer</c>, and <c>event</c> must have been created, allocated, or retrieved from the same <c>VkDevice</c>
</description></item></list>




Host Synchronization
<list type="bullet"><item><description>
Host access to <c>commandBuffer</c> must  be externally synchronized
</description></item><item><description>
Host access to the <c>VkCommandPool</c> that <c>commandBuffer</c> was allocated from  must be externally synchronized
</description></item></list>




Command Properties
<list type="table">       <listheader><tr><term> Command Buffer Levels </term><term> Render Pass Scope </term><term> Supported Queue Types </term><term> Pipeline Type </term></tr></listheader>
<item><term>
Primary<br />
Secondary
</term><term>
Outside
</term><term>
Graphics<br />
compute
</term><term></term></item>
</list>



To set the state of an event to unsignaled from a device, call:


<code> void vkCmdResetEvent(
    VkCommandBuffer                             commandBuffer,
    VkEvent                                     event,
    VkPipelineStageFlags                        stageMask); </code>

</remarks>
      <seealso cref="T:VkCommandBuffer" />
      <seealso cref="T:VkEvent" />
      <seealso cref="T:VkPipelineStageFlags" />
    </member>
    <member name="T:vkGetPhysicalDeviceSurfaceCapabilities2EXT" />
    <member name="T:vkCreateFramebuffer">
      <summary>Create a new framebuffer object</summary>
      <remarks>


Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>device</c> must be a valid <c>VkDevice</c> handle
</description></item><item><description>
<c>pCreateInfo</c> must be a pointer to a valid <c>VkFramebufferCreateInfo</c> structure
</description></item><item><description>
 If <c>pAllocator</c> is not <c>NULL</c>, <c>pAllocator</c> must be a pointer to a valid <c>VkAllocationCallbacks</c> structure
</description></item><item><description>
<c>pFramebuffer</c> must be a pointer to a <c>VkFramebuffer</c> handle
</description></item></list>




Return Codes
<dl><dt>On success, this command returns</dt><dd>
<list type="bullet"><item><description>
<c>VK_SUCCESS</c>
</description></item></list>
</dd><dt>On failure, this command returns</dt><dd>
<list type="bullet"><item><description>
<c>VK_ERROR_OUT_OF_HOST_MEMORY</c>
</description></item><item><description>
<c>VK_ERROR_OUT_OF_DEVICE_MEMORY</c>
</description></item></list>
</dd></dl>




To create a framebuffer, call:


<code> VkResult vkCreateFramebuffer(
    VkDevice                                    device,
    const VkFramebufferCreateInfo*              pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkFramebuffer*                              pFramebuffer); </code>

</remarks>
      <seealso cref="T:IVkAllocationCallbacks" />
      <seealso cref="T:VkDevice" />
      <seealso cref="T:VkFramebuffer" />
      <seealso cref="T:IVkFramebufferCreateInfo" />
    </member>
    <member name="T:vkCmdCopyImage">
      <summary>Copy data between images</summary>
      <remarks>

Each region in <c>pRegions</c> is copied from the source image to the same
region of the destination image.
<c>srcImage</c> and <c>dstImage</c> can  be the same image or alias the same
memory.


The formats of <c>srcImage</c> and <c>dstImage</c> must be compatible.
Formats are considered compatible if their element size is the same between
both formats.
For example, <c>VK_FORMAT_R8G8B8A8_UNORM</c> is compatible with
<c>VK_FORMAT_R32_UINT</c> because both texels are 4 bytes in size.
Depth/stencil formats  must match exactly.


<c>vkCmdCopyImage</c> allows copying between size-compatible compressed and
uncompressed internal formats.
Formats are size-compatible if the element size of the uncompressed format
is equal to the element size (compressed texel block size) of the compressed
format.
Such a copy does not perform on-the-fly compression or decompression.
When copying from an uncompressed format to a compressed format, each texel
of uncompressed data of the source image is copied as a raw value to the
corresponding compressed texel block of the destination image.
When copying from a compressed format to an uncompressed format, each
compressed texel block of the source image is copied as a raw value to the
corresponding texel of uncompressed data in the destination image.
Thus, for example, it is legal to copy between a 128-bit uncompressed format
and a compressed format which has a 128-bit sized compressed texel block
representing 4×4 texels (using 8 bits per texel), or between a 64-bit
uncompressed format and a compressed format which has a 64-bit sized
compressed texel block representing 4×4 texels (using 4 bits per
texel).


When copying between compressed and uncompressed formats the <c>extent</c>
members represent the texel dimensions of the source image and not the
destination.
When copying from a compressed image to an uncompressed image the image
texel dimensions written to the uncompressed image will be source extent
divided by the compressed texel block dimensions.
When copying from an uncompressed image to a compressed image the image
texel dimensions written to the compressed image will be the source extent
multiplied by the compressed texel block dimensions.
In both cases the number of bytes read and the number of bytes written will
be identical.


Copying to or from block-compressed images is typically done in multiples of
the compressed texel block size.
For this reason the <c>extent</c> must be a multiple of the compressed texel
block dimension.
There is one exception to this rule which is  required to handle compressed
images created with dimensions that are not a multiple of the compressed
texel block dimensions: if the <c>srcImage</c> is compressed, then:

<list type="bullet"><item><description>
If <c>extent.width</c> is not a multiple of the compressed texel block
width, then  (<c>extent.width</c> +  <c>srcOffset.x</c>) must 
equal the image subresource width.
</description></item><item><description>
If <c>extent.height</c> is not a multiple of the compressed texel block
height, then  (<c>extent.height</c> +  <c>srcOffset.y</c>) must 
equal the image subresource height.
</description></item><item><description>
If <c>extent.depth</c> is not a multiple of the compressed texel block
depth, then  (<c>extent.depth</c> +  <c>srcOffset.z</c>) must 
equal the image subresource depth.
</description></item></list>

Similarly, if the <c>dstImage</c> is compressed, then:

<list type="bullet"><item><description>
If <c>extent.width</c> is not a multiple of the compressed texel block
width, then  (<c>extent.width</c> +  <c>dstOffset.x</c>) must 
equal the image subresource width.
</description></item><item><description>
If <c>extent.height</c> is not a multiple of the compressed texel block
height, then  (<c>extent.height</c> +  <c>dstOffset.y</c>) must 
equal the image subresource height.
</description></item><item><description>
If <c>extent.depth</c> is not a multiple of the compressed texel block
depth, then  (<c>extent.depth</c> +  <c>dstOffset.z</c>) must 
equal the image subresource depth.
</description></item></list>

This allows the last compressed texel block of the image in each
non-multiple dimension to be included as a source or destination of the
copy.


<c>vkCmdCopyImage</c> can be used to copy image data between multisample
images, but both images  must have the same number of samples.



Valid Usage
<list type="bullet"><item><description>

The source region specified by a given element of <c>pRegions</c> must
be a region that is contained within <c>srcImage</c>
</description></item><item><description>

The destination region specified by a given element of <c>pRegions</c> must be a region that is contained within <c>dstImage</c>
</description></item><item><description>

The union of all source regions, and the union of all destination
regions, specified by the elements of <c>pRegions</c>,  must not overlap
in memory
</description></item><item><description>
<c>srcImage</c> must have been created with
<c>VK_IMAGE_USAGE_TRANSFER_SRC_BIT</c> usage flag
</description></item><item><description>

If <c>srcImage</c> is non-sparse then it  must be bound completely and
contiguously to a single <c>VkDeviceMemory</c> object
</description></item><item><description>
<c>srcImageLayout</c> must specify the layout of the image subresources
of <c>srcImage</c> specified in <c>pRegions</c> at the time this command
is executed on a <c>VkDevice</c>
</description></item><item><description>
<c>srcImageLayout</c> must be <c>VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL</c>
or <c>VK_IMAGE_LAYOUT_GENERAL</c>
</description></item><item><description>
<c>dstImage</c> must have been created with
<c>VK_IMAGE_USAGE_TRANSFER_DST_BIT</c> usage flag
</description></item><item><description>

If <c>dstImage</c> is non-sparse then it  must be bound completely and
contiguously to a single <c>VkDeviceMemory</c> object
</description></item><item><description>
<c>dstImageLayout</c> must specify the layout of the image subresources
of <c>dstImage</c> specified in <c>pRegions</c> at the time this command
is executed on a <c>VkDevice</c>
</description></item><item><description>
<c>dstImageLayout</c> must be <c>VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL</c>
or <c>VK_IMAGE_LAYOUT_GENERAL</c>
</description></item><item><description>

The <see cref="T:VkFormat" /> of each of <c>srcImage</c> and <c>dstImage</c> must be
compatible, as defined <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#copies-images-format-compatibility">below</a>
</description></item><item><description>

The sample count of <c>srcImage</c> and <c>dstImage</c> must  match
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>commandBuffer</c> must be a valid <c>VkCommandBuffer</c> handle
</description></item><item><description>
<c>srcImage</c> must be a valid <c>VkImage</c> handle
</description></item><item><description>
<c>srcImageLayout</c> must be a valid <see cref="T:VkImageLayout" /> value
</description></item><item><description>
<c>dstImage</c> must be a valid <c>VkImage</c> handle
</description></item><item><description>
<c>dstImageLayout</c> must be a valid <see cref="T:VkImageLayout" /> value
</description></item><item><description>
<c>pRegions</c> must be a pointer to an array of <c>regionCount</c> valid <c>VkImageCopy</c> structures
</description></item><item><description>
<c>commandBuffer</c> must be in the  recording state
</description></item><item><description>
 The <c>VkCommandPool</c> that <c>commandBuffer</c> was allocated from  must support transfer, graphics, or compute operations
</description></item><item><description>
 This command  must only be called outside of a render pass instance
</description></item><item><description>
<c>regionCount</c> must be greater than <c>0</c>
</description></item><item><description>
 Each of <c>commandBuffer</c>, <c>dstImage</c>, and <c>srcImage</c> must have been created, allocated, or retrieved from the same <c>VkDevice</c>
</description></item></list>




Host Synchronization
<list type="bullet"><item><description>
Host access to <c>commandBuffer</c> must  be externally synchronized
</description></item><item><description>
Host access to the <c>VkCommandPool</c> that <c>commandBuffer</c> was allocated from  must be externally synchronized
</description></item></list>




Command Properties
<list type="table">       <listheader><tr><term> Command Buffer Levels </term><term> Render Pass Scope </term><term> Supported Queue Types </term><term> Pipeline Type </term></tr></listheader>
<item><term>
Primary<br />
Secondary
</term><term>
Outside
</term><term>
Transfer<br />
graphics<br />
compute
</term><term>
Transfer
</term></item>
</list>



To copy data between image objects, call:


<code> void vkCmdCopyImage(
    VkCommandBuffer                             commandBuffer,
    VkImage                                     srcImage,
    VkImageLayout                               srcImageLayout,
    VkImage                                     dstImage,
    VkImageLayout                               dstImageLayout,
    uint32_t                                    regionCount,
    const VkImageCopy*                          pRegions); </code>

</remarks>
      <seealso cref="T:VkCommandBuffer" />
      <seealso cref="T:VkImage" />
      <seealso cref="T:VkImageCopy" />
      <seealso cref="T:VkImageLayout" />
    </member>
    <member name="T:vkGetPhysicalDeviceDisplayPlanePropertiesKHR" />
    <member name="T:IVkComputePipelineCreateInfo">
      <summary>Structure specifying parameters of a newly created compute pipeline</summary>
      <remarks>

The parameters <c>basePipelineHandle</c> and <c>basePipelineIndex</c> are
described in more detail in <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#pipelines-pipeline-derivatives">Pipeline
Derivatives</a>.


<c>stage</c> points to a structure of type
<c>VkPipelineShaderStageCreateInfo</c>.



Valid Usage
<list type="bullet"><item><description>

If <c>flags</c> contains the <c>VK_PIPELINE_CREATE_DERIVATIVE_BIT</c>
flag, and <c>basePipelineIndex</c> is -1, <c>basePipelineHandle</c> must
be a valid handle to a compute <c>VkPipeline</c>
</description></item><item><description>

If <c>flags</c> contains the <c>VK_PIPELINE_CREATE_DERIVATIVE_BIT</c>
flag, and <c>basePipelineHandle</c> is <see cref="!:VK_NULL_HANDLE" />,
<c>basePipelineIndex</c> must be a valid index into the calling
command&amp;#8217;s <c>pCreateInfos</c> parameter
</description></item><item><description>

If <c>flags</c> contains the <c>VK_PIPELINE_CREATE_DERIVATIVE_BIT</c>
flag, and <c>basePipelineIndex</c> is not -1, <c>basePipelineHandle</c> must be <see cref="!:VK_NULL_HANDLE" />
</description></item><item><description>

If <c>flags</c> contains the <c>VK_PIPELINE_CREATE_DERIVATIVE_BIT</c>
flag, and <c>basePipelineHandle</c> is not <see cref="!:VK_NULL_HANDLE" />,
<c>basePipelineIndex</c> must  be -1
</description></item><item><description>

The <c>stage</c> member of <c>stage</c> must be
<c>VK_SHADER_STAGE_COMPUTE_BIT</c>
</description></item><item><description>

The shader code for the entry point identified by <c>stage</c> and the
rest of the state identified by this structure  must adhere to the
pipeline linking rules described in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#interfaces">Shader Interfaces</a>
chapter
</description></item><item><description>
<c>layout</c> must be
<a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#descriptorsets-pipelinelayout-consistency">consistent</a> with the layout
of the compute shader specified in <c>stage</c>
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>sType</c> must be <c>VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO</c>
</description></item><item><description>
<c>pNext</c> must be <c>NULL</c>
</description></item><item><description>
<c>flags</c> must be a valid combination of <see cref="T:VkPipelineCreateFlags" /> values
</description></item><item><description>
<c>stage</c> must be a valid <c>VkPipelineShaderStageCreateInfo</c> structure
</description></item><item><description>
<c>layout</c> must be a valid <c>VkPipelineLayout</c> handle
</description></item><item><description>
 Both of <c>basePipelineHandle</c>, and <c>layout</c> that are valid handles  must have been created, allocated, or retrieved from the same <c>VkDevice</c>
</description></item></list>




The <c>VkComputePipelineCreateInfo</c> structure is defined as:


<code> typedef struct VkComputePipelineCreateInfo {
    VkStructureType                    sType;
    const void*                        pNext;
    VkPipelineCreateFlags              flags;
    VkPipelineShaderStageCreateInfo    stage;
    VkPipelineLayout                   layout;
    VkPipeline                         basePipelineHandle;
    int32_t                            basePipelineIndex;
} VkComputePipelineCreateInfo; </code>

</remarks>
      <seealso cref="T:VkPipeline" />
      <seealso cref="T:VkPipelineCreateFlags" />
      <seealso cref="T:VkPipelineLayout" />
      <seealso cref="T:IVkPipelineShaderStageCreateInfo" />
      <seealso cref="T:VkStructureType" />
      <seealso cref="T:vkCreateComputePipelines" />
    </member>
    <member name="T:VkComputePipelineCreateInfo32">
      <summary>See: <see cref="T:IVkComputePipelineCreateInfo" /></summary>
      <seealso cref="T:IVkComputePipelineCreateInfo" />
    </member>
    <member name="T:VkComputePipelineCreateInfo64">
      <summary>See: <see cref="T:IVkComputePipelineCreateInfo" /></summary>
      <seealso cref="T:IVkComputePipelineCreateInfo" />
    </member>
    <member name="T:IVkRenderPassBeginInfo">
      <summary>Structure specifying render pass begin info</summary>
      <remarks>

<c>renderArea</c> is the render area that is affected by the render pass
instance.
The effects of attachment load, store and multisample resolve operations are
restricted to the pixels whose x and y coordinates fall within the render
area on all attachments.
The render area extends to all layers of <c>framebuffer</c>.
The application  must ensure (using scissor if necessary) that all rendering
is contained within the render area, otherwise the pixels outside of the
render area become undefined and shader side effects  may occur for
fragments outside the render area.
The render area  must be contained within the framebuffer dimensions.

<list type="table"><tr><td><i title="Note"></i></td><td>
Note

There  may be a performance cost for using a render area smaller than the
framebuffer, unless it matches the render area granularity for the render
pass.

</td></tr></list>


Valid Usage
<list type="bullet"><item><description>
<c>clearValueCount</c> must be greater than the largest attachment index
in <c>renderPass</c> that specifies a <c>loadOp</c> (or
<c>stencilLoadOp</c>, if the attachment has a depth/stencil format) of
<c>VK_ATTACHMENT_LOAD_OP_CLEAR</c>
</description></item><item><description>

If <c>clearValueCount</c> is not <c>0</c>, <c>pClearValues</c> must be a
pointer to an array of <c>clearValueCount</c> valid <c>VkClearValue</c>
unions
</description></item><item><description>
<c>renderPass</c> must be <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#renderpass-compatibility">compatible</a> with
the <c>renderPass</c> member of the <c>VkFramebufferCreateInfo</c>
structure specified when creating <c>framebuffer</c>.
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>sType</c> must be <c>VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO</c>
</description></item><item><description>
<c>pNext</c> must be <c>NULL</c>
</description></item><item><description>
<c>renderPass</c> must be a valid <c>VkRenderPass</c> handle
</description></item><item><description>
<c>framebuffer</c> must be a valid <c>VkFramebuffer</c> handle
</description></item><item><description>
 Both of <c>framebuffer</c>, and <c>renderPass</c> must have been created, allocated, or retrieved from the same <c>VkDevice</c>
</description></item></list>




The <c>VkRenderPassBeginInfo</c> structure is defined as:


<code> typedef struct VkRenderPassBeginInfo {
    VkStructureType        sType;
    const void*            pNext;
    VkRenderPass           renderPass;
    VkFramebuffer          framebuffer;
    VkRect2D               renderArea;
    uint32_t               clearValueCount;
    const VkClearValue*    pClearValues;
} VkRenderPassBeginInfo; </code>

</remarks>
      <seealso cref="T:VkClearValue" />
      <seealso cref="T:VkFramebuffer" />
      <seealso cref="T:VkRect2D" />
      <seealso cref="T:VkRenderPass" />
      <seealso cref="T:VkStructureType" />
      <seealso cref="T:vkCmdBeginRenderPass" />
    </member>
    <member name="T:VkRenderPassBeginInfo32">
      <summary>See: <see cref="T:IVkRenderPassBeginInfo" /></summary>
      <seealso cref="T:IVkRenderPassBeginInfo" />
    </member>
    <member name="T:VkRenderPassBeginInfo64">
      <summary>See: <see cref="T:IVkRenderPassBeginInfo" /></summary>
      <seealso cref="T:IVkRenderPassBeginInfo" />
    </member>
    <member name="T:vkCreateBuffer">
      <summary>Create a new buffer object</summary>
      <remarks>


Valid Usage
<list type="bullet"><item><description>

If the <c>flags</c> member of <c>pCreateInfo</c> includes
<c>VK_BUFFER_CREATE_SPARSE_BINDING_BIT</c>, creating this <c>VkBuffer</c> must not cause the total required sparse memory for all currently valid
sparse resources on the device to exceed
<c>VkPhysicalDeviceLimits</c>::<c>sparseAddressSpaceSize</c>
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>device</c> must be a valid <c>VkDevice</c> handle
</description></item><item><description>
<c>pCreateInfo</c> must be a pointer to a valid <c>VkBufferCreateInfo</c> structure
</description></item><item><description>
 If <c>pAllocator</c> is not <c>NULL</c>, <c>pAllocator</c> must be a pointer to a valid <c>VkAllocationCallbacks</c> structure
</description></item><item><description>
<c>pBuffer</c> must be a pointer to a <c>VkBuffer</c> handle
</description></item></list>




Return Codes
<dl><dt>On success, this command returns</dt><dd>
<list type="bullet"><item><description>
<c>VK_SUCCESS</c>
</description></item></list>
</dd><dt>On failure, this command returns</dt><dd>
<list type="bullet"><item><description>
<c>VK_ERROR_OUT_OF_HOST_MEMORY</c>
</description></item><item><description>
<c>VK_ERROR_OUT_OF_DEVICE_MEMORY</c>
</description></item></list>
</dd></dl>




To create buffers, call:


<code> VkResult vkCreateBuffer(
    VkDevice                                    device,
    const VkBufferCreateInfo*                   pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkBuffer*                                   pBuffer); </code>

</remarks>
      <seealso cref="T:IVkAllocationCallbacks" />
      <seealso cref="T:VkBuffer" />
      <seealso cref="T:IVkBufferCreateInfo" />
      <seealso cref="T:VkDevice" />
    </member>
    <member name="T:VkSparseImageMemoryBind">
      <summary>Structure specifying sparse image memory bind</summary>
      <remarks>


Valid Usage
<list type="bullet"><item><description>

If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-sparseResidencyAliased">sparse aliased
residency</a> feature is not enabled, and if any other resources are bound
to ranges of <c>memory</c>, the range of <c>memory</c> being bound  must
not overlap with those bound ranges
</description></item><item><description>
<c>memory</c> and <c>memoryOffset</c> must match the memory requirements
of the calling command&amp;#8217;s <c>image</c>, as described in section
<a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#resources-association">../../html/vkspec.html#resources-association</a>
</description></item><item><description>
<c>subresource</c> must be a valid image subresource for <c>image</c>
(see <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#resources-image-views">../../html/vkspec.html#resources-image-views</a>)
</description></item><item><description>
<c>offset.x</c> must  be a multiple of the sparse image block width
(<c>VkSparseImageFormatProperties</c>::<c>imageGranularity.width</c>) of
the image
</description></item><item><description>
<c>extent.width</c> must either be a multiple of the sparse image block
width of the image, or else  (<c>extent.width</c> + 
<c>offset.x</c>) must  equal the width of the image subresource
</description></item><item><description>
<c>offset.y</c> must  be a multiple of the sparse image block height
(<c>VkSparseImageFormatProperties</c>::<c>imageGranularity.height</c>) of
the image
</description></item><item><description>
<c>extent.height</c> must either be a multiple of the sparse image block
height of the image, or else  (<c>extent.height</c> + 
<c>offset.y</c>) must  equal the height of the image subresource
</description></item><item><description>
<c>offset.z</c> must  be a multiple of the sparse image block depth
(<c>VkSparseImageFormatProperties</c>::<c>imageGranularity.depth</c>) of
the image
</description></item><item><description>
<c>extent.depth</c> must either be a multiple of the sparse image block
depth of the image, or else  (<c>extent.depth</c> + 
<c>offset.z</c>) must  equal the depth of the image subresource
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>subresource</c> must be a valid <c>VkImageSubresource</c> structure
</description></item><item><description>
 If <c>memory</c> is not <see cref="!:VK_NULL_HANDLE" />, <c>memory</c> must be a valid <c>VkDeviceMemory</c> handle
</description></item><item><description>
<c>flags</c> must be a valid combination of <see cref="T:VkSparseMemoryBindFlags" /> values
</description></item></list>




The <c>VkSparseImageMemoryBind</c> structure is defined as:


<code> typedef struct VkSparseImageMemoryBind {
    VkImageSubresource         subresource;
    VkOffset3D                 offset;
    VkExtent3D                 extent;
    VkDeviceMemory             memory;
    VkDeviceSize               memoryOffset;
    VkSparseMemoryBindFlags    flags;
} VkSparseImageMemoryBind; </code>

</remarks>
      <seealso cref="T:VkDeviceMemory" />
      <seealso cref="T:VkExtent3D" />
      <seealso cref="T:VkImageSubresource" />
      <seealso cref="T:VkOffset3D" />
      <seealso cref="T:IVkSparseImageMemoryBindInfo" />
      <seealso cref="T:VkSparseMemoryBindFlags" />
    </member>
    <member name="T:vkGetDeviceGroupPeerMemoryFeaturesKHX" />
    <member name="T:vkDestroySwapchainKHR" />
    <member name="T:IVkImageSwapchainCreateInfoKHX" />
    <member name="T:VkImageSwapchainCreateInfoKHX32">
      <summary>See: <see cref="T:IVkImageSwapchainCreateInfoKHX" /></summary>
      <seealso cref="T:IVkImageSwapchainCreateInfoKHX" />
    </member>
    <member name="T:VkImageSwapchainCreateInfoKHX64">
      <summary>See: <see cref="T:IVkImageSwapchainCreateInfoKHX" /></summary>
      <seealso cref="T:IVkImageSwapchainCreateInfoKHX" />
    </member>
    <member name="T:vkReleaseDisplayEXT" />
    <member name="T:vkCmdEndQuery">
      <summary>Ends a query</summary>
      <remarks>

As queries operate asynchronously, ending a query does not immediately set
the query&amp;#8217;s status to available.
A query is considered  finished when the final results of the query are
ready to be retrieved by <see cref="T:vkGetQueryPoolResults" /> and
<see cref="T:vkCmdCopyQueryPoolResults" />, and this is when the query&amp;#8217;s status is set
to available.


Once a query is ended the query  must finish in finite time, unless the
state of the query is changed using other commands, e.g. by issuing a reset
of the query.



Valid Usage
<list type="bullet"><item><description>

The query identified by <c>queryPool</c> and <c>query</c> must currently
be <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#queries-operation-active">active</a>
</description></item><item><description>
<c>query</c> must be less than the number of queries in <c>queryPool</c>
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>commandBuffer</c> must be a valid <c>VkCommandBuffer</c> handle
</description></item><item><description>
<c>queryPool</c> must be a valid <c>VkQueryPool</c> handle
</description></item><item><description>
<c>commandBuffer</c> must be in the  recording state
</description></item><item><description>
 The <c>VkCommandPool</c> that <c>commandBuffer</c> was allocated from  must support graphics, or compute operations
</description></item><item><description>
 Both of <c>commandBuffer</c>, and <c>queryPool</c> must have been created, allocated, or retrieved from the same <c>VkDevice</c>
</description></item></list>




Host Synchronization
<list type="bullet"><item><description>
Host access to <c>commandBuffer</c> must  be externally synchronized
</description></item><item><description>
Host access to the <c>VkCommandPool</c> that <c>commandBuffer</c> was allocated from  must be externally synchronized
</description></item></list>




Command Properties
<list type="table">       <listheader><tr><term> Command Buffer Levels </term><term> Render Pass Scope </term><term> Supported Queue Types </term><term> Pipeline Type </term></tr></listheader>
<item><term>
Primary<br />
Secondary
</term><term>
Both
</term><term>
Graphics<br />
compute
</term><term></term></item>
</list>



To end a query after the set of desired draw or dispatch commands is
executed, call:


<code> void vkCmdEndQuery(
    VkCommandBuffer                             commandBuffer,
    VkQueryPool                                 queryPool,
    uint32_t                                    query); </code>

</remarks>
      <seealso cref="T:VkCommandBuffer" />
      <seealso cref="T:VkQueryPool" />
    </member>
    <member name="T:IVkImportSemaphoreFdInfoKHX" />
    <member name="T:VkImportSemaphoreFdInfoKHX32">
      <summary>See: <see cref="T:IVkImportSemaphoreFdInfoKHX" /></summary>
      <seealso cref="T:IVkImportSemaphoreFdInfoKHX" />
    </member>
    <member name="T:VkImportSemaphoreFdInfoKHX64">
      <summary>See: <see cref="T:IVkImportSemaphoreFdInfoKHX" /></summary>
      <seealso cref="T:IVkImportSemaphoreFdInfoKHX" />
    </member>
    <member name="T:vkBindBufferMemory">
      <summary>Bind device memory to a buffer object</summary>
      <remarks>


Valid Usage
<list type="bullet"><item><description>
<c>buffer</c> must  not already be backed by a memory object
</description></item><item><description>
<c>buffer</c> must  not have been created with any sparse memory binding
flags
</description></item><item><description>
<c>memoryOffset</c> must be less than the size of <c>memory</c>
</description></item><item><description>

If <c>buffer</c> was created with the
<c>VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT</c> or
<c>VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT</c>, <c>memoryOffset</c> must
be a multiple of
<c>VkPhysicalDeviceLimits</c>::<c>minTexelBufferOffsetAlignment</c>
</description></item><item><description>

If <c>buffer</c> was created with the
<c>VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT</c>, <c>memoryOffset</c> must be a
multiple of
<c>VkPhysicalDeviceLimits</c>::<c>minUniformBufferOffsetAlignment</c>
</description></item><item><description>

If <c>buffer</c> was created with the
<c>VK_BUFFER_USAGE_STORAGE_BUFFER_BIT</c>, <c>memoryOffset</c> must be a
multiple of
<c>VkPhysicalDeviceLimits</c>::<c>minStorageBufferOffsetAlignment</c>
</description></item><item><description>
<c>memory</c> must have been allocated using one of the memory types
allowed in the <c>memoryTypeBits</c> member of the
<c>VkMemoryRequirements</c> structure returned from a call to
<c>vkGetBufferMemoryRequirements</c> with <c>buffer</c>
</description></item><item><description>
<c>memoryOffset</c> must be an integer multiple of the <c>alignment</c>
member of the <c>VkMemoryRequirements</c> structure returned from a call
to <c>vkGetBufferMemoryRequirements</c> with <c>buffer</c>
</description></item><item><description>

The <c>size</c> member of the <c>VkMemoryRequirements</c> structure
returned from a call to <c>vkGetBufferMemoryRequirements</c> with
<c>buffer</c> must be less than or equal to the size of <c>memory</c>
minus <c>memoryOffset</c>
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>device</c> must be a valid <c>VkDevice</c> handle
</description></item><item><description>
<c>buffer</c> must be a valid <c>VkBuffer</c> handle
</description></item><item><description>
<c>memory</c> must be a valid <c>VkDeviceMemory</c> handle
</description></item><item><description>
<c>buffer</c> must have been created, allocated, or retrieved from <c>device</c>
</description></item><item><description>
<c>memory</c> must have been created, allocated, or retrieved from <c>device</c>
</description></item></list>




Host Synchronization
<list type="bullet"><item><description>
Host access to <c>buffer</c> must  be externally synchronized
</description></item></list>




Return Codes
<dl><dt>On success, this command returns</dt><dd>
<list type="bullet"><item><description>
<c>VK_SUCCESS</c>
</description></item></list>
</dd><dt>On failure, this command returns</dt><dd>
<list type="bullet"><item><description>
<c>VK_ERROR_OUT_OF_HOST_MEMORY</c>
</description></item><item><description>
<c>VK_ERROR_OUT_OF_DEVICE_MEMORY</c>
</description></item></list>
</dd></dl>




To attach memory to a buffer object, call:


<code> VkResult vkBindBufferMemory(
    VkDevice                                    device,
    VkBuffer                                    buffer,
    VkDeviceMemory                              memory,
    VkDeviceSize                                memoryOffset); </code>

</remarks>
      <seealso cref="T:VkBuffer" />
      <seealso cref="T:VkDevice" />
      <seealso cref="T:VkDeviceMemory" />
    </member>
    <member name="T:IVkPhysicalDeviceFeatures2KHR" />
    <member name="T:VkPhysicalDeviceFeatures2KHR32">
      <summary>See: <see cref="T:IVkPhysicalDeviceFeatures2KHR" /></summary>
      <seealso cref="T:IVkPhysicalDeviceFeatures2KHR" />
    </member>
    <member name="T:VkPhysicalDeviceFeatures2KHR64">
      <summary>See: <see cref="T:IVkPhysicalDeviceFeatures2KHR" /></summary>
      <seealso cref="T:IVkPhysicalDeviceFeatures2KHR" />
    </member>
    <member name="T:IVkExternalMemoryImageCreateInfoKHX" />
    <member name="T:VkExternalMemoryImageCreateInfoKHX32">
      <summary>See: <see cref="T:IVkExternalMemoryImageCreateInfoKHX" /></summary>
      <seealso cref="T:IVkExternalMemoryImageCreateInfoKHX" />
    </member>
    <member name="T:VkExternalMemoryImageCreateInfoKHX64">
      <summary>See: <see cref="T:IVkExternalMemoryImageCreateInfoKHX" /></summary>
      <seealso cref="T:IVkExternalMemoryImageCreateInfoKHX" />
    </member>
    <member name="T:IVkRenderPassCreateInfo">
      <summary>Structure specifying parameters of a newly created render pass</summary>
      <remarks>


Valid Usage
<list type="bullet"><item><description>

If any two subpasses operate on attachments with overlapping ranges of
the same <c>VkDeviceMemory</c> object, and at least one subpass writes to
that area of <c>VkDeviceMemory</c>, a subpass dependency  must be
included (either directly or via some intermediate subpasses) between
them
</description></item><item><description>

If the <c>attachment</c> member of any element of
<c>pInputAttachments</c>, <c>pColorAttachments</c>,
<c>pResolveAttachments</c> or <c>pDepthStencilAttachment</c>, or the
attachment indexed by any element of <c>pPreserveAttachments</c> in any
given element of <c>pSubpasses</c> is bound to a range of a
<c>VkDeviceMemory</c> object that overlaps with any other attachment in
any subpass (including the same subpass), the
<c>VkAttachmentDescription</c> structures describing them  must include
<c>VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT</c> in <c>flags</c>
</description></item><item><description>

If the <c>attachment</c> member of any element of
<c>pInputAttachments</c>, <c>pColorAttachments</c>,
<c>pResolveAttachments</c> or <c>pDepthStencilAttachment</c>, or any
element of <c>pPreserveAttachments</c> in any given element of
<c>pSubpasses</c> is not <c>VK_ATTACHMENT_UNUSED</c>, it  must be less
than <c>attachmentCount</c>
</description></item><item><description>

The value of any element of the <c>pPreserveAttachments</c> member in any
given element of <c>pSubpasses</c> must not be
<c>VK_ATTACHMENT_UNUSED</c>
</description></item><item><description>

For any member of <c>pAttachments</c> with a <c>loadOp</c> equal to
<c>VK_ATTACHMENT_LOAD_OP_CLEAR</c>, the first use of that attachment
 must not specify a <c>layout</c> equal to
<c>VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL</c> or
<c>VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL</c>.
</description></item><item><description>

For any element of <c>pDependencies</c>, if the <c>srcSubpass</c> is not
<c>VK_SUBPASS_EXTERNAL</c>, all stage flags included in the
<c>srcStageMask</c> member of that dependency  must be a pipeline stage
supported by the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-pipeline-stages-types">pipeline</a>
identified by the <c>pipelineBindPoint</c> member of the source subpass.
</description></item><item><description>

For any element of <c>pDependencies</c>, if the <c>dstSubpass</c> is not
<c>VK_SUBPASS_EXTERNAL</c>, all stage flags included in the
<c>dstStageMask</c> member of that dependency  must be a pipeline stage
supported by the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-pipeline-stages-types">pipeline</a>
identified by the <c>pipelineBindPoint</c> member of the source subpass.
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>sType</c> must be <c>VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO</c>
</description></item><item><description>
<c>pNext</c> must be <c>NULL</c>
</description></item><item><description>
<c>flags</c> must be <c>0</c>
</description></item><item><description>
 If <c>attachmentCount</c> is not <c>0</c>, <c>pAttachments</c> must be a pointer to an array of <c>attachmentCount</c> valid <c>VkAttachmentDescription</c> structures
</description></item><item><description>
<c>pSubpasses</c> must be a pointer to an array of <c>subpassCount</c> valid <c>VkSubpassDescription</c> structures
</description></item><item><description>
 If <c>dependencyCount</c> is not <c>0</c>, <c>pDependencies</c> must be a pointer to an array of <c>dependencyCount</c> valid <c>VkSubpassDependency</c> structures
</description></item><item><description>
<c>subpassCount</c> must be greater than <c>0</c>
</description></item></list>




The <c>VkRenderPassCreateInfo</c> structure is defined as:


<code> typedef struct VkRenderPassCreateInfo {
    VkStructureType                   sType;
    const void*                       pNext;
    VkRenderPassCreateFlags           flags;
    uint32_t                          attachmentCount;
    const VkAttachmentDescription*    pAttachments;
    uint32_t                          subpassCount;
    const VkSubpassDescription*       pSubpasses;
    uint32_t                          dependencyCount;
    const VkSubpassDependency*        pDependencies;
} VkRenderPassCreateInfo; </code>

</remarks>
      <seealso cref="T:VkAttachmentDescription" />
      <seealso cref="T:VkRenderPassCreateFlags" />
      <seealso cref="T:VkStructureType" />
      <seealso cref="T:VkSubpassDependency" />
      <seealso cref="T:IVkSubpassDescription" />
      <seealso cref="T:vkCreateRenderPass" />
    </member>
    <member name="T:VkRenderPassCreateInfo32">
      <summary>See: <see cref="T:IVkRenderPassCreateInfo" /></summary>
      <seealso cref="T:IVkRenderPassCreateInfo" />
    </member>
    <member name="T:VkRenderPassCreateInfo64">
      <summary>See: <see cref="T:IVkRenderPassCreateInfo" /></summary>
      <seealso cref="T:IVkRenderPassCreateInfo" />
    </member>
    <member name="T:vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX" />
    <member name="T:vkAcquireNextImage2KHX" />
    <member name="T:vkMapMemory">
      <summary>Map a memory object into application address space</summary>
      <remarks>

It is an application error to call <c>vkMapMemory</c> on a memory object that
is already mapped.

<list type="table"><tr><td><i title="Note"></i></td><td>
Note

<c>vkMapMemory</c> will fail if the implementation is unable to allocate an
appropriately sized contiguous virtual address range, e.g. due to virtual
address space fragmentation or platform limits.
In such cases, <c>vkMapMemory</c> must return
<c>VK_ERROR_MEMORY_MAP_FAILED</c>.
The application  can improve the likelihood of success by reducing the size
of the mapped range and/or removing unneeded mappings using
<c>VkUnmapMemory</c>.

</td></tr></list>

<c>vkMapMemory</c> does not check whether the device memory is currently in
use before returning the host-accessible pointer.
The application  must guarantee that any previously submitted command that
writes to this range has completed before the host reads from or writes to
that range, and that any previously submitted command that reads from that
range has completed before the host writes to that region (see
<a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-submission-host-writes">here</a> for details on fulfilling
such a guarantee).
If the device memory was allocated without the
<c>VK_MEMORY_PROPERTY_HOST_COHERENT_BIT</c> set, these guarantees  must be
made for an extended range: the application  must round down the start of
the range to the nearest multiple of
<c>VkPhysicalDeviceLimits</c>::<c>nonCoherentAtomSize</c>, and round the end
of the range up to the nearest multiple of
<c>VkPhysicalDeviceLimits</c>::<c>nonCoherentAtomSize</c>.


While a range of device memory is mapped for host access, the application is
responsible for synchronizing both device and host access to that memory
range.

<list type="table"><tr><td><i title="Note"></i></td><td>
Note

It is important for the application developer to become meticulously
familiar with all of the mechanisms described in the chapter on
<a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization">Synchronization and Cache Control</a> as they are crucial
to maintaining memory access ordering.

</td></tr></list>


Valid Usage
<list type="bullet"><item><description>
<c>memory</c> must  not currently be mapped
</description></item><item><description>
<c>offset</c> must be less than the size of <c>memory</c>
</description></item><item><description>

If <c>size</c> is not equal to <c>VK_WHOLE_SIZE</c>, <c>size</c> must be
greater than <c>0</c>
</description></item><item><description>

If <c>size</c> is not equal to <c>VK_WHOLE_SIZE</c>, <c>size</c> must be
less than or equal to the size of the <c>memory</c> minus <c>offset</c>
</description></item><item><description>
<c>memory</c> must have been created with a memory type that reports
<c>VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT</c>
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>device</c> must be a valid <c>VkDevice</c> handle
</description></item><item><description>
<c>memory</c> must be a valid <c>VkDeviceMemory</c> handle
</description></item><item><description>
<c>flags</c> must be <c>0</c>
</description></item><item><description>
<c>ppData</c> must  be a pointer to a pointer
</description></item><item><description>
<c>memory</c> must have been created, allocated, or retrieved from <c>device</c>
</description></item></list>




Host Synchronization
<list type="bullet"><item><description>
Host access to <c>memory</c> must  be externally synchronized
</description></item></list>




Return Codes
<dl><dt>On success, this command returns</dt><dd>
<list type="bullet"><item><description>
<c>VK_SUCCESS</c>
</description></item></list>
</dd><dt>On failure, this command returns</dt><dd>
<list type="bullet"><item><description>
<c>VK_ERROR_OUT_OF_HOST_MEMORY</c>
</description></item><item><description>
<c>VK_ERROR_OUT_OF_DEVICE_MEMORY</c>
</description></item><item><description>
<c>VK_ERROR_MEMORY_MAP_FAILED</c>
</description></item></list>
</dd></dl>




To retrieve a host virtual address pointer to a region of a mappable memory
object, call:


<code> VkResult vkMapMemory(
    VkDevice                                    device,
    VkDeviceMemory                              memory,
    VkDeviceSize                                offset,
    VkDeviceSize                                size,
    VkMemoryMapFlags                            flags,
    void**                                      ppData); </code>

</remarks>
      <seealso cref="T:VkDevice" />
      <seealso cref="T:VkDeviceMemory" />
      <seealso cref="T:VkMemoryMapFlags" />
    </member>
    <member name="T:vkCmdDrawIndirectCountAMD" />
    <member name="T:vkCmdSetDiscardRectangleEXT" />
    <member name="T:vkCreatePipelineLayout">
      <summary>Creates a new pipeline layout object</summary>
      <remarks>


Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>device</c> must be a valid <c>VkDevice</c> handle
</description></item><item><description>
<c>pCreateInfo</c> must be a pointer to a valid <c>VkPipelineLayoutCreateInfo</c> structure
</description></item><item><description>
 If <c>pAllocator</c> is not <c>NULL</c>, <c>pAllocator</c> must be a pointer to a valid <c>VkAllocationCallbacks</c> structure
</description></item><item><description>
<c>pPipelineLayout</c> must be a pointer to a <c>VkPipelineLayout</c> handle
</description></item></list>




Return Codes
<dl><dt>On success, this command returns</dt><dd>
<list type="bullet"><item><description>
<c>VK_SUCCESS</c>
</description></item></list>
</dd><dt>On failure, this command returns</dt><dd>
<list type="bullet"><item><description>
<c>VK_ERROR_OUT_OF_HOST_MEMORY</c>
</description></item><item><description>
<c>VK_ERROR_OUT_OF_DEVICE_MEMORY</c>
</description></item></list>
</dd></dl>




To create a pipeline layout, call:


<code> VkResult vkCreatePipelineLayout(
    VkDevice                                    device,
    const VkPipelineLayoutCreateInfo*           pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkPipelineLayout*                           pPipelineLayout); </code>

</remarks>
      <seealso cref="T:IVkAllocationCallbacks" />
      <seealso cref="T:VkDevice" />
      <seealso cref="T:VkPipelineLayout" />
      <seealso cref="T:IVkPipelineLayoutCreateInfo" />
    </member>
    <member name="T:IVkSemaphoreCreateInfo">
      <summary>Structure specifying parameters of a newly created semaphore</summary>
      <remarks>


Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>sType</c> must be <c>VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO</c>
</description></item><item><description>
<c>pNext</c> must be <c>NULL</c>
</description></item><item><description>
<c>flags</c> must be <c>0</c>
</description></item></list>




The <c>VkSemaphoreCreateInfo</c> structure is defined as:


<code> typedef struct VkSemaphoreCreateInfo {
    VkStructureType           sType;
    const void*               pNext;
    VkSemaphoreCreateFlags    flags;
} VkSemaphoreCreateInfo; </code>

</remarks>
      <seealso cref="T:VkSemaphoreCreateFlags" />
      <seealso cref="T:VkStructureType" />
      <seealso cref="T:vkCreateSemaphore" />
    </member>
    <member name="T:VkSemaphoreCreateInfo32">
      <summary>See: <see cref="T:IVkSemaphoreCreateInfo" /></summary>
      <seealso cref="T:IVkSemaphoreCreateInfo" />
    </member>
    <member name="T:VkSemaphoreCreateInfo64">
      <summary>See: <see cref="T:IVkSemaphoreCreateInfo" /></summary>
      <seealso cref="T:IVkSemaphoreCreateInfo" />
    </member>
    <member name="T:vkCmdSetDepthBounds">
      <summary>Set the depth bounds test values for a command buffer</summary>
      <remarks>


Valid Usage
<list type="bullet"><item><description>

The currently bound graphics pipeline  must have been created with the
<c>VK_DYNAMIC_STATE_DEPTH_BOUNDS</c> dynamic state enabled
</description></item><item><description>
<c>minDepthBounds</c> must be between <c>0.0</c> and <c>1.0</c>, inclusive
</description></item><item><description>
<c>maxDepthBounds</c> must be between <c>0.0</c> and <c>1.0</c>, inclusive
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>commandBuffer</c> must be a valid <c>VkCommandBuffer</c> handle
</description></item><item><description>
<c>commandBuffer</c> must be in the  recording state
</description></item><item><description>
 The <c>VkCommandPool</c> that <c>commandBuffer</c> was allocated from  must support graphics operations
</description></item></list>




Host Synchronization
<list type="bullet"><item><description>
Host access to <c>commandBuffer</c> must  be externally synchronized
</description></item><item><description>
Host access to the <c>VkCommandPool</c> that <c>commandBuffer</c> was allocated from  must be externally synchronized
</description></item></list>




Command Properties
<list type="table">       <listheader><tr><term> Command Buffer Levels </term><term> Render Pass Scope </term><term> Supported Queue Types </term><term> Pipeline Type </term></tr></listheader>
<item><term>
Primary<br />
Secondary
</term><term>
Both
</term><term>
Graphics
</term><term></term></item>
</list>



The depth bounds test conditionally disables coverage of a sample based on
the outcome of a comparison between the value  z<sub>a</sub> in the depth
attachment at location  (x<sub>f</sub>,y<sub>f</sub>) (for the appropriate sample) and a
range of values.
The test is enabled or disabled by the <c>depthBoundsTestEnable</c> member of
<see cref="T:IVkPipelineDepthStencilStateCreateInfo" />: If the pipeline state object is
created without the <c>VK_DYNAMIC_STATE_DEPTH_BOUNDS</c> dynamic state
enabled then the range of values used in the depth bounds test are defined
by the <c>minDepthBounds</c> and <c>maxDepthBounds</c> members of the
<see cref="T:IVkPipelineDepthStencilStateCreateInfo" /> structure.
Otherwise, to dynamically set the depth bounds range values call:


<code> void vkCmdSetDepthBounds(
    VkCommandBuffer                             commandBuffer,
    float                                       minDepthBounds,
    float                                       maxDepthBounds); </code>

</remarks>
      <seealso cref="T:VkCommandBuffer" />
    </member>
    <member name="T:vkCmdFillBuffer">
      <summary>Fill a region of a buffer with a fixed value</summary>
      <remarks>

<c>vkCmdFillBuffer</c> is treated as &amp;#8220;transfer&amp;#8221; operation for the purposes
of synchronization barriers.
The <c>VK_BUFFER_USAGE_TRANSFER_DST_BIT</c> must be specified in <c>usage</c>
of <c>VkBufferCreateInfo</c> in order for the buffer to be compatible with
<c>vkCmdFillBuffer</c>.



Valid Usage
<list type="bullet"><item><description>
<c>dstOffset</c> must be less than the size of <c>dstBuffer</c>
</description></item><item><description>
<c>dstOffset</c> must be a multiple of <c>4</c>
</description></item><item><description>

If <c>size</c> is not equal to <c>VK_WHOLE_SIZE</c>, <c>size</c> must be
greater than <c>0</c>
</description></item><item><description>

If <c>size</c> is not equal to <c>VK_WHOLE_SIZE</c>, <c>size</c> must be
less than or equal to the size of <c>dstBuffer</c> minus <c>dstOffset</c>
</description></item><item><description>

If <c>size</c> is not equal to <c>VK_WHOLE_SIZE</c>, <c>size</c> must be a
multiple of <c>4</c>
</description></item><item><description>
<c>dstBuffer</c> must have been created with
<c>VK_BUFFER_USAGE_TRANSFER_DST_BIT</c> usage flag
</description></item><item><description>

The <c>VkCommandPool</c> that <c>commandBuffer</c> was allocated from
 must support graphics or compute operations
</description></item><item><description>

If <c>dstBuffer</c> is non-sparse then it  must be bound completely and
contiguously to a single <c>VkDeviceMemory</c> object
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>commandBuffer</c> must be a valid <c>VkCommandBuffer</c> handle
</description></item><item><description>
<c>dstBuffer</c> must be a valid <c>VkBuffer</c> handle
</description></item><item><description>
<c>commandBuffer</c> must be in the  recording state
</description></item><item><description>
 The <c>VkCommandPool</c> that <c>commandBuffer</c> was allocated from  must support graphics or compute operations
</description></item><item><description>
 This command  must only be called outside of a render pass instance
</description></item><item><description>
 Both of <c>commandBuffer</c>, and <c>dstBuffer</c> must have been created, allocated, or retrieved from the same <c>VkDevice</c>
</description></item></list>




Host Synchronization
<list type="bullet"><item><description>
Host access to <c>commandBuffer</c> must  be externally synchronized
</description></item><item><description>
Host access to the <c>VkCommandPool</c> that <c>commandBuffer</c> was allocated from  must be externally synchronized
</description></item></list>




Command Properties
<list type="table">       <listheader><tr><term> Command Buffer Levels </term><term> Render Pass Scope </term><term> Supported Queue Types </term><term> Pipeline Type </term></tr></listheader>
<item><term>
Primary<br />
Secondary
</term><term>
Outside
</term><term>
Graphics<br />
Compute
</term><term>
Transfer
</term></item>
</list>



To clear buffer data, call:


<code> void vkCmdFillBuffer(
    VkCommandBuffer                             commandBuffer,
    VkBuffer                                    dstBuffer,
    VkDeviceSize                                dstOffset,
    VkDeviceSize                                size,
    uint32_t                                    data); </code>

</remarks>
      <seealso cref="T:VkBuffer" />
      <seealso cref="T:VkCommandBuffer" />
    </member>
    <member name="T:IVkDeviceGroupCommandBufferBeginInfoKHX" />
    <member name="T:VkDeviceGroupCommandBufferBeginInfoKHX32">
      <summary>See: <see cref="T:IVkDeviceGroupCommandBufferBeginInfoKHX" /></summary>
      <seealso cref="T:IVkDeviceGroupCommandBufferBeginInfoKHX" />
    </member>
    <member name="T:VkDeviceGroupCommandBufferBeginInfoKHX64">
      <summary>See: <see cref="T:IVkDeviceGroupCommandBufferBeginInfoKHX" /></summary>
      <seealso cref="T:IVkDeviceGroupCommandBufferBeginInfoKHX" />
    </member>
    <member name="T:IVkTextureLODGatherFormatPropertiesAMD" />
    <member name="T:VkTextureLODGatherFormatPropertiesAMD32">
      <summary>See: <see cref="T:IVkTextureLODGatherFormatPropertiesAMD" /></summary>
      <seealso cref="T:IVkTextureLODGatherFormatPropertiesAMD" />
    </member>
    <member name="T:VkTextureLODGatherFormatPropertiesAMD64">
      <summary>See: <see cref="T:IVkTextureLODGatherFormatPropertiesAMD" /></summary>
      <seealso cref="T:IVkTextureLODGatherFormatPropertiesAMD" />
    </member>
    <member name="T:vkFreeCommandBuffers">
      <summary>Free command buffers</summary>
      <remarks>

Any primary command buffer that is in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#commandbuffers-lifecycle">recording or executable state</a> and has any element of <c>pCommandBuffers</c>
recorded into it, becomes <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#commandbuffers-lifecycle">invalid</a>.



Valid Usage
<list type="bullet"><item><description>

All elements of <c>pCommandBuffers</c> must not be in the
<a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#commandbuffers-lifecycle">pending state</a>
</description></item><item><description>
<c>pCommandBuffers</c> must be a pointer to an array of
<c>commandBufferCount</c><c>VkCommandBuffer</c> handles, each element of
which  must either be a valid handle or <c>NULL</c>
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>device</c> must be a valid <c>VkDevice</c> handle
</description></item><item><description>
<c>commandPool</c> must be a valid <c>VkCommandPool</c> handle
</description></item><item><description>
<c>commandBufferCount</c> must be greater than <c>0</c>
</description></item><item><description>
<c>commandPool</c> must have been created, allocated, or retrieved from <c>device</c>
</description></item><item><description>
 Each element of <c>pCommandBuffers</c> that is a valid handle  must have been created, allocated, or retrieved from <c>commandPool</c>
</description></item></list>




Host Synchronization
<list type="bullet"><item><description>
Host access to <c>commandPool</c> must  be externally synchronized
</description></item><item><description>
Host access to each member of <c>pCommandBuffers</c> must  be externally synchronized
</description></item></list>




To free command buffers, call:


<code> void vkFreeCommandBuffers(
    VkDevice                                    device,
    VkCommandPool                               commandPool,
    uint32_t                                    commandBufferCount,
    const VkCommandBuffer*                      pCommandBuffers); </code>

</remarks>
      <seealso cref="T:VkCommandBuffer" />
      <seealso cref="T:VkCommandPool" />
      <seealso cref="T:VkDevice" />
    </member>
    <member name="T:IVkMemoryAllocateFlagsInfoKHX" />
    <member name="T:VkMemoryAllocateFlagsInfoKHX32">
      <summary>See: <see cref="T:IVkMemoryAllocateFlagsInfoKHX" /></summary>
      <seealso cref="T:IVkMemoryAllocateFlagsInfoKHX" />
    </member>
    <member name="T:VkMemoryAllocateFlagsInfoKHX64">
      <summary>See: <see cref="T:IVkMemoryAllocateFlagsInfoKHX" /></summary>
      <seealso cref="T:IVkMemoryAllocateFlagsInfoKHX" />
    </member>
    <member name="T:VkObjectTableDescriptorSetEntryNVX" />
    <member name="T:vkCmdDispatch">
      <summary>Dispatch compute work items</summary>
      <remarks>

When the command is executed, a global workgroup consisting of
 groupCountX × groupCountY × groupCountZ local workgroups
is assembled.



Valid Usage
<list type="bullet"><item><description>
<c>groupCountX</c> must be less than or equal to
<c>VkPhysicalDeviceLimits</c>::<c>maxComputeWorkGroupCount</c>[0]
</description></item><item><description>
<c>groupCountY</c> must be less than or equal to
<c>VkPhysicalDeviceLimits</c>::<c>maxComputeWorkGroupCount</c>[1]
</description></item><item><description>
<c>groupCountZ</c> must be less than or equal to
<c>VkPhysicalDeviceLimits</c>::<c>maxComputeWorkGroupCount</c>[2]
</description></item><item><description>

For each set  n that is statically used by the <c>VkPipeline</c>
currently bound to <c>VK_PIPELINE_BIND_POINT_COMPUTE</c>, a descriptor
set  must have been bound to  n at
<c>VK_PIPELINE_BIND_POINT_COMPUTE</c>, with a <c>VkPipelineLayout</c> that
is compatible for set  n, with the <c>VkPipelineLayout</c> used to
create the current <c>VkPipeline</c>, as described in
<a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#descriptorsets-compatibility">../../html/vkspec.html#descriptorsets-compatibility</a>
</description></item><item><description>

Descriptors in each bound descriptor set, specified via
<c>vkCmdBindDescriptorSets</c>,  must be valid if they are statically
used by the currently bound <c>VkPipeline</c> object, specified via
<c>vkCmdBindPipeline</c>
</description></item><item><description>

A valid compute pipeline  must be bound to the current command buffer
with <c>VK_PIPELINE_BIND_POINT_COMPUTE</c>
</description></item><item><description>

For each push constant that is statically used by the <c>VkPipeline</c>
currently bound to <c>VK_PIPELINE_BIND_POINT_COMPUTE</c>, a push constant
value  must have been set for <c>VK_PIPELINE_BIND_POINT_COMPUTE</c>, with
a <c>VkPipelineLayout</c> that is compatible for push constants with the
one used to create the current <c>VkPipeline</c>, as described in
<a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#descriptorsets-compatibility">../../html/vkspec.html#descriptorsets-compatibility</a>
</description></item><item><description>

If any <c>VkSampler</c> object that is accessed from a shader by the
<c>VkPipeline</c> currently bound to <c>VK_PIPELINE_BIND_POINT_COMPUTE</c>
uses unnormalized coordinates, it  must not be used to sample from any
<c>VkImage</c> with a <c>VkImageView</c> of the type
<c>VK_IMAGE_VIEW_TYPE_3D</c>, <c>VK_IMAGE_VIEW_TYPE_CUBE</c>,
<c>VK_IMAGE_VIEW_TYPE_1D_ARRAY</c>, <c>VK_IMAGE_VIEW_TYPE_2D_ARRAY</c> or
<c>VK_IMAGE_VIEW_TYPE_CUBE_ARRAY</c>, in any shader stage
</description></item><item><description>

If any <c>VkSampler</c> object that is accessed from a shader by the
<c>VkPipeline</c> currently bound to <c>VK_PIPELINE_BIND_POINT_COMPUTE</c>
uses unnormalized coordinates, it  must not be used with any of the
SPIR-V <c>OpImageSample*</c> or <c>OpImageSparseSample*</c> instructions with
<c>ImplicitLod</c>, <c>Dref</c> or <c>Proj</c> in their name, in any shader
stage
</description></item><item><description>

If any <c>VkSampler</c> object that is accessed from a shader by the
<c>VkPipeline</c> currently bound to <c>VK_PIPELINE_BIND_POINT_COMPUTE</c>
uses unnormalized coordinates, it  must not be used with any of the
SPIR-V <c>OpImageSample*</c> or <c>OpImageSparseSample*</c> instructions that
includes a LOD bias or any offset values, in any shader stage
</description></item><item><description>

If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-robustBufferAccess">robust buffer access</a>
feature is not enabled, and any shader stage in the <c>VkPipeline</c>
object currently bound to <c>VK_PIPELINE_BIND_POINT_COMPUTE</c> accesses
a uniform buffer, it  must not access values outside of the range of
that buffer specified in the currently bound descriptor set
</description></item><item><description>

If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-robustBufferAccess">robust buffer access</a>
feature is not enabled, and any shader stage in the <c>VkPipeline</c>
object currently bound to <c>VK_PIPELINE_BIND_POINT_COMPUTE</c> accesses
a storage buffer, it  must not access values outside of the range of
that buffer specified in the currently bound descriptor set
</description></item><item><description>

Any <c>VkImageView</c> being sampled with <c>VK_FILTER_LINEAR</c> as a
result of this command  must be of a format which supports linear
filtering, as specified by the
<c>VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT</c> flag in
<c>VkFormatProperties</c>::<c>linearTilingFeatures</c> (for a linear
image) or <c>VkFormatProperties</c>::<c>optimalTilingFeatures</c>(for an
optimally tiled image) returned by
<c>vkGetPhysicalDeviceFormatProperties</c>
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>commandBuffer</c> must be a valid <c>VkCommandBuffer</c> handle
</description></item><item><description>
<c>commandBuffer</c> must be in the  recording state
</description></item><item><description>
 The <c>VkCommandPool</c> that <c>commandBuffer</c> was allocated from  must support compute operations
</description></item><item><description>
 This command  must only be called outside of a render pass instance
</description></item></list>




Host Synchronization
<list type="bullet"><item><description>
Host access to <c>commandBuffer</c> must  be externally synchronized
</description></item><item><description>
Host access to the <c>VkCommandPool</c> that <c>commandBuffer</c> was allocated from  must be externally synchronized
</description></item></list>




Command Properties
<list type="table">       <listheader><tr><term> Command Buffer Levels </term><term> Render Pass Scope </term><term> Supported Queue Types </term><term> Pipeline Type </term></tr></listheader>
<item><term>
Primary<br />
Secondary
</term><term>
Outside
</term><term>
Compute
</term><term>
Compute
</term></item>
</list>



To record a dispatch, call:


<code> void vkCmdDispatch(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    groupCountX,
    uint32_t                                    groupCountY,
    uint32_t                                    groupCountZ); </code>

</remarks>
      <seealso cref="T:VkCommandBuffer" />
    </member>
    <member name="T:IVkDescriptorSetLayoutBinding">
      <summary>Structure specifying a descriptor set layout binding</summary>
      <remarks>
<list type="bullet"><item><description>
<c>pImmutableSamplers</c> affects initialization of samplers.
If <c>descriptorType</c> specifies a <c>VK_DESCRIPTOR_TYPE_SAMPLER</c> or
<c>VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER</c> type descriptor, then
<c>pImmutableSamplers</c> can be used to initialize a set of  immutable
samplers.
Immutable samplers are permanently bound into the set layout; later
binding a sampler into an immutable sampler slot in a descriptor set is
not allowed.
If <c>pImmutableSamplers</c> is not <c>NULL</c>, then it is considered to be a
pointer to an array of sampler handles that will be consumed by the set
layout and used for the corresponding binding.
If <c>pImmutableSamplers</c> is <c>NULL</c>, then the sampler slots are
dynamic and sampler handles  must be bound into descriptor sets using
this layout.
If <c>descriptorType</c> is not one of these descriptor types, then
<c>pImmutableSamplers</c> is ignored.
</description></item></list>

The above layout definition allows the descriptor bindings to be specified
sparsely such that not all binding numbers between 0 and the maximum binding
number need to be specified in the <c>pBindings</c> array.
Bindings that are not specified have a <c>descriptorCount</c> and
<c>stageFlags</c> of zero, and the <c>descriptorType</c> is treated as
undefined.
However, all binding numbers between 0 and the maximum binding number in the
<see cref="T:IVkDescriptorSetLayoutCreateInfo" />::<c>pBindings</c> array  may consume
memory in the descriptor set layout even if not all descriptor bindings are
used, though it  should not consume additional memory from the descriptor
pool.

<list type="table"><tr><td><i title="Note"></i></td><td>
Note

The maximum binding number specified  should be as compact as possible to
avoid wasted memory.

</td></tr></list>


Valid Usage
<list type="bullet"><item><description>

If <c>descriptorType</c> is <c>VK_DESCRIPTOR_TYPE_SAMPLER</c> or
<c>VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER</c>, and
<c>descriptorCount</c> is not <c>0</c> and <c>pImmutableSamplers</c> is not
<c>NULL</c>, <c>pImmutableSamplers</c> must be a pointer to an array of
<c>descriptorCount</c> valid <c>VkSampler</c> handles
</description></item><item><description>

If <c>descriptorCount</c> is not <c>0</c>, <c>stageFlags</c> must be a valid
combination of <see cref="T:VkShaderStageFlags" /> values
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>descriptorType</c> must be a valid <see cref="T:VkDescriptorType" /> value
</description></item></list>




The <c>VkDescriptorSetLayoutBinding</c> structure is defined as:


<code> typedef struct VkDescriptorSetLayoutBinding {
    uint32_t              binding;
    VkDescriptorType      descriptorType;
    uint32_t              descriptorCount;
    VkShaderStageFlags    stageFlags;
    const VkSampler*      pImmutableSamplers;
} VkDescriptorSetLayoutBinding; </code>

</remarks>
      <seealso cref="T:IVkDescriptorSetLayoutCreateInfo" />
      <seealso cref="T:VkDescriptorType" />
      <seealso cref="T:VkSampler" />
      <seealso cref="T:VkShaderStageFlags" />
    </member>
    <member name="T:VkDescriptorSetLayoutBinding32">
      <summary>See: <see cref="T:IVkDescriptorSetLayoutBinding" /></summary>
      <seealso cref="T:IVkDescriptorSetLayoutBinding" />
    </member>
    <member name="T:VkDescriptorSetLayoutBinding64">
      <summary>See: <see cref="T:IVkDescriptorSetLayoutBinding" /></summary>
      <seealso cref="T:IVkDescriptorSetLayoutBinding" />
    </member>
    <member name="T:IVkDeviceGroupDeviceCreateInfoKHX" />
    <member name="T:VkDeviceGroupDeviceCreateInfoKHX32">
      <summary>See: <see cref="T:IVkDeviceGroupDeviceCreateInfoKHX" /></summary>
      <seealso cref="T:IVkDeviceGroupDeviceCreateInfoKHX" />
    </member>
    <member name="T:VkDeviceGroupDeviceCreateInfoKHX64">
      <summary>See: <see cref="T:IVkDeviceGroupDeviceCreateInfoKHX" /></summary>
      <seealso cref="T:IVkDeviceGroupDeviceCreateInfoKHX" />
    </member>
    <member name="T:IVkPipelineShaderStageCreateInfo">
      <summary>Structure specifying parameters of a newly created pipeline shader stage</summary>
      <remarks>


Valid Usage
<list type="bullet"><item><description>

If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-geometryShader">geometry shaders</a> feature is
not enabled, <c>stage</c> must not be <c>VK_SHADER_STAGE_GEOMETRY_BIT</c>
</description></item><item><description>

If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-tessellationShader">tessellation shaders</a>
feature is not enabled, <c>stage</c> must not be
<c>VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT</c> or
<c>VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT</c>
</description></item><item><description>
<c>stage</c> must not be <c>VK_SHADER_STAGE_ALL_GRAPHICS</c>, or
<c>VK_SHADER_STAGE_ALL</c>
</description></item><item><description>
<c>pName</c> must be the name of an <c>OpEntryPoint</c> in <c>module</c>
with an execution model that matches <c>stage</c>
</description></item><item><description>

If the identified entry point includes any variable in its interface
that is declared with the <c>ClipDistance</c><c>BuiltIn</c> decoration,
that variable  must not have an array size greater than
<c>VkPhysicalDeviceLimits</c>::<c>maxClipDistances</c>
</description></item><item><description>

If the identified entry point includes any variable in its interface
that is declared with the <c>CullDistance</c><c>BuiltIn</c> decoration,
that variable  must not have an array size greater than
<c>VkPhysicalDeviceLimits</c>::<c>maxCullDistances</c>
</description></item><item><description>

If the identified entry point includes any variables in its interface
that are declared with the <c>ClipDistance</c> or <c>CullDistance</c><c>BuiltIn</c> decoration, those variables  must not have array sizes
which sum to more than
<c>VkPhysicalDeviceLimits</c>::<c>maxCombinedClipAndCullDistances</c>
</description></item><item><description>

If the identified entry point includes any variable in its interface
that is declared with the <c>SampleMask</c><c>BuiltIn</c> decoration, that
variable  must not have an array size greater than
<c>VkPhysicalDeviceLimits</c>::<c>maxSampleMaskWords</c>
</description></item><item><description>

If <c>stage</c> is <c>VK_SHADER_STAGE_VERTEX_BIT</c>, the identified entry
point  must not include any input variable in its interface that is
decorated with <c>CullDistance</c>
</description></item><item><description>

If <c>stage</c> is <c>VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT</c> or
<c>VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT</c>, and the identified
entry point has an <c>OpExecutionMode</c> instruction that specifies a
patch size with <c>OutputVertices</c>, the patch size  must be greater
than <c>0</c> and less than or equal to
<c>VkPhysicalDeviceLimits</c>::<c>maxTessellationPatchSize</c>
</description></item><item><description>

If <c>stage</c> is <c>VK_SHADER_STAGE_GEOMETRY_BIT</c>, the identified
entry point  must have an <c>OpExecutionMode</c> instruction that
specifies a maximum output vertex count that is greater than <c>0</c> and
less than or equal to
<c>VkPhysicalDeviceLimits</c>::<c>maxGeometryOutputVertices</c>
</description></item><item><description>

If <c>stage</c> is <c>VK_SHADER_STAGE_GEOMETRY_BIT</c>, the identified
entry point  must have an <c>OpExecutionMode</c> instruction that
specifies an invocation count that is greater than <c>0</c> and less than or
equal to
<c>VkPhysicalDeviceLimits</c>::<c>maxGeometryShaderInvocations</c>
</description></item><item><description>

If <c>stage</c> is <c>VK_SHADER_STAGE_GEOMETRY_BIT</c>, and the identified
entry point writes to <c>Layer</c> for any primitive, it  must write the
same value to <c>Layer</c> for all vertices of a given primitive
</description></item><item><description>

If <c>stage</c> is <c>VK_SHADER_STAGE_GEOMETRY_BIT</c>, and the identified
entry point writes to <c>ViewportIndex</c> for any primitive, it  must
write the same value to <c>ViewportIndex</c> for all vertices of a given
primitive
</description></item><item><description>

If <c>stage</c> is <c>VK_SHADER_STAGE_FRAGMENT_BIT</c>, the identified
entry point  must not include any output variables in its interface
decorated with <c>CullDistance</c>
</description></item><item><description>

If <c>stage</c> is <c>VK_SHADER_STAGE_FRAGMENT_BIT</c>, and the identified
entry point writes to <c>FragDepth</c> in any execution path, it  must
write to <c>FragDepth</c> in all execution paths
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>sType</c> must be <c>VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO</c>
</description></item><item><description>
<c>pNext</c> must be <c>NULL</c>
</description></item><item><description>
<c>flags</c> must be <c>0</c>
</description></item><item><description>
<c>stage</c> must be a valid <see cref="T:VkShaderStageFlags" /> value
</description></item><item><description>
<c>module</c> must be a valid <c>VkShaderModule</c> handle
</description></item><item><description>
<c>pName</c> must  be a null-terminated UTF-8 string
</description></item><item><description>
 If <c>pSpecializationInfo</c> is not <c>NULL</c>, <c>pSpecializationInfo</c> must be a pointer to a valid <c>VkSpecializationInfo</c> structure
</description></item></list>




The <c>VkPipelineShaderStageCreateInfo</c> structure is defined as:


<code> typedef struct VkPipelineShaderStageCreateInfo {
    VkStructureType                     sType;
    const void*                         pNext;
    VkPipelineShaderStageCreateFlags    flags;
    VkShaderStageFlagBits               stage;
    VkShaderModule                      module;
    const char*                         pName;
    const VkSpecializationInfo*         pSpecializationInfo;
} VkPipelineShaderStageCreateInfo; </code>

</remarks>
      <seealso cref="T:IVkComputePipelineCreateInfo" />
      <seealso cref="T:IVkGraphicsPipelineCreateInfo" />
      <seealso cref="T:VkPipelineShaderStageCreateFlags" />
      <seealso cref="T:VkShaderModule" />
      <seealso cref="T:VkShaderStageFlags" />
      <seealso cref="T:IVkSpecializationInfo" />
      <seealso cref="T:VkStructureType" />
    </member>
    <member name="T:VkPipelineShaderStageCreateInfo32">
      <summary>See: <see cref="T:IVkPipelineShaderStageCreateInfo" /></summary>
      <seealso cref="T:IVkPipelineShaderStageCreateInfo" />
    </member>
    <member name="T:VkPipelineShaderStageCreateInfo64">
      <summary>See: <see cref="T:IVkPipelineShaderStageCreateInfo" /></summary>
      <seealso cref="T:IVkPipelineShaderStageCreateInfo" />
    </member>
    <member name="T:VkQueue">
      <summary>Opaque handle to a queue object</summary>
      <remarks>

Creating a logical device also creates the queues associated with that
device.
The queues to create are described by a set of <see cref="T:IVkDeviceQueueCreateInfo" />
structures that are passed to <see cref="T:vkCreateDevice" /> in
<c>pQueueCreateInfos</c>.


Queues are represented by <c>VkQueue</c> handles:


<code> VK_DEFINE_HANDLE(VkQueue) </code>

</remarks>
      <seealso cref="T:vkGetDeviceQueue" />
      <seealso cref="T:vkQueueBindSparse" />
      <seealso cref="T:vkQueueSubmit" />
      <seealso cref="T:vkQueueWaitIdle" />
    </member>
    <member name="T:vkCmdNextSubpass">
      <summary>Transition to the next subpass of a render pass</summary>
      <remarks>

The subpass index for a render pass begins at zero when
<c>vkCmdBeginRenderPass</c> is recorded, and increments each time
<c>vkCmdNextSubpass</c> is recorded.


Moving to the next subpass automatically performs any multisample resolve
operations in the subpass being ended.
End-of-subpass multisample resolves are treated as color attachment writes
for the purposes of synchronization.
That is, they are considered to execute in the
<c>VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT</c> pipeline stage and their
writes are synchronized with <c>VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT</c>.
Synchronization between rendering within a subpass and any resolve
operations at the end of the subpass occurs automatically, without need for
explicit dependencies or pipeline barriers.
However, if the resolve attachment is also used in a different subpass, an
explicit dependency is needed.


After transitioning to the next subpass, the application  can record the
commands for that subpass.



Valid Usage
<list type="bullet"><item><description>

The current subpass index  must be less than the number of subpasses in
the render pass minus one
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>commandBuffer</c> must be a valid <c>VkCommandBuffer</c> handle
</description></item><item><description>
<c>contents</c> must be a valid <see cref="T:VkSubpassContents" /> value
</description></item><item><description>
<c>commandBuffer</c> must be in the  recording state
</description></item><item><description>
 The <c>VkCommandPool</c> that <c>commandBuffer</c> was allocated from  must support graphics operations
</description></item><item><description>
 This command  must only be called inside of a render pass instance
</description></item><item><description>
<c>commandBuffer</c> must be a primary <c>VkCommandBuffer</c>
</description></item></list>




Host Synchronization
<list type="bullet"><item><description>
Host access to <c>commandBuffer</c> must  be externally synchronized
</description></item><item><description>
Host access to the <c>VkCommandPool</c> that <c>commandBuffer</c> was allocated from  must be externally synchronized
</description></item></list>




Command Properties
<list type="table">       <listheader><tr><term> Command Buffer Levels </term><term> Render Pass Scope </term><term> Supported Queue Types </term><term> Pipeline Type </term></tr></listheader>
<item><term>
Primary
</term><term>
Inside
</term><term>
Graphics
</term><term>
Graphics
</term></item>
</list>



To transition to the next subpass in the render pass instance after
recording the commands for a subpass, call:


<code> void vkCmdNextSubpass(
    VkCommandBuffer                             commandBuffer,
    VkSubpassContents                           contents); </code>

</remarks>
      <seealso cref="T:VkCommandBuffer" />
      <seealso cref="T:VkSubpassContents" />
    </member>
    <member name="T:vkGetPhysicalDeviceImageFormatProperties2KHR" />
    <member name="T:vkGetDeviceMemoryCommitment">
      <summary>Query the current commitment for a VkDeviceMemory</summary>
      <remarks>

The implementation  may update the commitment at any time, and the value
returned by this query  may be out of date.


The implementation guarantees to allocate any committed memory from the
heapIndex indicated by the memory type that the memory object was created
with.



Valid Usage
<list type="bullet"><item><description>
<c>memory</c> must have been created with a memory type that reports
<c>VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT</c>
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>device</c> must be a valid <c>VkDevice</c> handle
</description></item><item><description>
<c>memory</c> must be a valid <c>VkDeviceMemory</c> handle
</description></item><item><description>
<c>pCommittedMemoryInBytes</c> must be a pointer to a <c>VkDeviceSize</c> value
</description></item><item><description>
<c>memory</c> must have been created, allocated, or retrieved from <c>device</c>
</description></item></list>




To determine the amount of lazily-allocated memory that is currently
committed for a memory object, call:


<code> void vkGetDeviceMemoryCommitment(
    VkDevice                                    device,
    VkDeviceMemory                              memory,
    VkDeviceSize*                               pCommittedMemoryInBytes); </code>

</remarks>
      <seealso cref="T:VkDevice" />
      <seealso cref="T:VkDeviceMemory" />
    </member>
    <member name="T:vkCmdBeginQuery">
      <summary>Begin a query</summary>
      <remarks>

If the <c>queryType</c> of the pool is <c>VK_QUERY_TYPE_OCCLUSION</c> and
<c>flags</c> contains <c>VK_QUERY_CONTROL_PRECISE_BIT</c>, an implementation
 must return a result that matches the actual number of samples passed.
This is described in more detail in <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#queries-occlusion">Occlusion Queries</a>.


After beginning a query, that query is considered  active within the
command buffer it was called in until that same query is ended.
Queries active in a primary command buffer when secondary command buffers
are executed are considered active for those secondary command buffers.



Valid Usage
<list type="bullet"><item><description>

The query identified by <c>queryPool</c> and <c>query</c> must currently
not be <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#queries-operation-active">active</a>
</description></item><item><description>

The query identified by <c>queryPool</c> and <c>query</c> must  be
unavailable
</description></item><item><description>

If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-occlusionQueryPrecise">precise occlusion
queries</a> feature is not enabled, or the <c>queryType</c> used to create
<c>queryPool</c> was not <c>VK_QUERY_TYPE_OCCLUSION</c>, <c>flags</c> must
not contain <c>VK_QUERY_CONTROL_PRECISE_BIT</c>
</description></item><item><description>
<c>queryPool</c> must have been created with a <c>queryType</c> that
differs from that of any other queries that have been made
<a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#queries-operation-active">active</a>, and are currently still active
within <c>commandBuffer</c>
</description></item><item><description>
<c>query</c> must be less than the number of queries in <c>queryPool</c>
</description></item><item><description>

If the <c>queryType</c> used to create <c>queryPool</c> was
<c>VK_QUERY_TYPE_OCCLUSION</c>, the <c>VkCommandPool</c> that
<c>commandBuffer</c> was allocated from  must support graphics operations
</description></item><item><description>

If the <c>queryType</c> used to create <c>queryPool</c> was
<c>VK_QUERY_TYPE_PIPELINE_STATISTICS</c> and any of the
<c>pipelineStatistics</c> indicate graphics operations, the
<c>VkCommandPool</c> that <c>commandBuffer</c> was allocated from  must
support graphics operations
</description></item><item><description>

If the <c>queryType</c> used to create <c>queryPool</c> was
<c>VK_QUERY_TYPE_PIPELINE_STATISTICS</c> and any of the
<c>pipelineStatistics</c> indicate compute operations, the
<c>VkCommandPool</c> that <c>commandBuffer</c> was allocated from  must
support compute operations
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>commandBuffer</c> must be a valid <c>VkCommandBuffer</c> handle
</description></item><item><description>
<c>queryPool</c> must be a valid <c>VkQueryPool</c> handle
</description></item><item><description>
<c>flags</c> must be a valid combination of <see cref="T:VkQueryControlFlags" /> values
</description></item><item><description>
<c>commandBuffer</c> must be in the  recording state
</description></item><item><description>
 The <c>VkCommandPool</c> that <c>commandBuffer</c> was allocated from  must support graphics, or compute operations
</description></item><item><description>
 Both of <c>commandBuffer</c>, and <c>queryPool</c> must have been created, allocated, or retrieved from the same <c>VkDevice</c>
</description></item></list>




Host Synchronization
<list type="bullet"><item><description>
Host access to <c>commandBuffer</c> must  be externally synchronized
</description></item><item><description>
Host access to the <c>VkCommandPool</c> that <c>commandBuffer</c> was allocated from  must be externally synchronized
</description></item></list>




Command Properties
<list type="table">       <listheader><tr><term> Command Buffer Levels </term><term> Render Pass Scope </term><term> Supported Queue Types </term><term> Pipeline Type </term></tr></listheader>
<item><term>
Primary<br />
Secondary
</term><term>
Both
</term><term>
Graphics<br />
compute
</term><term></term></item>
</list>



To begin a query, call:


<code> void vkCmdBeginQuery(
    VkCommandBuffer                             commandBuffer,
    VkQueryPool                                 queryPool,
    uint32_t                                    query,
    VkQueryControlFlags                         flags); </code>

</remarks>
      <seealso cref="T:VkCommandBuffer" />
      <seealso cref="T:VkQueryControlFlags" />
      <seealso cref="T:VkQueryPool" />
    </member>
    <member name="T:vkDestroyDescriptorUpdateTemplateKHR" />
    <member name="T:IVkPhysicalDeviceSparseImageFormatInfo2KHR" />
    <member name="T:VkPhysicalDeviceSparseImageFormatInfo2KHR32">
      <summary>See: <see cref="T:IVkPhysicalDeviceSparseImageFormatInfo2KHR" /></summary>
      <seealso cref="T:IVkPhysicalDeviceSparseImageFormatInfo2KHR" />
    </member>
    <member name="T:VkPhysicalDeviceSparseImageFormatInfo2KHR64">
      <summary>See: <see cref="T:IVkPhysicalDeviceSparseImageFormatInfo2KHR" /></summary>
      <seealso cref="T:IVkPhysicalDeviceSparseImageFormatInfo2KHR" />
    </member>
    <member name="T:vkGetPhysicalDeviceSurfacePresentModesKHR" />
    <member name="T:vkGetMemoryFdKHX" />
    <member name="T:VkMemoryType">
      <summary>Structure specifying memory type</summary>
      <remarks>

The <c>VkMemoryType</c> structure is defined as:


<code> typedef struct VkMemoryType {
    VkMemoryPropertyFlags    propertyFlags;
    uint32_t                 heapIndex;
} VkMemoryType; </code>

</remarks>
      <seealso cref="T:VkMemoryPropertyFlags" />
      <seealso cref="T:VkPhysicalDeviceMemoryProperties" />
    </member>
    <member name="T:vkCreateDebugReportCallbackEXT" />
    <member name="T:PFN_vkInternalAllocationNotification">
      <summary>Application-defined memory allocation notification function</summary>
      <remarks>

This is a purely informational callback.



The type of <c>pfnInternalAllocation</c> is:


<code> typedef void (VKAPI_PTR *PFN_vkInternalAllocationNotification)(
    void*                                       pUserData,
    size_t                                      size,
    VkInternalAllocationType                    allocationType,
    VkSystemAllocationScope                     allocationScope); </code>

</remarks>
      <seealso cref="T:IVkAllocationCallbacks" />
    </member>
    <member name="T:vkGetImageMemoryRequirements">
      <summary>Returns the memory requirements for specified Vulkan object</summary>
      <remarks>


Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>device</c> must be a valid <c>VkDevice</c> handle
</description></item><item><description>
<c>image</c> must be a valid <c>VkImage</c> handle
</description></item><item><description>
<c>pMemoryRequirements</c> must be a pointer to a <c>VkMemoryRequirements</c> structure
</description></item><item><description>
<c>image</c> must have been created, allocated, or retrieved from <c>device</c>
</description></item></list>




To determine the memory requirements for an image resource, call:


<code> void vkGetImageMemoryRequirements(
    VkDevice                                    device,
    VkImage                                     image,
    VkMemoryRequirements*                       pMemoryRequirements); </code>

</remarks>
      <seealso cref="T:VkDevice" />
      <seealso cref="T:VkImage" />
      <seealso cref="T:VkMemoryRequirements" />
    </member>
    <member name="T:IVkSparseImageOpaqueMemoryBindInfo">
      <summary>Structure specifying sparse image opaque memory bind info</summary>
      <remarks>


Valid Usage
<list type="bullet"><item><description>

For any given element of <c>pBinds</c>, if the <c>flags</c> member of that
element contains <c>VK_SPARSE_MEMORY_BIND_METADATA_BIT</c>, the binding
range defined  must be within the mip tail region of the metadata aspect
of <c>image</c>
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>image</c> must be a valid <c>VkImage</c> handle
</description></item><item><description>
<c>pBinds</c> must be a pointer to an array of <c>bindCount</c> valid <c>VkSparseMemoryBind</c> structures
</description></item><item><description>
<c>bindCount</c> must be greater than <c>0</c>
</description></item></list>




Memory is bound to opaque regions of <c>VkImage</c> objects created with the
<c>VK_IMAGE_CREATE_SPARSE_BINDING_BIT</c> flag using the following structure:


<code> typedef struct VkSparseImageOpaqueMemoryBindInfo {
    VkImage                      image;
    uint32_t                     bindCount;
    const VkSparseMemoryBind*    pBinds;
} VkSparseImageOpaqueMemoryBindInfo; </code>

</remarks>
      <seealso cref="T:IVkBindSparseInfo" />
      <seealso cref="T:VkImage" />
      <seealso cref="T:VkSparseMemoryBind" />
    </member>
    <member name="T:VkSparseImageOpaqueMemoryBindInfo32">
      <summary>See: <see cref="T:IVkSparseImageOpaqueMemoryBindInfo" /></summary>
      <seealso cref="T:IVkSparseImageOpaqueMemoryBindInfo" />
    </member>
    <member name="T:VkSparseImageOpaqueMemoryBindInfo64">
      <summary>See: <see cref="T:IVkSparseImageOpaqueMemoryBindInfo" /></summary>
      <seealso cref="T:IVkSparseImageOpaqueMemoryBindInfo" />
    </member>
    <member name="T:vkCmdPipelineBarrier">
      <summary>Insert a memory dependency</summary>
      <remarks>

When <see cref="T:vkCmdPipelineBarrier" /> is submitted to a queue, it defines a memory
dependency between commands that were submitted before it, and those
submitted after it.


If <see cref="T:vkCmdPipelineBarrier" /> was recorded outside a render pass instance,
the first <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-dependencies-scopes">synchronization scope</a>
includes every command submitted to the same queue before it, including
those in the same command buffer and batch.
If <see cref="T:vkCmdPipelineBarrier" /> was recorded inside a render pass instance,
the first synchronization scope includes only commands submitted before it
within the same subpass.
In either case, the first synchronization scope is limited to operations on
the pipeline stages determined by the
<a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-pipeline-stages-masks">source stage mask</a> specified by
<c>srcStageMask</c>.


If <see cref="T:vkCmdPipelineBarrier" /> was recorded outside a render pass instance,
the second <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-dependencies-scopes">synchronization scope</a>
includes every command submitted to the same queue after it, including those
in the same command buffer and batch.
If <see cref="T:vkCmdPipelineBarrier" /> was recorded inside a render pass instance,
the second synchronization scope includes only commands submitted after it
within the same subpass.
In either case, the second synchronization scope is limited to operations on
the pipeline stages determined by the
<a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-pipeline-stages-masks">destination stage mask</a> specified
by <c>dstStageMask</c>.


The first <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-dependencies-access-scopes">access scope</a> is
limited to access in the pipeline stages determined by the
<a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-pipeline-stages-masks">source stage mask</a> specified by
<c>srcStageMask</c>.
Within that, the first access scope only includes the first access scopes
defined by elements of the <c>pMemoryBarriers</c>,
<c>pBufferMemoryBarriers</c> and <c>pImageMemoryBarriers</c> arrays, which
each define a set of <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-memory-barriers">memory barriers</a>.
If no memory barriers are specified, then the first access scope includes no
accesses.


The second <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-dependencies-access-scopes">access scope</a> is
limited to access in the pipeline stages determined by the
<a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-pipeline-stages-masks">destination stage mask</a> specified
by <c>dstStageMask</c>.
Within that, the second access scope only includes the second access scopes
defined by elements of the <c>pMemoryBarriers</c>,
<c>pBufferMemoryBarriers</c> and <c>pImageMemoryBarriers</c> arrays, which
each define a set of <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-memory-barriers">memory barriers</a>.
If no memory barriers are specified, then the second access scope includes
no accesses.


If <c>dependencyFlags</c> includes <c>VK_DEPENDENCY_BY_REGION_BIT</c>, then
any dependency between <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-framebuffer-regions">framebuffer-space</a> pipeline stages is
<a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-framebuffer-regions">framebuffer-local</a> - otherwise it is
<a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-framebuffer-regions">framebuffer-global</a>.



Valid Usage
<list type="bullet"><item><description>

If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-geometryShader">geometry shaders</a> feature is
not enabled, <c>srcStageMask</c> must not contain
<c>VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT</c>
</description></item><item><description>

If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-geometryShader">geometry shaders</a> feature is
not enabled, <c>dstStageMask</c> must not contain
<c>VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT</c>
</description></item><item><description>

If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-tessellationShader">tessellation shaders</a>
feature is not enabled, <c>srcStageMask</c> must not contain
<c>VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT</c> or
<c>VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT</c>
</description></item><item><description>

If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-tessellationShader">tessellation shaders</a>
feature is not enabled, <c>dstStageMask</c> must not contain
<c>VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT</c> or
<c>VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT</c>
</description></item><item><description>

If <c>vkCmdPipelineBarrier</c> is called within a render pass instance,
the render pass  must have been created with a <c>VkSubpassDependency</c>
instance in <c>pDependencies</c> that expresses a dependency from the
current subpass to itself.
</description></item><item><description>

If <c>vkCmdPipelineBarrier</c> is called within a render pass instance,
<c>srcStageMask</c> must contain a subset of the bit values in the
<c>srcStageMask</c> member of that instance of <c>VkSubpassDependency</c>
</description></item><item><description>

If <c>vkCmdPipelineBarrier</c> is called within a render pass instance,
<c>dstStageMask</c> must contain a subset of the bit values in the
<c>dstStageMask</c> member of that instance of <c>VkSubpassDependency</c>
</description></item><item><description>

If <c>vkCmdPipelineBarrier</c> is called within a render pass instance,
the <c>srcAccessMask</c> of any element of <c>pMemoryBarriers</c> or
<c>pImageMemoryBarriers</c> must contain a subset of the bit values the
<c>srcAccessMask</c> member of that instance of <c>VkSubpassDependency</c>
</description></item><item><description>

If <c>vkCmdPipelineBarrier</c> is called within a render pass instance,
the <c>dstAccessMask</c> of any element of <c>pMemoryBarriers</c> or
<c>pImageMemoryBarriers</c> must contain a subset of the bit values the
<c>dstAccessMask</c> member of that instance of <c>VkSubpassDependency</c>
</description></item><item><description>

If <c>vkCmdPipelineBarrier</c> is called within a render pass instance,
<c>dependencyFlags</c> must be equal to the <c>dependencyFlags</c> member
of that instance of <c>VkSubpassDependency</c>
</description></item><item><description>

If <c>vkCmdPipelineBarrier</c> is called within a render pass instance,
<c>bufferMemoryBarrierCount</c> must be <c>0</c>
</description></item><item><description>

If <c>vkCmdPipelineBarrier</c> is called within a render pass instance,
the <c>image</c> member of any element of <c>pImageMemoryBarriers</c> must be equal to one of the elements of <c>pAttachments</c> that the
current <c>framebuffer</c> was created with, that is also referred to by
one of the elements of the <c>pColorAttachments</c>,
<c>pResolveAttachments</c> or <c>pDepthStencilAttachment</c> members of
the <c>VkSubpassDescription</c> instance that the current subpass was
created with
</description></item><item><description>

If <c>vkCmdPipelineBarrier</c> is called within a render pass instance,
the <c>oldLayout</c> and <c>newLayout</c> members of any element of
<c>pImageMemoryBarriers</c> must be equal to the <c>layout</c> member of
an element of the <c>pColorAttachments</c>, <c>pResolveAttachments</c> or
<c>pDepthStencilAttachment</c> members of the <c>VkSubpassDescription</c>
instance that the current subpass was created with, that refers to the
same <c>image</c>
</description></item><item><description>

If <c>vkCmdPipelineBarrier</c> is called within a render pass instance,
the <c>oldLayout</c> and <c>newLayout</c> members of an element of
<c>pImageMemoryBarriers</c> must  be equal
</description></item><item><description>

If <c>vkCmdPipelineBarrier</c> is called within a render pass instance,
the <c>srcQueueFamilyIndex</c> and <c>dstQueueFamilyIndex</c> members of
any element of <c>pImageMemoryBarriers</c> must be
<c>VK_QUEUE_FAMILY_IGNORED</c>
</description></item><item><description>

Any pipeline stage included in <c>srcStageMask</c> or <c>dstStageMask</c> must be supported by the capabilities of the queue family specified by
the <c>queueFamilyIndex</c> member of the <see cref="T:IVkCommandPoolCreateInfo" />
structure that was used to create the <c>VkCommandPool</c> that
<c>commandBuffer</c> was allocated from, as specified in the
<a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-pipeline-stages-supported">table of supported pipeline
stages</a>.
</description></item><item><description>

Any given element of <c>pMemoryBarriers</c>, <c>pBufferMemoryBarriers</c>
or <c>pImageMemoryBarriers</c> must not have any access flag included in
its <c>srcAccessMask</c> member if that bit is not supported by any of
the pipeline stages in <c>srcStageMask</c>, as specified in the
<a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-access-types-supported">table of supported access
types</a>.
</description></item><item><description>

Any given element of <c>pMemoryBarriers</c>, <c>pBufferMemoryBarriers</c>
or <c>pImageMemoryBarriers</c> must not have any access flag included in
its <c>dstAccessMask</c> member if that bit is not supported by any of
the pipeline stages in <c>dstStageMask</c>, as specified in the
<a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-access-types-supported">table of supported access
types</a>.
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>commandBuffer</c> must be a valid <c>VkCommandBuffer</c> handle
</description></item><item><description>
<c>srcStageMask</c> must be a valid combination of <see cref="T:VkPipelineStageFlags" /> values
</description></item><item><description>
<c>srcStageMask</c> must not be <c>0</c>
</description></item><item><description>
<c>dstStageMask</c> must be a valid combination of <see cref="T:VkPipelineStageFlags" /> values
</description></item><item><description>
<c>dstStageMask</c> must not be <c>0</c>
</description></item><item><description>
<c>dependencyFlags</c> must be a valid combination of <see cref="T:VkDependencyFlags" /> values
</description></item><item><description>
 If <c>memoryBarrierCount</c> is not <c>0</c>, <c>pMemoryBarriers</c> must be a pointer to an array of <c>memoryBarrierCount</c> valid <c>VkMemoryBarrier</c> structures
</description></item><item><description>
 If <c>bufferMemoryBarrierCount</c> is not <c>0</c>, <c>pBufferMemoryBarriers</c> must be a pointer to an array of <c>bufferMemoryBarrierCount</c> valid <c>VkBufferMemoryBarrier</c> structures
</description></item><item><description>
 If <c>imageMemoryBarrierCount</c> is not <c>0</c>, <c>pImageMemoryBarriers</c> must be a pointer to an array of <c>imageMemoryBarrierCount</c> valid <c>VkImageMemoryBarrier</c> structures
</description></item><item><description>
<c>commandBuffer</c> must be in the  recording state
</description></item><item><description>
 The <c>VkCommandPool</c> that <c>commandBuffer</c> was allocated from  must support transfer, graphics, or compute operations
</description></item></list>




Host Synchronization
<list type="bullet"><item><description>
Host access to <c>commandBuffer</c> must  be externally synchronized
</description></item><item><description>
Host access to the <c>VkCommandPool</c> that <c>commandBuffer</c> was allocated from  must be externally synchronized
</description></item></list>




Command Properties
<list type="table">       <listheader><tr><term> Command Buffer Levels </term><term> Render Pass Scope </term><term> Supported Queue Types </term><term> Pipeline Type </term></tr></listheader>
<item><term>
Primary<br />
Secondary
</term><term>
Both
</term><term>
Transfer<br />
graphics<br />
compute
</term><term></term></item>
</list>



To record a pipeline barrier, call:


<code> void vkCmdPipelineBarrier(
    VkCommandBuffer                             commandBuffer,
    VkPipelineStageFlags                        srcStageMask,
    VkPipelineStageFlags                        dstStageMask,
    VkDependencyFlags                           dependencyFlags,
    uint32_t                                    memoryBarrierCount,
    const VkMemoryBarrier*                      pMemoryBarriers,
    uint32_t                                    bufferMemoryBarrierCount,
    const VkBufferMemoryBarrier*                pBufferMemoryBarriers,
    uint32_t                                    imageMemoryBarrierCount,
    const VkImageMemoryBarrier*                 pImageMemoryBarriers); </code>

</remarks>
      <seealso cref="T:IVkBufferMemoryBarrier" />
      <seealso cref="T:VkCommandBuffer" />
      <seealso cref="T:VkDependencyFlags" />
      <seealso cref="T:IVkImageMemoryBarrier" />
      <seealso cref="T:IVkMemoryBarrier" />
      <seealso cref="T:VkPipelineStageFlags" />
    </member>
    <member name="T:vkGetPhysicalDeviceSparseImageFormatProperties2KHR" />
    <member name="T:IVkMemoryFdPropertiesKHX" />
    <member name="T:VkMemoryFdPropertiesKHX32">
      <summary>See: <see cref="T:IVkMemoryFdPropertiesKHX" /></summary>
      <seealso cref="T:IVkMemoryFdPropertiesKHX" />
    </member>
    <member name="T:VkMemoryFdPropertiesKHX64">
      <summary>See: <see cref="T:IVkMemoryFdPropertiesKHX" /></summary>
      <seealso cref="T:IVkMemoryFdPropertiesKHX" />
    </member>
    <member name="T:vkCreateDescriptorPool">
      <summary>Creates a descriptor pool object</summary>
      <remarks>

<c>pAllocator</c> controls host memory allocation as described in the
<a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#memory-allocation">Memory Allocation</a> chapter.


The created descriptor pool is returned in <c>pDescriptorPool</c>.



Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>device</c> must be a valid <c>VkDevice</c> handle
</description></item><item><description>
<c>pCreateInfo</c> must be a pointer to a valid <c>VkDescriptorPoolCreateInfo</c> structure
</description></item><item><description>
 If <c>pAllocator</c> is not <c>NULL</c>, <c>pAllocator</c> must be a pointer to a valid <c>VkAllocationCallbacks</c> structure
</description></item><item><description>
<c>pDescriptorPool</c> must be a pointer to a <c>VkDescriptorPool</c> handle
</description></item></list>




Return Codes
<dl><dt>On success, this command returns</dt><dd>
<list type="bullet"><item><description>
<c>VK_SUCCESS</c>
</description></item></list>
</dd><dt>On failure, this command returns</dt><dd>
<list type="bullet"><item><description>
<c>VK_ERROR_OUT_OF_HOST_MEMORY</c>
</description></item><item><description>
<c>VK_ERROR_OUT_OF_DEVICE_MEMORY</c>
</description></item></list>
</dd></dl>




To create a descriptor pool object, call:


<code> VkResult vkCreateDescriptorPool(
    VkDevice                                    device,
    const VkDescriptorPoolCreateInfo*           pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkDescriptorPool*                           pDescriptorPool); </code>

</remarks>
      <seealso cref="T:IVkAllocationCallbacks" />
      <seealso cref="T:VkDescriptorPool" />
      <seealso cref="T:IVkDescriptorPoolCreateInfo" />
      <seealso cref="T:VkDevice" />
    </member>
    <member name="T:vkEnumerateInstanceLayerProperties">
      <summary>Returns up to requested number of global layer properties</summary>
      <remarks>

If <c>pProperties</c> is <c>NULL</c>, then the number of layer properties
available is returned in <c>pPropertyCount</c>.
Otherwise, <c>pPropertyCount</c> must point to a variable set by the user to
the number of elements in the <c>pProperties</c> array, and on return the
variable is overwritten with the number of structures actually written to
<c>pProperties</c>.
If <c>pPropertyCount</c> is less than the number of layer properties
available, at most <c>pPropertyCount</c> structures will be written.
If <c>pPropertyCount</c> is smaller than the number of layers available,
<c>VK_INCOMPLETE</c> will be returned instead of <c>VK_SUCCESS</c>, to
indicate that not all the available layer properties were returned.


The list of available layers may change at any time due to actions outside
of the Vulkan implementation, so two calls to
<c>vkEnumerateInstanceLayerProperties</c> with the same parameters  may
return different results, or retrieve different <c>pPropertyCount</c> values
or <c>pProperties</c> contents.
Once an instance has been created, the layers enabled for that instance will
continue to be enabled and valid for the lifetime of that instance, even if
some of them become unavailable for future instances.



Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>pPropertyCount</c> must be a pointer to a <c>uint32_t</c> value
</description></item><item><description>
 If the value referenced by <c>pPropertyCount</c> is not <c>0</c>, and <c>pProperties</c> is not <c>NULL</c>, <c>pProperties</c> must be a pointer to an array of <c>pPropertyCount</c><c>VkLayerProperties</c> structures
</description></item></list>




Return Codes
<dl><dt>On success, this command returns</dt><dd>
<list type="bullet"><item><description>
<c>VK_SUCCESS</c>
</description></item><item><description>
<c>VK_INCOMPLETE</c>
</description></item></list>
</dd><dt>On failure, this command returns</dt><dd>
<list type="bullet"><item><description>
<c>VK_ERROR_OUT_OF_HOST_MEMORY</c>
</description></item><item><description>
<c>VK_ERROR_OUT_OF_DEVICE_MEMORY</c>
</description></item></list>
</dd></dl>




To query the available layers, call:


<code> VkResult vkEnumerateInstanceLayerProperties(
    uint32_t*                                   pPropertyCount,
    VkLayerProperties*                          pProperties); </code>

</remarks>
      <seealso cref="T:VkLayerProperties" />
    </member>
    <member name="T:PFN_vkDebugReportCallbackEXT" />
    <member name="T:IVkQueryPoolCreateInfo">
      <summary>Structure specifying parameters of a newly created query pool</summary>
      <remarks>

<c>pipelineStatistics</c> is ignored if <c>queryType</c> is not
<c>VK_QUERY_TYPE_PIPELINE_STATISTICS</c>.



Valid Usage
<list type="bullet"><item><description>

If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-pipelineStatisticsQuery">pipeline statistics
queries</a> feature is not enabled, <c>queryType</c> must not be
<c>VK_QUERY_TYPE_PIPELINE_STATISTICS</c>
</description></item><item><description>

If <c>queryType</c> is <c>VK_QUERY_TYPE_PIPELINE_STATISTICS</c>,
<c>pipelineStatistics</c> must be a valid combination of
<see cref="T:VkQueryPipelineStatisticFlags" /> values
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>sType</c> must be <c>VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO</c>
</description></item><item><description>
<c>pNext</c> must be <c>NULL</c>
</description></item><item><description>
<c>flags</c> must be <c>0</c>
</description></item><item><description>
<c>queryType</c> must be a valid <see cref="T:VkQueryType" /> value
</description></item></list>




The <c>VkQueryPoolCreateInfo</c> structure is defined as:


<code> typedef struct VkQueryPoolCreateInfo {
    VkStructureType                  sType;
    const void*                      pNext;
    VkQueryPoolCreateFlags           flags;
    VkQueryType                      queryType;
    uint32_t                         queryCount;
    VkQueryPipelineStatisticFlags    pipelineStatistics;
} VkQueryPoolCreateInfo; </code>

</remarks>
      <seealso cref="T:VkQueryPipelineStatisticFlags" />
      <seealso cref="T:VkQueryPoolCreateFlags" />
      <seealso cref="T:VkQueryType" />
      <seealso cref="T:VkStructureType" />
      <seealso cref="T:vkCreateQueryPool" />
    </member>
    <member name="T:VkQueryPoolCreateInfo32">
      <summary>See: <see cref="T:IVkQueryPoolCreateInfo" /></summary>
      <seealso cref="T:IVkQueryPoolCreateInfo" />
    </member>
    <member name="T:VkQueryPoolCreateInfo64">
      <summary>See: <see cref="T:IVkQueryPoolCreateInfo" /></summary>
      <seealso cref="T:IVkQueryPoolCreateInfo" />
    </member>
    <member name="T:IVkSurfaceCapabilities2KHR" />
    <member name="T:VkSurfaceCapabilities2KHR32">
      <summary>See: <see cref="T:IVkSurfaceCapabilities2KHR" /></summary>
      <seealso cref="T:IVkSurfaceCapabilities2KHR" />
    </member>
    <member name="T:VkSurfaceCapabilities2KHR64">
      <summary>See: <see cref="T:IVkSurfaceCapabilities2KHR" /></summary>
      <seealso cref="T:IVkSurfaceCapabilities2KHR" />
    </member>
    <member name="T:vkCreateBufferView">
      <summary>Create a new buffer view object</summary>
      <remarks>


Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>device</c> must be a valid <c>VkDevice</c> handle
</description></item><item><description>
<c>pCreateInfo</c> must be a pointer to a valid <c>VkBufferViewCreateInfo</c> structure
</description></item><item><description>
 If <c>pAllocator</c> is not <c>NULL</c>, <c>pAllocator</c> must be a pointer to a valid <c>VkAllocationCallbacks</c> structure
</description></item><item><description>
<c>pView</c> must be a pointer to a <c>VkBufferView</c> handle
</description></item></list>




Return Codes
<dl><dt>On success, this command returns</dt><dd>
<list type="bullet"><item><description>
<c>VK_SUCCESS</c>
</description></item></list>
</dd><dt>On failure, this command returns</dt><dd>
<list type="bullet"><item><description>
<c>VK_ERROR_OUT_OF_HOST_MEMORY</c>
</description></item><item><description>
<c>VK_ERROR_OUT_OF_DEVICE_MEMORY</c>
</description></item></list>
</dd></dl>




To create a buffer view, call:


<code> VkResult vkCreateBufferView(
    VkDevice                                    device,
    const VkBufferViewCreateInfo*               pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkBufferView*                               pView); </code>

</remarks>
      <seealso cref="T:IVkAllocationCallbacks" />
      <seealso cref="T:VkBufferView" />
      <seealso cref="T:IVkBufferViewCreateInfo" />
      <seealso cref="T:VkDevice" />
    </member>
    <member name="T:IVkSparseBufferMemoryBindInfo">
      <summary>Structure specifying a sparse buffer memory bind operation</summary>
      <remarks>


Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>buffer</c> must be a valid <c>VkBuffer</c> handle
</description></item><item><description>
<c>pBinds</c> must be a pointer to an array of <c>bindCount</c> valid <c>VkSparseMemoryBind</c> structures
</description></item><item><description>
<c>bindCount</c> must be greater than <c>0</c>
</description></item></list>




Memory is bound to <c>VkBuffer</c> objects created with the
<c>VK_BUFFER_CREATE_SPARSE_BINDING_BIT</c> flag using the following
structure:


<code> typedef struct VkSparseBufferMemoryBindInfo {
    VkBuffer                     buffer;
    uint32_t                     bindCount;
    const VkSparseMemoryBind*    pBinds;
} VkSparseBufferMemoryBindInfo; </code>

</remarks>
      <seealso cref="T:IVkBindSparseInfo" />
      <seealso cref="T:VkBuffer" />
      <seealso cref="T:VkSparseMemoryBind" />
    </member>
    <member name="T:VkSparseBufferMemoryBindInfo32">
      <summary>See: <see cref="T:IVkSparseBufferMemoryBindInfo" /></summary>
      <seealso cref="T:IVkSparseBufferMemoryBindInfo" />
    </member>
    <member name="T:VkSparseBufferMemoryBindInfo64">
      <summary>See: <see cref="T:IVkSparseBufferMemoryBindInfo" /></summary>
      <seealso cref="T:IVkSparseBufferMemoryBindInfo" />
    </member>
    <member name="T:VkSparseMemoryBind">
      <summary>Structure specifying a sparse memory bind operation</summary>
      <remarks>

The  binding range [<c>resourceOffset</c>, <c>resourceOffset</c> + 
<c>size</c>) has different constraints based on <c>flags</c>.
If <c>flags</c> contains <c>VK_SPARSE_MEMORY_BIND_METADATA_BIT</c>, the
binding range  must be within the mip tail region of the metadata aspect.
This metadata region is defined by:

<dl><dt></dt><dd>
 metadataRegion = [base, base +  <c>imageMipTailSize</c>) 
</dd><dt></dt><dd>
 base = <c>imageMipTailOffset</c> +  <c>imageMipTailStride</c>
× n 
</dd></dl>

and <c>imageMipTailOffset</c>, <c>imageMipTailSize</c>, and
<c>imageMipTailStride</c> values are from the
<see cref="T:VkSparseImageMemoryRequirements" /> corresponding to the metadata aspect
of the image, and  n is a valid array layer index for the image,


<c>imageMipTailStride</c> is considered to be zero for aspects where
<c>VkSparseImageMemoryRequirements</c>::<c>formatProperties.flags</c> contains
<c>VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT</c>.


If <c>flags</c> does not contain <c>VK_SPARSE_MEMORY_BIND_METADATA_BIT</c>,
the binding range  must be within the range
 [0,<see cref="T:VkMemoryRequirements" />::<c>size</c>).



Valid Usage
<list type="bullet"><item><description>

If <c>memory</c> is not <see cref="!:VK_NULL_HANDLE" />, <c>memory</c> and
<c>memoryOffset</c> must match the memory requirements of the resource,
as described in section <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#resources-association">../../html/vkspec.html#resources-association</a>
</description></item><item><description>

If <c>memory</c> is not <see cref="!:VK_NULL_HANDLE" />, <c>memory</c> must not have
been created with a memory type that reports
<c>VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT</c> bit set
</description></item><item><description>
<c>size</c> must be greater than <c>0</c>
</description></item><item><description>
<c>resourceOffset</c> must  be less than the size of the resource
</description></item><item><description>
<c>size</c> must be less than or equal to the size of the resource minus
<c>resourceOffset</c>
</description></item><item><description>
<c>memoryOffset</c> must be less than the size of <c>memory</c>
</description></item><item><description>
<c>size</c> must be less than or equal to the size of <c>memory</c> minus
<c>memoryOffset</c>
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
 If <c>memory</c> is not <see cref="!:VK_NULL_HANDLE" />, <c>memory</c> must be a valid <c>VkDeviceMemory</c> handle
</description></item><item><description>
<c>flags</c> must be a valid combination of <see cref="T:VkSparseMemoryBindFlags" /> values
</description></item></list>




The <c>VkSparseMemoryBind</c> structure is defined as:


<code> typedef struct VkSparseMemoryBind {
    VkDeviceSize               resourceOffset;
    VkDeviceSize               size;
    VkDeviceMemory             memory;
    VkDeviceSize               memoryOffset;
    VkSparseMemoryBindFlags    flags;
} VkSparseMemoryBind; </code>

</remarks>
      <seealso cref="T:VkDeviceMemory" />
      <seealso cref="T:IVkSparseBufferMemoryBindInfo" />
      <seealso cref="T:IVkSparseImageOpaqueMemoryBindInfo" />
      <seealso cref="T:VkSparseMemoryBindFlags" />
    </member>
    <member name="T:VkIndirectCommandsTokenNVX" />
    <member name="T:IVkPresentRegionKHR" />
    <member name="T:VkPresentRegionKHR32">
      <summary>See: <see cref="T:IVkPresentRegionKHR" /></summary>
      <seealso cref="T:IVkPresentRegionKHR" />
    </member>
    <member name="T:VkPresentRegionKHR64">
      <summary>See: <see cref="T:IVkPresentRegionKHR" /></summary>
      <seealso cref="T:IVkPresentRegionKHR" />
    </member>
    <member name="T:vkBeginCommandBuffer">
      <summary>Start recording a command buffer</summary>
      <remarks>


Valid Usage
<list type="bullet"><item><description>
<c>commandBuffer</c> must not be in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#commandbuffers-lifecycle">recording or pending state</a>.
</description></item><item><description>

If <c>commandBuffer</c> was allocated from a <see cref="T:VkCommandPool" /> which
did not have the <c>VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT</c>
flag set, <c>commandBuffer</c> must be in the
<a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#commandbuffers-lifecycle">initial state</a>.
</description></item><item><description>

If <c>commandBuffer</c> is a secondary command buffer, the
<c>pInheritanceInfo</c> member of <c>pBeginInfo</c> must be a valid
<c>VkCommandBufferInheritanceInfo</c> structure
</description></item><item><description>

If <c>commandBuffer</c> is a secondary command buffer and either the
<c>occlusionQueryEnable</c> member of the <c>pInheritanceInfo</c> member
of <c>pBeginInfo</c> is <c>VK_FALSE</c>, or the precise occlusion queries
feature is not enabled, the <c>queryFlags</c> member of the
<c>pInheritanceInfo</c> member <c>pBeginInfo</c> must not contain
<c>VK_QUERY_CONTROL_PRECISE_BIT</c>
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>commandBuffer</c> must be a valid <c>VkCommandBuffer</c> handle
</description></item><item><description>
<c>pBeginInfo</c> must be a pointer to a valid <c>VkCommandBufferBeginInfo</c> structure
</description></item></list>




Host Synchronization
<list type="bullet"><item><description>
Host access to <c>commandBuffer</c> must  be externally synchronized
</description></item><item><description>
Host access to the <c>VkCommandPool</c> that <c>commandBuffer</c> was allocated from  must be externally synchronized
</description></item></list>




Return Codes
<dl><dt>On success, this command returns</dt><dd>
<list type="bullet"><item><description>
<c>VK_SUCCESS</c>
</description></item></list>
</dd><dt>On failure, this command returns</dt><dd>
<list type="bullet"><item><description>
<c>VK_ERROR_OUT_OF_HOST_MEMORY</c>
</description></item><item><description>
<c>VK_ERROR_OUT_OF_DEVICE_MEMORY</c>
</description></item></list>
</dd></dl>




To begin recording a command buffer, call:


<code> VkResult vkBeginCommandBuffer(
    VkCommandBuffer                             commandBuffer,
    const VkCommandBufferBeginInfo*             pBeginInfo); </code>

</remarks>
      <seealso cref="T:VkCommandBuffer" />
      <seealso cref="T:IVkCommandBufferBeginInfo" />
    </member>
    <member name="T:IVkPipelineDynamicStateCreateInfo">
      <summary>Structure specifying parameters of a newly created pipeline dynamic state</summary>
      <remarks>


Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>sType</c> must be <c>VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO</c>
</description></item><item><description>
<c>pNext</c> must be <c>NULL</c>
</description></item><item><description>
<c>flags</c> must be <c>0</c>
</description></item><item><description>
<c>pDynamicStates</c> must be a pointer to an array of <c>dynamicStateCount</c> valid <see cref="T:VkDynamicState" /> values
</description></item><item><description>
<c>dynamicStateCount</c> must be greater than <c>0</c>
</description></item></list>




The <c>VkPipelineDynamicStateCreateInfo</c> structure is defined as:


<code> typedef struct VkPipelineDynamicStateCreateInfo {
    VkStructureType                      sType;
    const void*                          pNext;
    VkPipelineDynamicStateCreateFlags    flags;
    uint32_t                             dynamicStateCount;
    const VkDynamicState*                pDynamicStates;
} VkPipelineDynamicStateCreateInfo; </code>

</remarks>
      <seealso cref="T:VkDynamicState" />
      <seealso cref="T:IVkGraphicsPipelineCreateInfo" />
      <seealso cref="T:VkPipelineDynamicStateCreateFlags" />
      <seealso cref="T:VkStructureType" />
    </member>
    <member name="T:VkPipelineDynamicStateCreateInfo32">
      <summary>See: <see cref="T:IVkPipelineDynamicStateCreateInfo" /></summary>
      <seealso cref="T:IVkPipelineDynamicStateCreateInfo" />
    </member>
    <member name="T:VkPipelineDynamicStateCreateInfo64">
      <summary>See: <see cref="T:IVkPipelineDynamicStateCreateInfo" /></summary>
      <seealso cref="T:IVkPipelineDynamicStateCreateInfo" />
    </member>
    <member name="T:vkCreateCommandPool">
      <summary>Create a new command pool object</summary>
      <remarks>


Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>device</c> must be a valid <c>VkDevice</c> handle
</description></item><item><description>
<c>pCreateInfo</c> must be a pointer to a valid <c>VkCommandPoolCreateInfo</c> structure
</description></item><item><description>
 If <c>pAllocator</c> is not <c>NULL</c>, <c>pAllocator</c> must be a pointer to a valid <c>VkAllocationCallbacks</c> structure
</description></item><item><description>
<c>pCommandPool</c> must be a pointer to a <c>VkCommandPool</c> handle
</description></item></list>




Return Codes
<dl><dt>On success, this command returns</dt><dd>
<list type="bullet"><item><description>
<c>VK_SUCCESS</c>
</description></item></list>
</dd><dt>On failure, this command returns</dt><dd>
<list type="bullet"><item><description>
<c>VK_ERROR_OUT_OF_HOST_MEMORY</c>
</description></item><item><description>
<c>VK_ERROR_OUT_OF_DEVICE_MEMORY</c>
</description></item></list>
</dd></dl>




To create a command pool, call:


<code> VkResult vkCreateCommandPool(
    VkDevice                                    device,
    const VkCommandPoolCreateInfo*              pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkCommandPool*                              pCommandPool); </code>

</remarks>
      <seealso cref="T:IVkAllocationCallbacks" />
      <seealso cref="T:VkCommandPool" />
      <seealso cref="T:IVkCommandPoolCreateInfo" />
      <seealso cref="T:VkDevice" />
    </member>
    <member name="T:IVkDeviceEventInfoEXT" />
    <member name="T:VkDeviceEventInfoEXT32">
      <summary>See: <see cref="T:IVkDeviceEventInfoEXT" /></summary>
      <seealso cref="T:IVkDeviceEventInfoEXT" />
    </member>
    <member name="T:VkDeviceEventInfoEXT64">
      <summary>See: <see cref="T:IVkDeviceEventInfoEXT" /></summary>
      <seealso cref="T:IVkDeviceEventInfoEXT" />
    </member>
    <member name="T:vkResetFences">
      <summary>Resets one or more fence objects</summary>
      <remarks>

When <see cref="T:vkResetFences" /> is executed on the host, it defines a  fence
unsignal operation for each fence, which resets the fence to the unsignaled
state.


If any member of <c>pFences</c> is already in the unsignaled state when
<see cref="T:vkResetFences" /> is executed, then <see cref="T:vkResetFences" /> has no effect on
that fence.



Valid Usage
<list type="bullet"><item><description>

Any given element of <c>pFences</c> must  not currently be associated
with any queue command that has not yet completed execution on that
queue
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>device</c> must be a valid <c>VkDevice</c> handle
</description></item><item><description>
<c>pFences</c> must be a pointer to an array of <c>fenceCount</c> valid <c>VkFence</c> handles
</description></item><item><description>
<c>fenceCount</c> must be greater than <c>0</c>
</description></item><item><description>
 Each element of <c>pFences</c> must have been created, allocated, or retrieved from <c>device</c>
</description></item></list>




Host Synchronization
<list type="bullet"><item><description>
Host access to each member of <c>pFences</c> must  be externally synchronized
</description></item></list>




Return Codes
<dl><dt>On success, this command returns</dt><dd>
<list type="bullet"><item><description>
<c>VK_SUCCESS</c>
</description></item></list>
</dd><dt>On failure, this command returns</dt><dd>
<list type="bullet"><item><description>
<c>VK_ERROR_OUT_OF_HOST_MEMORY</c>
</description></item><item><description>
<c>VK_ERROR_OUT_OF_DEVICE_MEMORY</c>
</description></item></list>
</dd></dl>




To set the state of fences to unsignaled from the host, call:


<code> VkResult vkResetFences(
    VkDevice                                    device,
    uint32_t                                    fenceCount,
    const VkFence*                              pFences); </code>

</remarks>
      <seealso cref="T:VkDevice" />
      <seealso cref="T:VkFence" />
    </member>
    <member name="T:IVkPhysicalDeviceProperties2KHR" />
    <member name="T:VkPhysicalDeviceProperties2KHR32">
      <summary>See: <see cref="T:IVkPhysicalDeviceProperties2KHR" /></summary>
      <seealso cref="T:IVkPhysicalDeviceProperties2KHR" />
    </member>
    <member name="T:VkPhysicalDeviceProperties2KHR64">
      <summary>See: <see cref="T:IVkPhysicalDeviceProperties2KHR" /></summary>
      <seealso cref="T:IVkPhysicalDeviceProperties2KHR" />
    </member>
    <member name="T:vkGetEventStatus">
      <summary>Retrieve the status of an event object</summary>
      <remarks>

Upon success, <c>vkGetEventStatus</c> returns the state of the event object
with the following return codes:

<para>Table 1. Event Object Status Codes</para><list type="table">     <listheader><tr><term>Status</term><term>Meaning</term></tr></listheader>
<item><term>
<c>VK_EVENT_SET</c>
</term><term>
The event specified by <c>event</c> is signaled.
</term></item><item><term>
<c>VK_EVENT_RESET</c>
</term><term>
The event specified by <c>event</c> is unsignaled.
</term></item>
</list>

If a <c>vkCmdSetEvent</c> or <c>vkCmdResetEvent</c> command is in a command
buffer that is in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#commandbuffers-lifecycle">pending state</a>, then the
value returned by this command  may immediately be out of date.


The state of an event  can be updated by the host.
The state of the event is immediately changed, and subsequent calls to
<c>vkGetEventStatus</c> will return the new state.
If an event is already in the requested state, then updating it to the same
state has no effect.



Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>device</c> must be a valid <c>VkDevice</c> handle
</description></item><item><description>
<c>event</c> must be a valid <c>VkEvent</c> handle
</description></item><item><description>
<c>event</c> must have been created, allocated, or retrieved from <c>device</c>
</description></item></list>




Return Codes
<dl><dt>On success, this command returns</dt><dd>
<list type="bullet"><item><description>
<c>VK_EVENT_SET</c>
</description></item><item><description>
<c>VK_EVENT_RESET</c>
</description></item></list>
</dd><dt>On failure, this command returns</dt><dd>
<list type="bullet"><item><description>
<c>VK_ERROR_OUT_OF_HOST_MEMORY</c>
</description></item><item><description>
<c>VK_ERROR_OUT_OF_DEVICE_MEMORY</c>
</description></item><item><description>
<c>VK_ERROR_DEVICE_LOST</c>
</description></item></list>
</dd></dl>




To query the state of an event from the host, call:


<code> VkResult vkGetEventStatus(
    VkDevice                                    device,
    VkEvent                                     event); </code>

</remarks>
      <seealso cref="T:VkDevice" />
      <seealso cref="T:VkEvent" />
    </member>
    <member name="T:IVkBindSparseInfo">
      <summary>Structure specifying a sparse binding operation</summary>
      <remarks>


Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>sType</c> must be <c>VK_STRUCTURE_TYPE_BIND_SPARSE_INFO</c>
</description></item><item><description>
<c>pNext</c> must be <c>NULL</c>
</description></item><item><description>
 If <c>waitSemaphoreCount</c> is not <c>0</c>, <c>pWaitSemaphores</c> must be a pointer to an array of <c>waitSemaphoreCount</c> valid <c>VkSemaphore</c> handles
</description></item><item><description>
 If <c>bufferBindCount</c> is not <c>0</c>, <c>pBufferBinds</c> must be a pointer to an array of <c>bufferBindCount</c> valid <c>VkSparseBufferMemoryBindInfo</c> structures
</description></item><item><description>
 If <c>imageOpaqueBindCount</c> is not <c>0</c>, <c>pImageOpaqueBinds</c> must be a pointer to an array of <c>imageOpaqueBindCount</c> valid <c>VkSparseImageOpaqueMemoryBindInfo</c> structures
</description></item><item><description>
 If <c>imageBindCount</c> is not <c>0</c>, <c>pImageBinds</c> must be a pointer to an array of <c>imageBindCount</c> valid <c>VkSparseImageMemoryBindInfo</c> structures
</description></item><item><description>
 If <c>signalSemaphoreCount</c> is not <c>0</c>, <c>pSignalSemaphores</c> must be a pointer to an array of <c>signalSemaphoreCount</c> valid <c>VkSemaphore</c> handles
</description></item><item><description>
 Both of the elements of <c>pSignalSemaphores</c>, and the elements of <c>pWaitSemaphores</c> that are valid handles  must have been created, allocated, or retrieved from the same <c>VkDevice</c>
</description></item></list>




The <c>VkBindSparseInfo</c> structure is defined as:


<code> typedef struct VkBindSparseInfo {
    VkStructureType                             sType;
    const void*                                 pNext;
    uint32_t                                    waitSemaphoreCount;
    const VkSemaphore*                          pWaitSemaphores;
    uint32_t                                    bufferBindCount;
    const VkSparseBufferMemoryBindInfo*         pBufferBinds;
    uint32_t                                    imageOpaqueBindCount;
    const VkSparseImageOpaqueMemoryBindInfo*    pImageOpaqueBinds;
    uint32_t                                    imageBindCount;
    const VkSparseImageMemoryBindInfo*          pImageBinds;
    uint32_t                                    signalSemaphoreCount;
    const VkSemaphore*                          pSignalSemaphores;
} VkBindSparseInfo; </code>

</remarks>
      <seealso cref="T:VkSemaphore" />
      <seealso cref="T:IVkSparseBufferMemoryBindInfo" />
      <seealso cref="T:IVkSparseImageMemoryBindInfo" />
      <seealso cref="T:IVkSparseImageOpaqueMemoryBindInfo" />
      <seealso cref="T:VkStructureType" />
      <seealso cref="T:vkQueueBindSparse" />
    </member>
    <member name="T:VkBindSparseInfo32">
      <summary>See: <see cref="T:IVkBindSparseInfo" /></summary>
      <seealso cref="T:IVkBindSparseInfo" />
    </member>
    <member name="T:VkBindSparseInfo64">
      <summary>See: <see cref="T:IVkBindSparseInfo" /></summary>
      <seealso cref="T:IVkBindSparseInfo" />
    </member>
    <member name="T:vkFreeDescriptorSets">
      <summary>Free one or more descriptor sets</summary>
      <remarks>

After a successful call to <c>vkFreeDescriptorSets</c>, all descriptor sets
in <c>pDescriptorSets</c> are invalid.



Valid Usage
<list type="bullet"><item><description>

All submitted commands that refer to any element of
<c>pDescriptorSets</c> must  have completed execution
</description></item><item><description>
<c>pDescriptorSets</c> must be a pointer to an array of
<c>descriptorSetCount</c><c>VkDescriptorSet</c> handles, each element of
which  must either be a valid handle or <see cref="!:VK_NULL_HANDLE" />
</description></item><item><description>

Each valid handle in <c>pDescriptorSets</c> must have been allocated
from <c>descriptorPool</c>
</description></item><item><description>
<c>descriptorPool</c> must have been created with the
<c>VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT</c> flag
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>device</c> must be a valid <c>VkDevice</c> handle
</description></item><item><description>
<c>descriptorPool</c> must be a valid <c>VkDescriptorPool</c> handle
</description></item><item><description>
<c>descriptorSetCount</c> must be greater than <c>0</c>
</description></item><item><description>
<c>descriptorPool</c> must have been created, allocated, or retrieved from <c>device</c>
</description></item><item><description>
 Each element of <c>pDescriptorSets</c> that is a valid handle  must have been created, allocated, or retrieved from <c>descriptorPool</c>
</description></item></list>




Host Synchronization
<list type="bullet"><item><description>
Host access to <c>descriptorPool</c> must  be externally synchronized
</description></item><item><description>
Host access to each member of <c>pDescriptorSets</c> must  be externally synchronized
</description></item></list>




Return Codes
<dl><dt>On success, this command returns</dt><dd>
<list type="bullet"><item><description>
<c>VK_SUCCESS</c>
</description></item></list>
</dd><dt>On failure, this command returns</dt><dd>
<list type="bullet"><item><description>
<c>VK_ERROR_OUT_OF_HOST_MEMORY</c>
</description></item><item><description>
<c>VK_ERROR_OUT_OF_DEVICE_MEMORY</c>
</description></item></list>
</dd></dl>




To free allocated descriptor sets, call:


<code> VkResult vkFreeDescriptorSets(
    VkDevice                                    device,
    VkDescriptorPool                            descriptorPool,
    uint32_t                                    descriptorSetCount,
    const VkDescriptorSet*                      pDescriptorSets); </code>

</remarks>
      <seealso cref="T:VkDescriptorPool" />
      <seealso cref="T:VkDescriptorSet" />
      <seealso cref="T:VkDevice" />
    </member>
    <member name="T:vkGetDeviceQueue">
      <summary>Get a queue handle from a device</summary>
      <remarks>


Valid Usage
<list type="bullet"><item><description>
<c>queueFamilyIndex</c> must be one of the queue family indices
specified when <c>device</c> was created, via the
<c>VkDeviceQueueCreateInfo</c> structure
</description></item><item><description>
<c>queueIndex</c> must be less than the number of queues created for the
specified queue family index when <c>device</c> was created, via the
<c>queueCount</c> member of the <c>VkDeviceQueueCreateInfo</c> structure
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>device</c> must be a valid <c>VkDevice</c> handle
</description></item><item><description>
<c>pQueue</c> must be a pointer to a <c>VkQueue</c> handle
</description></item></list>




To retrieve a handle to a VkQueue object, call:


<code> void vkGetDeviceQueue(
    VkDevice                                    device,
    uint32_t                                    queueFamilyIndex,
    uint32_t                                    queueIndex,
    VkQueue*                                    pQueue); </code>

</remarks>
      <seealso cref="T:VkDevice" />
      <seealso cref="T:VkQueue" />
    </member>
    <member name="T:IVkExportMemoryAllocateInfoNV" />
    <member name="T:VkExportMemoryAllocateInfoNV32">
      <summary>See: <see cref="T:IVkExportMemoryAllocateInfoNV" /></summary>
      <seealso cref="T:IVkExportMemoryAllocateInfoNV" />
    </member>
    <member name="T:VkExportMemoryAllocateInfoNV64">
      <summary>See: <see cref="T:IVkExportMemoryAllocateInfoNV" /></summary>
      <seealso cref="T:IVkExportMemoryAllocateInfoNV" />
    </member>
    <member name="T:vkCreateInstance">
      <summary>Create a new Vulkan instance</summary>
      <remarks>

<c>vkCreateInstance</c> verifies that the requested layers exist.
If not, <c>vkCreateInstance</c> will return <c>VK_ERROR_LAYER_NOT_PRESENT</c>.
Next <c>vkCreateInstance</c> verifies that the requested extensions are
supported (e.g. in the implementation or in any enabled instance layer) and
if any requested extension is not supported, <c>vkCreateInstance</c> must
return <c>VK_ERROR_EXTENSION_NOT_PRESENT</c>.
After verifying and enabling the instance layers and extensions the
<c>VkInstance</c> object is created and returned to the application.
If a requested extension is only supported by a layer, both the layer and
the extension need to be specified at <c>vkCreateInstance</c> time for the
creation to succeed.



Valid Usage
<list type="bullet"><item><description>

All <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#extended-functionality-extensions-dependencies">required
extensions</a> for each extension in the
<see cref="T:IVkInstanceCreateInfo" />::<c>ppEnabledExtensionNames</c> list  must
also be present in that list.
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>pCreateInfo</c> must be a pointer to a valid <c>VkInstanceCreateInfo</c> structure
</description></item><item><description>
 If <c>pAllocator</c> is not <c>NULL</c>, <c>pAllocator</c> must be a pointer to a valid <c>VkAllocationCallbacks</c> structure
</description></item><item><description>
<c>pInstance</c> must be a pointer to a <c>VkInstance</c> handle
</description></item></list>




Return Codes
<dl><dt>On success, this command returns</dt><dd>
<list type="bullet"><item><description>
<c>VK_SUCCESS</c>
</description></item></list>
</dd><dt>On failure, this command returns</dt><dd>
<list type="bullet"><item><description>
<c>VK_ERROR_OUT_OF_HOST_MEMORY</c>
</description></item><item><description>
<c>VK_ERROR_OUT_OF_DEVICE_MEMORY</c>
</description></item><item><description>
<c>VK_ERROR_INITIALIZATION_FAILED</c>
</description></item><item><description>
<c>VK_ERROR_LAYER_NOT_PRESENT</c>
</description></item><item><description>
<c>VK_ERROR_EXTENSION_NOT_PRESENT</c>
</description></item><item><description>
<c>VK_ERROR_INCOMPATIBLE_DRIVER</c>
</description></item></list>
</dd></dl>




To create an instance object, call:


<code> VkResult vkCreateInstance(
    const VkInstanceCreateInfo*                 pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkInstance*                                 pInstance); </code>

</remarks>
      <seealso cref="T:IVkAllocationCallbacks" />
      <seealso cref="T:VkInstance" />
      <seealso cref="T:IVkInstanceCreateInfo" />
    </member>
    <member name="T:IVkPhysicalDeviceMultiviewFeaturesKHX" />
    <member name="T:VkPhysicalDeviceMultiviewFeaturesKHX32">
      <summary>See: <see cref="T:IVkPhysicalDeviceMultiviewFeaturesKHX" /></summary>
      <seealso cref="T:IVkPhysicalDeviceMultiviewFeaturesKHX" />
    </member>
    <member name="T:VkPhysicalDeviceMultiviewFeaturesKHX64">
      <summary>See: <see cref="T:IVkPhysicalDeviceMultiviewFeaturesKHX" /></summary>
      <seealso cref="T:IVkPhysicalDeviceMultiviewFeaturesKHX" />
    </member>
    <member name="T:vkMergePipelineCaches">
      <summary>Combine the data stores of pipeline caches</summary>
      <remarks>
<list type="table"><tr><td><i title="Note"></i></td><td>
Note

The details of the merge operation are implementation dependent, but
implementations  should merge the contents of the specified pipelines and
prune duplicate entries.

</td></tr></list>


Valid Usage
<list type="bullet"><item><description>
<c>dstCache</c> must  not appear in the list of source caches
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>device</c> must be a valid <c>VkDevice</c> handle
</description></item><item><description>
<c>dstCache</c> must be a valid <c>VkPipelineCache</c> handle
</description></item><item><description>
<c>pSrcCaches</c> must be a pointer to an array of <c>srcCacheCount</c> valid <c>VkPipelineCache</c> handles
</description></item><item><description>
<c>srcCacheCount</c> must be greater than <c>0</c>
</description></item><item><description>
<c>dstCache</c> must have been created, allocated, or retrieved from <c>device</c>
</description></item><item><description>
 Each element of <c>pSrcCaches</c> must have been created, allocated, or retrieved from <c>device</c>
</description></item></list>




Host Synchronization
<list type="bullet"><item><description>
Host access to <c>dstCache</c> must  be externally synchronized
</description></item></list>




Return Codes
<dl><dt>On success, this command returns</dt><dd>
<list type="bullet"><item><description>
<c>VK_SUCCESS</c>
</description></item></list>
</dd><dt>On failure, this command returns</dt><dd>
<list type="bullet"><item><description>
<c>VK_ERROR_OUT_OF_HOST_MEMORY</c>
</description></item><item><description>
<c>VK_ERROR_OUT_OF_DEVICE_MEMORY</c>
</description></item></list>
</dd></dl>




Pipeline cache objects  can be merged using the command:


<code> VkResult vkMergePipelineCaches(
    VkDevice                                    device,
    VkPipelineCache                             dstCache,
    uint32_t                                    srcCacheCount,
    const VkPipelineCache*                      pSrcCaches); </code>

</remarks>
      <seealso cref="T:VkDevice" />
      <seealso cref="T:VkPipelineCache" />
    </member>
    <member name="T:VkImageResolve">
      <summary>Structure specifying an image resolve operation</summary>
      <remarks>


Valid Usage
<list type="bullet"><item><description>

The <c>aspectMask</c> member of <c>srcSubresource</c> and
<c>dstSubresource</c> must only contain <c>VK_IMAGE_ASPECT_COLOR_BIT</c>
</description></item><item><description>

The <c>layerCount</c> member of <c>srcSubresource</c> and
<c>dstSubresource</c> must  match
</description></item><item><description>

If either of the calling command&amp;#8217;s <c>srcImage</c> or <c>dstImage</c>
parameters are of <see cref="T:VkImageType" /><c>VK_IMAGE_TYPE_3D</c>, the
<c>baseArrayLayer</c> and <c>layerCount</c> members of both
<c>srcSubresource</c> and <c>dstSubresource</c> must be <c>0</c> and <c>1</c>,
respectively
</description></item><item><description>
<c>srcOffset.x</c> and  (<c>extent.width</c> + 
<c>srcOffset.x</c>) must both be greater than or equal to <c>0</c> and less
than or equal to the source image subresource width
</description></item><item><description>
<c>srcOffset.y</c> and  (<c>extent.height</c> + 
<c>srcOffset.y</c>) must both be greater than or equal to <c>0</c> and less
than or equal to the source image subresource height
</description></item><item><description>

If the calling command&amp;#8217;s <c>srcImage</c> is of type
<c>VK_IMAGE_TYPE_1D</c>, then <c>srcOffset.y</c> must be <c>0</c> and
<c>extent.height</c> must be <c>1</c>.
</description></item><item><description>
<c>srcOffset.z</c> and  (<c>extent.depth</c> + 
<c>srcOffset.z</c>) must both be greater than or equal to <c>0</c> and less
than or equal to the source image subresource depth
</description></item><item><description>

If the calling command&amp;#8217;s <c>srcImage</c> is of type
<c>VK_IMAGE_TYPE_1D</c> or <c>VK_IMAGE_TYPE_2D</c>, then <c>srcOffset.z</c> must be <c>0</c> and <c>extent.depth</c> must be <c>1</c>.
</description></item><item><description>
<c>dstOffset.x</c> and  (<c>extent.width</c> + 
<c>dstOffset.x</c>) must both be greater than or equal to <c>0</c> and less
than or equal to the destination image subresource width
</description></item><item><description>
<c>dstOffset.y</c> and  (<c>extent.height</c> + 
<c>dstOffset.y</c>) must both be greater than or equal to <c>0</c> and less
than or equal to the destination image subresource height
</description></item><item><description>

If the calling command&amp;#8217;s <c>dstImage</c> is of type
<c>VK_IMAGE_TYPE_1D</c>, then <c>dstOffset.y</c> must be <c>0</c> and
<c>extent.height</c> must be <c>1</c>.
</description></item><item><description>
<c>dstOffset.z</c> and  (<c>extent.depth</c> + 
<c>dstOffset.z</c>) must both be greater than or equal to <c>0</c> and less
than or equal to the destination image subresource depth
</description></item><item><description>

If the calling command&amp;#8217;s <c>dstImage</c> is of type
<c>VK_IMAGE_TYPE_1D</c> or <c>VK_IMAGE_TYPE_2D</c>, then <c>dstOffset.z</c> must be <c>0</c> and <c>extent.depth</c> must be <c>1</c>.
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>srcSubresource</c> must be a valid <c>VkImageSubresourceLayers</c> structure
</description></item><item><description>
<c>dstSubresource</c> must be a valid <c>VkImageSubresourceLayers</c> structure
</description></item></list>




The <c>VkImageResolve</c> structure is defined as:


<code> typedef struct VkImageResolve {
    VkImageSubresourceLayers    srcSubresource;
    VkOffset3D                  srcOffset;
    VkImageSubresourceLayers    dstSubresource;
    VkOffset3D                  dstOffset;
    VkExtent3D                  extent;
} VkImageResolve; </code>

</remarks>
      <seealso cref="T:VkExtent3D" />
      <seealso cref="T:VkImageSubresourceLayers" />
      <seealso cref="T:VkOffset3D" />
      <seealso cref="T:vkCmdResolveImage" />
    </member>
    <member name="T:vkDestroyDevice">
      <summary>Destroy a logical device</summary>
      <remarks>

To ensure that no work is active on the device, <see cref="T:vkDeviceWaitIdle" /> can
be used to gate the destruction of the device.
Prior to destroying a device, an application is responsible for
destroying/freeing any Vulkan objects that were created using that device as
the first parameter of the corresponding <c>vkCreate*</c> or
<c>vkAllocate*</c> command.

<list type="table"><tr><td><i title="Note"></i></td><td>
Note

The lifetime of each of these objects is bound by the lifetime of the
<c>VkDevice</c> object.
Therefore, to avoid resource leaks, it is critical that an application
explicitly free all of these resources prior to calling
<c>vkDestroyDevice</c>.

</td></tr></list>


Valid Usage
<list type="bullet"><item><description>

All child objects created on <c>device</c> must have been destroyed
prior to destroying <c>device</c>
</description></item><item><description>

If <c>VkAllocationCallbacks</c> were provided when <c>device</c> was
created, a compatible set of callbacks  must be provided here
</description></item><item><description>

If no <c>VkAllocationCallbacks</c> were provided when <c>device</c> was
created, <c>pAllocator</c> must be <c>NULL</c>
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
 If <c>device</c> is not <c>NULL</c>, <c>device</c> must be a valid <c>VkDevice</c> handle
</description></item><item><description>
 If <c>pAllocator</c> is not <c>NULL</c>, <c>pAllocator</c> must be a pointer to a valid <c>VkAllocationCallbacks</c> structure
</description></item></list>




Host Synchronization
<list type="bullet"><item><description>
Host access to <c>device</c> must  be externally synchronized
</description></item></list>




To destroy a device, call:


<code> void vkDestroyDevice(
    VkDevice                                    device,
    const VkAllocationCallbacks*                pAllocator); </code>

</remarks>
      <seealso cref="T:IVkAllocationCallbacks" />
      <seealso cref="T:VkDevice" />
    </member>
    <member name="T:vkGetRefreshCycleDurationGOOGLE" />
    <member name="T:IVkHdrMetadataEXT" />
    <member name="T:VkHdrMetadataEXT32">
      <summary>See: <see cref="T:IVkHdrMetadataEXT" /></summary>
      <seealso cref="T:IVkHdrMetadataEXT" />
    </member>
    <member name="T:VkHdrMetadataEXT64">
      <summary>See: <see cref="T:IVkHdrMetadataEXT" /></summary>
      <seealso cref="T:IVkHdrMetadataEXT" />
    </member>
    <member name="T:vkEnumerateInstanceExtensionProperties">
      <summary>Returns up to requested number of global extension properties</summary>
      <remarks>

When <c>pLayerName</c> parameter is NULL, only extensions provided by the
Vulkan implementation or by implicitly enabled layers are returned.
When <c>pLayerName</c> is the name of a layer, the instance extensions
provided by that layer are returned.


If <c>pProperties</c> is <c>NULL</c>, then the number of extensions properties
available is returned in <c>pPropertyCount</c>.
Otherwise, <c>pPropertyCount</c> must point to a variable set by the user to
the number of elements in the <c>pProperties</c> array, and on return the
variable is overwritten with the number of structures actually written to
<c>pProperties</c>.
If <c>pPropertyCount</c> is less than the number of extension properties
available, at most <c>pPropertyCount</c> structures will be written.
If <c>pPropertyCount</c> is smaller than the number of extensions available,
<c>VK_INCOMPLETE</c> will be returned instead of <c>VK_SUCCESS</c>, to
indicate that not all the available properties were returned.


Because the list of available layers may change externally between calls to
<c>vkEnumerateInstanceExtensionProperties</c>, two calls may retrieve
different results if a <c>pLayerName</c> is available in one call but not in
another.
The extensions supported by a layer may also change between two calls, e.g.
if the layer implementation is replaced by a different version between those
calls.



Valid Usage (Implicit)
<list type="bullet"><item><description>
 If <c>pLayerName</c> is not <c>NULL</c>, <c>pLayerName</c> must  be a null-terminated UTF-8 string
</description></item><item><description>
<c>pPropertyCount</c> must be a pointer to a <c>uint32_t</c> value
</description></item><item><description>
 If the value referenced by <c>pPropertyCount</c> is not <c>0</c>, and <c>pProperties</c> is not <c>NULL</c>, <c>pProperties</c> must be a pointer to an array of <c>pPropertyCount</c><c>VkExtensionProperties</c> structures
</description></item></list>




Return Codes
<dl><dt>On success, this command returns</dt><dd>
<list type="bullet"><item><description>
<c>VK_SUCCESS</c>
</description></item><item><description>
<c>VK_INCOMPLETE</c>
</description></item></list>
</dd><dt>On failure, this command returns</dt><dd>
<list type="bullet"><item><description>
<c>VK_ERROR_OUT_OF_HOST_MEMORY</c>
</description></item><item><description>
<c>VK_ERROR_OUT_OF_DEVICE_MEMORY</c>
</description></item><item><description>
<c>VK_ERROR_LAYER_NOT_PRESENT</c>
</description></item></list>
</dd></dl>




To query the available instance extensions, call:


<code> VkResult vkEnumerateInstanceExtensionProperties(
    const char*                                 pLayerName,
    uint32_t*                                   pPropertyCount,
    VkExtensionProperties*                      pProperties); </code>

</remarks>
      <seealso cref="T:VkExtensionProperties" />
    </member>
    <member name="T:VkPushConstantRange">
      <summary>Structure specifying a push constant range</summary>
      <remarks>


Valid Usage
<list type="bullet"><item><description>
<c>offset</c> must be less than
<c>VkPhysicalDeviceLimits</c>::<c>maxPushConstantsSize</c>
</description></item><item><description>
<c>offset</c> must be a multiple of <c>4</c>
</description></item><item><description>
<c>size</c> must be greater than <c>0</c>
</description></item><item><description>
<c>size</c> must be a multiple of <c>4</c>
</description></item><item><description>
<c>size</c> must be less than or equal to
<c>VkPhysicalDeviceLimits</c>::<c>maxPushConstantsSize</c> minus
<c>offset</c>
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>stageFlags</c> must be a valid combination of <see cref="T:VkShaderStageFlags" /> values
</description></item><item><description>
<c>stageFlags</c> must not be <c>0</c>
</description></item></list>




The <c>VkPushConstantRange</c> structure is defined as:


<code> typedef struct VkPushConstantRange {
    VkShaderStageFlags    stageFlags;
    uint32_t              offset;
    uint32_t              size;
} VkPushConstantRange; </code>

</remarks>
      <seealso cref="T:IVkPipelineLayoutCreateInfo" />
      <seealso cref="T:VkShaderStageFlags" />
    </member>
    <member name="T:IVkPipelineDiscardRectangleStateCreateInfoEXT" />
    <member name="T:VkPipelineDiscardRectangleStateCreateInfoEXT32">
      <summary>See: <see cref="T:IVkPipelineDiscardRectangleStateCreateInfoEXT" /></summary>
      <seealso cref="T:IVkPipelineDiscardRectangleStateCreateInfoEXT" />
    </member>
    <member name="T:VkPipelineDiscardRectangleStateCreateInfoEXT64">
      <summary>See: <see cref="T:IVkPipelineDiscardRectangleStateCreateInfoEXT" /></summary>
      <seealso cref="T:IVkPipelineDiscardRectangleStateCreateInfoEXT" />
    </member>
    <member name="T:VkImageCopy">
      <summary>Structure specifying an image copy operation</summary>
      <remarks>

Copies are done layer by layer starting with <c>baseArrayLayer</c> member of
<c>srcSubresource</c> for the source and <c>dstSubresource</c> for the
destination.
<c>layerCount</c> layers are copied to the destination image.



Valid Usage
<list type="bullet"><item><description>

The <c>aspectMask</c> member of <c>srcSubresource</c> and
<c>dstSubresource</c> must  match
</description></item><item><description>

The <c>layerCount</c> member of <c>srcSubresource</c> and
<c>dstSubresource</c> must  match
</description></item><item><description>

If either of the calling command&amp;#8217;s <c>srcImage</c> or <c>dstImage</c>
parameters are of <see cref="T:VkImageType" /><c>VK_IMAGE_TYPE_3D</c>, the
<c>baseArrayLayer</c> and <c>layerCount</c> members of both
<c>srcSubresource</c> and <c>dstSubresource</c> must be <c>0</c> and <c>1</c>,
respectively
</description></item><item><description>

The <c>aspectMask</c> member of <c>srcSubresource</c> must specify
aspects present in the calling command&amp;#8217;s <c>srcImage</c>
</description></item><item><description>

The <c>aspectMask</c> member of <c>dstSubresource</c> must specify
aspects present in the calling command&amp;#8217;s <c>dstImage</c>
</description></item><item><description>
<c>srcOffset.x</c> and  (<c>extent.width</c> + 
<c>srcOffset.x</c>) must both be greater than or equal to <c>0</c> and less
than or equal to the source image subresource width
</description></item><item><description>
<c>srcOffset.y</c> and  (<c>extent.height</c> + 
<c>srcOffset.y</c>) must both be greater than or equal to <c>0</c> and less
than or equal to the source image subresource height
</description></item><item><description>

If the calling command&amp;#8217;s <c>srcImage</c> is of type
<c>VK_IMAGE_TYPE_1D</c>, then <c>srcOffset.y</c> must be <c>0</c> and
<c>extent.height</c> must be <c>1</c>.
</description></item><item><description>
<c>srcOffset.z</c> and  (<c>extent.depth</c> + 
<c>srcOffset.z</c>) must both be greater than or equal to <c>0</c> and less
than or equal to the source image subresource depth
</description></item><item><description>

If the calling command&amp;#8217;s <c>srcImage</c> is of type
<c>VK_IMAGE_TYPE_1D</c> or <c>VK_IMAGE_TYPE_2D</c>, then <c>srcOffset.z</c> must be <c>0</c> and <c>extent.depth</c> must be <c>1</c>.
</description></item><item><description>
<c>srcSubresource.baseArrayLayer</c> must be less than and
 (<c>srcSubresource.layerCount</c> + 
<c>srcSubresource.baseArrayLayer</c>) must  be less than or equal to the
number of layers in the source image
</description></item><item><description>
<c>dstOffset.x</c> and  (<c>extent.width</c> + 
<c>dstOffset.x</c>) must both be greater than or equal to <c>0</c> and less
than or equal to the destination image subresource width
</description></item><item><description>
<c>dstOffset.y</c> and  (<c>extent.height</c> + 
<c>dstOffset.y</c>) must both be greater than or equal to <c>0</c> and less
than or equal to the destination image subresource height
</description></item><item><description>

If the calling command&amp;#8217;s <c>dstImage</c> is of type
<c>VK_IMAGE_TYPE_1D</c>, then <c>dstOffset.y</c> must be <c>0</c> and
<c>extent.height</c> must be <c>1</c>.
</description></item><item><description>
<c>dstOffset.z</c> and  (<c>extent.depth</c> + 
<c>dstOffset.z</c>) must both be greater than or equal to <c>0</c> and less
than or equal to the destination image subresource depth
</description></item><item><description>

If the calling command&amp;#8217;s <c>dstImage</c> is of type
<c>VK_IMAGE_TYPE_1D</c> or <c>VK_IMAGE_TYPE_2D</c>, then <c>dstOffset.z</c> must be <c>0</c> and <c>extent.depth</c> must be <c>1</c>.
</description></item><item><description>
<c>dstSubresource.baseArrayLayer</c> must be less than and
 (<c>dstSubresource.layerCount</c> + 
<c>dstSubresource.baseArrayLayer</c>) must  be less than or equal to the
number of layers in the destination image
</description></item><item><description>

If the calling command&amp;#8217;s <c>srcImage</c> is a compressed format image,
all members of <c>srcOffset</c> must  be a multiple of the corresponding
dimensions of the compressed texel block
</description></item><item><description>

If the calling command&amp;#8217;s <c>srcImage</c> is a compressed format image,
<c>extent.width</c> must be a multiple of the compressed texel block
width or  (<c>extent.width</c> +  <c>srcOffset.x</c>) must  equal
the source image subresource width
</description></item><item><description>

If the calling command&amp;#8217;s <c>srcImage</c> is a compressed format image,
<c>extent.height</c> must be a multiple of the compressed texel block
height or  (<c>extent.height</c> +  <c>srcOffset.y</c>) must 
equal the source image subresource height
</description></item><item><description>

If the calling command&amp;#8217;s <c>srcImage</c> is a compressed format image,
<c>extent.depth</c> must be a multiple of the compressed texel block
depth or  (<c>extent.depth</c> +  <c>srcOffset.z</c>) must  equal
the source image subresource depth
</description></item><item><description>

If the calling command&amp;#8217;s <c>dstImage</c> is a compressed format image,
all members of <c>dstOffset</c> must  be a multiple of the corresponding
dimensions of the compressed texel block
</description></item><item><description>

If the calling command&amp;#8217;s <c>dstImage</c> is a compressed format image,
<c>extent.width</c> must be a multiple of the compressed texel block
width or  (<c>extent.width</c> +  <c>dstOffset.x</c>) must  equal
the destination image subresource width
</description></item><item><description>

If the calling command&amp;#8217;s <c>dstImage</c> is a compressed format image,
<c>extent.height</c> must be a multiple of the compressed texel block
height or  (<c>extent.height</c> +  <c>dstOffset.y</c>) must 
equal the destination image subresource height
</description></item><item><description>

If the calling command&amp;#8217;s <c>dstImage</c> is a compressed format image,
<c>extent.depth</c> must be a multiple of the compressed texel block
depth or  (<c>extent.depth</c> +  <c>dstOffset.z</c>) must  equal
the destination image subresource depth
</description></item><item><description>
<c>srcOffset</c>, <c>dstOffset</c>, and <c>extent</c> must respect the
image transfer granularity requirements of the queue family that it will
be submitted against, as described in
<a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#devsandqueues-physical-device-enumeration">Physical Device
Enumeration</a>
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>srcSubresource</c> must be a valid <c>VkImageSubresourceLayers</c> structure
</description></item><item><description>
<c>dstSubresource</c> must be a valid <c>VkImageSubresourceLayers</c> structure
</description></item></list>




The <c>VkImageCopy</c> structure is defined as:


<code> typedef struct VkImageCopy {
    VkImageSubresourceLayers    srcSubresource;
    VkOffset3D                  srcOffset;
    VkImageSubresourceLayers    dstSubresource;
    VkOffset3D                  dstOffset;
    VkExtent3D                  extent;
} VkImageCopy; </code>

</remarks>
      <seealso cref="T:VkExtent3D" />
      <seealso cref="T:VkImageSubresourceLayers" />
      <seealso cref="T:VkOffset3D" />
      <seealso cref="T:vkCmdCopyImage" />
    </member>
    <member name="T:vkEnumerateDeviceExtensionProperties">
      <summary>Returns properties of available physical device extensions</summary>
      <remarks>

When <c>pLayerName</c> parameter is NULL, only extensions provided by the
Vulkan implementation or by implicitly enabled layers are returned.
When <c>pLayerName</c> is the name of a layer, the device extensions provided
by that layer are returned.



Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>physicalDevice</c> must be a valid <c>VkPhysicalDevice</c> handle
</description></item><item><description>
 If <c>pLayerName</c> is not <c>NULL</c>, <c>pLayerName</c> must  be a null-terminated UTF-8 string
</description></item><item><description>
<c>pPropertyCount</c> must be a pointer to a <c>uint32_t</c> value
</description></item><item><description>
 If the value referenced by <c>pPropertyCount</c> is not <c>0</c>, and <c>pProperties</c> is not <c>NULL</c>, <c>pProperties</c> must be a pointer to an array of <c>pPropertyCount</c><c>VkExtensionProperties</c> structures
</description></item></list>




Return Codes
<dl><dt>On success, this command returns</dt><dd>
<list type="bullet"><item><description>
<c>VK_SUCCESS</c>
</description></item><item><description>
<c>VK_INCOMPLETE</c>
</description></item></list>
</dd><dt>On failure, this command returns</dt><dd>
<list type="bullet"><item><description>
<c>VK_ERROR_OUT_OF_HOST_MEMORY</c>
</description></item><item><description>
<c>VK_ERROR_OUT_OF_DEVICE_MEMORY</c>
</description></item><item><description>
<c>VK_ERROR_LAYER_NOT_PRESENT</c>
</description></item></list>
</dd></dl>




To query the extensions available to a given physical device, call:


<code> VkResult vkEnumerateDeviceExtensionProperties(
    VkPhysicalDevice                            physicalDevice,
    const char*                                 pLayerName,
    uint32_t*                                   pPropertyCount,
    VkExtensionProperties*                      pProperties); </code>

</remarks>
      <seealso cref="T:VkExtensionProperties" />
      <seealso cref="T:VkPhysicalDevice" />
    </member>
    <member name="T:VkBufferImageCopy">
      <summary>Structure specifying a buffer image copy operation</summary>
      <remarks>

When copying to or from a depth or stencil aspect, the data in buffer memory
uses a layout that is a (mostly) tightly packed representation of the depth
or stencil data.
Specifically:

<list type="bullet"><item><description>
data copied to or from the stencil aspect of any depth/stencil format is
tightly packed with one <c>VK_FORMAT_S8_UINT</c> value per texel.
</description></item><item><description>
data copied to or from the depth aspect of a <c>VK_FORMAT_D16_UNORM</c>
or <c>VK_FORMAT_D16_UNORM_S8_UINT</c> format is tightly packed with one
<c>VK_FORMAT_D16_UNORM</c> value per texel.
</description></item><item><description>
data copied to or from the depth aspect of a <c>VK_FORMAT_D32_SFLOAT</c>
or <c>VK_FORMAT_D32_SFLOAT_S8_UINT</c> format is tightly packed with one
<c>VK_FORMAT_D32_SFLOAT</c> value per texel.
</description></item><item><description>
data copied to or from the depth aspect of a
<c>VK_FORMAT_X8_D24_UNORM_PACK32</c> or <c>VK_FORMAT_D24_UNORM_S8_UINT</c>
format is packed with one 32-bit word per texel with the D24 value in
the LSBs of the word, and undefined values in the eight MSBs.
</description></item></list>
<list type="table"><tr><td><i title="Note"></i></td><td>
Note

To copy both the depth and stencil aspects of a depth/stencil format, two
entries in <c>pRegions</c> can be used, where one specifies the depth aspect
in <c>imageSubresource</c>, and the other specifies the stencil aspect.

</td></tr></list>

Because depth or stencil aspect buffer to image copies  may require format
conversions on some implementations, they are not supported on queues that
do not support graphics.
When copying to a depth aspect, the data in buffer memory  must be in the
the range  [0,1] or undefined results occur.


Copies are done layer by layer starting with image layer
<c>baseArrayLayer</c> member of <c>imageSubresource</c>.
<c>layerCount</c> layers are copied from the source image or to the
destination image.



Valid Usage
<list type="bullet"><item><description>

If the the calling command&amp;#8217;s <c>VkImage</c> parameter&amp;#8217;s format is not a
depth/stencil format, then <c>bufferOffset</c> must  be a multiple of the
format&amp;#8217;s element size
</description></item><item><description>
<c>bufferOffset</c> must be a multiple of <c>4</c>
</description></item><item><description>
<c>bufferRowLength</c> must be <c>0</c>, or greater than or equal to the
<c>width</c> member of <c>imageExtent</c>
</description></item><item><description>
<c>bufferImageHeight</c> must be <c>0</c>, or greater than or equal to the
<c>height</c> member of <c>imageExtent</c>
</description></item><item><description>
<c>imageOffset.x</c> and  (<c>imageExtent.width</c> + 
<c>imageOffset.x</c>) must both be greater than or equal to <c>0</c> and
less than or equal to the image subresource width
</description></item><item><description>
<c>imageOffset.y</c> and  (imageExtent.height + 
<c>imageOffset.y</c>) must both be greater than or equal to <c>0</c> and
less than or equal to the image subresource height
</description></item><item><description>

If the calling command&amp;#8217;s <c>srcImage</c> (<see cref="T:vkCmdCopyImageToBuffer" />)
or <c>dstImage</c> (<see cref="T:vkCmdCopyBufferToImage" />) is of type
<c>VK_IMAGE_TYPE_1D</c>, then <c>imageOffset.y</c> must be <c>0</c> and
<c>imageExtent.height</c> must be <c>1</c>.
</description></item><item><description>
<c>imageOffset.z</c> and  (imageExtent.depth + 
<c>imageOffset.z</c>) must both be greater than or equal to <c>0</c> and
less than or equal to the image subresource depth
</description></item><item><description>

If the calling command&amp;#8217;s <c>srcImage</c> (<see cref="T:vkCmdCopyImageToBuffer" />)
or <c>dstImage</c> (<see cref="T:vkCmdCopyBufferToImage" />) is of type
<c>VK_IMAGE_TYPE_1D</c> or <c>VK_IMAGE_TYPE_2D</c>, then
<c>imageOffset.z</c> must be <c>0</c> and <c>imageExtent.depth</c> must be
<c>1</c>.
</description></item><item><description>

If the calling command&amp;#8217;s <c>VkImage</c> parameter is a compressed format
image, <c>bufferRowLength</c> must  be a multiple of the compressed texel
block width
</description></item><item><description>

If the calling command&amp;#8217;s <c>VkImage</c> parameter is a compressed format
image, <c>bufferImageHeight</c> must  be a multiple of the compressed
texel block height
</description></item><item><description>

If the calling command&amp;#8217;s <c>VkImage</c> parameter is a compressed format
image, all members of <c>imageOffset</c> must  be a multiple of the
corresponding dimensions of the compressed texel block
</description></item><item><description>

If the calling command&amp;#8217;s <c>VkImage</c> parameter is a compressed format
image, <c>bufferOffset</c> must  be a multiple of the compressed texel
block size in bytes
</description></item><item><description>

If the calling command&amp;#8217;s <c>VkImage</c> parameter is a compressed format
image, <c>imageExtent.width</c> must be a multiple of the compressed
texel block width or  (<c>imageExtent.width</c> + 
<c>imageOffset.x</c>) must  equal the image subresource width
</description></item><item><description>

If the calling command&amp;#8217;s <c>VkImage</c> parameter is a compressed format
image, <c>imageExtent.height</c> must be a multiple of the compressed
texel block height or  (<c>imageExtent.height</c> + 
<c>imageOffset.y</c>) must  equal the image subresource height
</description></item><item><description>

If the calling command&amp;#8217;s <c>VkImage</c> parameter is a compressed format
image, <c>imageExtent.depth</c> must be a multiple of the compressed
texel block depth or  (<c>imageExtent.depth</c> + 
<c>imageOffset.z</c>) must  equal the image subresource depth
</description></item><item><description>
<c>bufferOffset</c>, <c>bufferRowLength</c>, <c>bufferImageHeight</c> and
all members of <c>imageOffset</c> and <c>imageExtent</c> must respect the
image transfer granularity requirements of the queue family that it will
be submitted against, as described in
<a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#devsandqueues-physical-device-enumeration">Physical Device
Enumeration</a>
</description></item><item><description>

The <c>aspectMask</c> member of <c>imageSubresource</c> must specify
aspects present in the calling command&amp;#8217;s <c>VkImage</c> parameter
</description></item><item><description>

The <c>aspectMask</c> member of <c>imageSubresource</c> must  only have a
single bit set
</description></item><item><description>

If the calling command&amp;#8217;s <c>VkImage</c> parameter is of <see cref="T:VkImageType" /><c>VK_IMAGE_TYPE_3D</c>, the <c>baseArrayLayer</c> and <c>layerCount</c>
members of <c>imageSubresource</c> must be <c>0</c> and <c>1</c>, respectively
</description></item><item><description>

When copying to the depth aspect of an image subresource, the data in
the source buffer  must be in the range  [0,1]
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>imageSubresource</c> must be a valid <c>VkImageSubresourceLayers</c> structure
</description></item></list>




For both <see cref="T:vkCmdCopyBufferToImage" /> and <see cref="T:vkCmdCopyImageToBuffer" />, each
element of <c>pRegions</c> is a structure defined as:


<code> typedef struct VkBufferImageCopy {
    VkDeviceSize                bufferOffset;
    uint32_t                    bufferRowLength;
    uint32_t                    bufferImageHeight;
    VkImageSubresourceLayers    imageSubresource;
    VkOffset3D                  imageOffset;
    VkExtent3D                  imageExtent;
} VkBufferImageCopy; </code>

</remarks>
      <seealso cref="T:VkExtent3D" />
      <seealso cref="T:VkImageSubresourceLayers" />
      <seealso cref="T:VkOffset3D" />
      <seealso cref="T:vkCmdCopyBufferToImage" />
      <seealso cref="T:vkCmdCopyImageToBuffer" />
    </member>
    <member name="T:vkDestroyPipelineCache">
      <summary>Destroy a pipeline cache object</summary>
      <remarks>


Valid Usage
<list type="bullet"><item><description>

If <c>VkAllocationCallbacks</c> were provided when <c>pipelineCache</c>
was created, a compatible set of callbacks  must be provided here
</description></item><item><description>

If no <c>VkAllocationCallbacks</c> were provided when <c>pipelineCache</c>
was created, <c>pAllocator</c> must be <c>NULL</c>
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>device</c> must be a valid <c>VkDevice</c> handle
</description></item><item><description>
 If <c>pipelineCache</c> is not <see cref="!:VK_NULL_HANDLE" />, <c>pipelineCache</c> must be a valid <c>VkPipelineCache</c> handle
</description></item><item><description>
 If <c>pAllocator</c> is not <c>NULL</c>, <c>pAllocator</c> must be a pointer to a valid <c>VkAllocationCallbacks</c> structure
</description></item><item><description>
 If <c>pipelineCache</c> is a valid handle, it  must have been created, allocated, or retrieved from <c>device</c>
</description></item></list>




Host Synchronization
<list type="bullet"><item><description>
Host access to <c>pipelineCache</c> must  be externally synchronized
</description></item></list>




To destroy a pipeline cache, call:


<code> void vkDestroyPipelineCache(
    VkDevice                                    device,
    VkPipelineCache                             pipelineCache,
    const VkAllocationCallbacks*                pAllocator); </code>

</remarks>
      <seealso cref="T:IVkAllocationCallbacks" />
      <seealso cref="T:VkDevice" />
      <seealso cref="T:VkPipelineCache" />
    </member>
    <member name="T:vkCreateFence">
      <summary>Create a new fence object</summary>
      <remarks>


Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>device</c> must be a valid <c>VkDevice</c> handle
</description></item><item><description>
<c>pCreateInfo</c> must be a pointer to a valid <c>VkFenceCreateInfo</c> structure
</description></item><item><description>
 If <c>pAllocator</c> is not <c>NULL</c>, <c>pAllocator</c> must be a pointer to a valid <c>VkAllocationCallbacks</c> structure
</description></item><item><description>
<c>pFence</c> must be a pointer to a <c>VkFence</c> handle
</description></item></list>




Return Codes
<dl><dt>On success, this command returns</dt><dd>
<list type="bullet"><item><description>
<c>VK_SUCCESS</c>
</description></item></list>
</dd><dt>On failure, this command returns</dt><dd>
<list type="bullet"><item><description>
<c>VK_ERROR_OUT_OF_HOST_MEMORY</c>
</description></item><item><description>
<c>VK_ERROR_OUT_OF_DEVICE_MEMORY</c>
</description></item></list>
</dd></dl>




To create a fence, call:


<code> VkResult vkCreateFence(
    VkDevice                                    device,
    const VkFenceCreateInfo*                    pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkFence*                                    pFence); </code>

</remarks>
      <seealso cref="T:IVkAllocationCallbacks" />
      <seealso cref="T:VkDevice" />
      <seealso cref="T:VkFence" />
      <seealso cref="T:IVkFenceCreateInfo" />
    </member>
    <member name="T:vkGetDisplayPlaneCapabilitiesKHR" />
    <member name="T:vkDestroyCommandPool">
      <summary>Destroy a command pool object</summary>
      <remarks>

When a pool is destroyed, all command buffers allocated from the pool are
<a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkFreeCommandBuffers">freed</a>.


Any primary command buffer allocated from another <see cref="T:VkCommandPool" /> that
is in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#commandbuffers-lifecycle">recording or executable state</a> and
has a secondary command buffer allocated from <c>commandPool</c> recorded
into it, becomes <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#commandbuffers-lifecycle">invalid</a>.



Valid Usage
<list type="bullet"><item><description>

All <c>VkCommandBuffer</c> objects allocated from <c>commandPool</c> must
not be in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#commandbuffers-lifecycle">pending state</a>.
</description></item><item><description>

If <c>VkAllocationCallbacks</c> were provided when <c>commandPool</c> was
created, a compatible set of callbacks  must be provided here
</description></item><item><description>

If no <c>VkAllocationCallbacks</c> were provided when <c>commandPool</c>
was created, <c>pAllocator</c> must be <c>NULL</c>
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>device</c> must be a valid <c>VkDevice</c> handle
</description></item><item><description>
 If <c>commandPool</c> is not <see cref="!:VK_NULL_HANDLE" />, <c>commandPool</c> must be a valid <c>VkCommandPool</c> handle
</description></item><item><description>
 If <c>pAllocator</c> is not <c>NULL</c>, <c>pAllocator</c> must be a pointer to a valid <c>VkAllocationCallbacks</c> structure
</description></item><item><description>
 If <c>commandPool</c> is a valid handle, it  must have been created, allocated, or retrieved from <c>device</c>
</description></item></list>




Host Synchronization
<list type="bullet"><item><description>
Host access to <c>commandPool</c> must  be externally synchronized
</description></item></list>




To destroy a command pool, call:


<code> void vkDestroyCommandPool(
    VkDevice                                    device,
    VkCommandPool                               commandPool,
    const VkAllocationCallbacks*                pAllocator); </code>

</remarks>
      <seealso cref="T:IVkAllocationCallbacks" />
      <seealso cref="T:VkCommandPool" />
      <seealso cref="T:VkDevice" />
    </member>
    <member name="T:IVkWriteDescriptorSet">
      <summary>Structure specifying the parameters of a descriptor set write operation</summary>
      <remarks>

Only one of <c>pImageInfo</c>, <c>pBufferInfo</c>, or <c>pTexelBufferView</c>
members is used according to the descriptor type specified in the
<c>descriptorType</c> member of the containing <c>VkWriteDescriptorSet</c>
structure, as specified below.


If the <c>dstBinding</c> has fewer than <c>descriptorCount</c> array elements
remaining starting from <c>dstArrayElement</c>, then the remainder will be
used to update the subsequent binding - <c>dstBinding</c>+1 starting at array
element zero.
If a binding has a <c>descriptorCount</c> of zero, it is skipped.
This behavior applies recursively, with the update affecting consecutive
bindings as needed to update all <c>descriptorCount</c> descriptors.



Valid Usage
<list type="bullet"><item><description>
<c>dstBinding</c> must be less than or equal to the maximum value of
<c>binding</c> of all <see cref="T:IVkDescriptorSetLayoutBinding" /> structures
specified when <c>dstSet</c>&amp;#8217;s descriptor set layout was created
</description></item><item><description>
<c>dstBinding</c> must be a binding with a non-zero
<c>descriptorCount</c>
</description></item><item><description>

All consecutive bindings updated via a single <c>VkWriteDescriptorSet</c>
structure, except those with a <c>descriptorCount</c> of zero,  must have
identical <c>descriptorType</c> and <c>stageFlags</c>.
</description></item><item><description>

All consecutive bindings updated via a single <c>VkWriteDescriptorSet</c>
structure, except those with a <c>descriptorCount</c> of zero,  must all
either use immutable samplers or  must all not use immutable samplers.
</description></item><item><description>
<c>descriptorType</c> must match the type of <c>dstBinding</c> within
<c>dstSet</c>
</description></item><item><description>
<c>dstSet</c> must be a valid <see cref="T:VkDescriptorSet" /> handle
</description></item><item><description>

The sum of <c>dstArrayElement</c> and <c>descriptorCount</c> must be less
than or equal to the number of array elements in the descriptor set
binding specified by <c>dstBinding</c>, and all applicable consecutive
bindings, as described by <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#descriptorsets-updates-consecutive">../../html/vkspec.html#descriptorsets-updates-consecutive</a>
</description></item><item><description>

If <c>descriptorType</c> is <c>VK_DESCRIPTOR_TYPE_SAMPLER</c>,
<c>VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER</c>,
<c>VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE</c>,
<c>VK_DESCRIPTOR_TYPE_STORAGE_IMAGE</c>, or
<c>VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT</c>, <c>pImageInfo</c> must be a
pointer to an array of <c>descriptorCount</c> valid
<c>VkDescriptorImageInfo</c> structures
</description></item><item><description>

If <c>descriptorType</c> is <c>VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER</c>
or <c>VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER</c>, <c>pTexelBufferView</c> must be a pointer to an array of <c>descriptorCount</c> valid
<c>VkBufferView</c> handles
</description></item><item><description>

If <c>descriptorType</c> is <c>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER</c>,
<c>VK_DESCRIPTOR_TYPE_STORAGE_BUFFER</c>,
<c>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC</c>, or
<c>VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC</c>, <c>pBufferInfo</c> must
be a pointer to an array of <c>descriptorCount</c> valid
<c>VkDescriptorBufferInfo</c> structures
</description></item><item><description>

If <c>descriptorType</c> is <c>VK_DESCRIPTOR_TYPE_SAMPLER</c> or
<c>VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER</c>, and <c>dstSet</c> was
not allocated with a layout that included immutable samplers for
<c>dstBinding</c> with <c>descriptorType</c>, the <c>sampler</c> member of
any given element of <c>pImageInfo</c> must be a valid <c>VkSampler</c>
object
</description></item><item><description>

If <c>descriptorType</c> is
<c>VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER</c>,
<c>VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE</c>,
<c>VK_DESCRIPTOR_TYPE_STORAGE_IMAGE</c>, or
<c>VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT</c>, the <c>imageView</c> and
<c>imageLayout</c> members of any given element of <c>pImageInfo</c> must
be a valid <c>VkImageView</c> and <see cref="T:VkImageLayout" />, respectively
</description></item><item><description>

If <c>descriptorType</c> is <c>VK_DESCRIPTOR_TYPE_STORAGE_IMAGE</c>, for
each descriptor that will be accessed via load or store operations the
<c>imageLayout</c> member for corresponding elements of <c>pImageInfo</c> must be <c>VK_IMAGE_LAYOUT_GENERAL</c>
</description></item><item><description>

If <c>descriptorType</c> is <c>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER</c> or
<c>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC</c>, the <c>offset</c> member
of any given element of <c>pBufferInfo</c> must be a multiple of
<c>VkPhysicalDeviceLimits</c>::<c>minUniformBufferOffsetAlignment</c>
</description></item><item><description>

If <c>descriptorType</c> is <c>VK_DESCRIPTOR_TYPE_STORAGE_BUFFER</c> or
<c>VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC</c>, the <c>offset</c> member
of any given element of <c>pBufferInfo</c> must be a multiple of
<c>VkPhysicalDeviceLimits</c>::<c>minStorageBufferOffsetAlignment</c>
</description></item><item><description>

If <c>descriptorType</c> is <c>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER</c>,
<c>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC</c>,
<c>VK_DESCRIPTOR_TYPE_STORAGE_BUFFER</c>, or
<c>VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC</c>, the <c>buffer</c> member
of any given element of <c>pBufferInfo</c> that is non-sparse  must be
bound completely and contiguously to a single <c>VkDeviceMemory</c>
object
</description></item><item><description>

If <c>descriptorType</c> is <c>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER</c> or
<c>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC</c>, the <c>buffer</c> member
of any given element of <c>pBufferInfo</c> must have been created with
<c>VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT</c> set
</description></item><item><description>

If <c>descriptorType</c> is <c>VK_DESCRIPTOR_TYPE_STORAGE_BUFFER</c> or
<c>VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC</c>, the <c>buffer</c> member
of any given element of <c>pBufferInfo</c> must have been created with
<c>VK_BUFFER_USAGE_STORAGE_BUFFER_BIT</c> set
</description></item><item><description>

If <c>descriptorType</c> is <c>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER</c> or
<c>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC</c>, the <c>range</c> member
of any given element of <c>pBufferInfo</c>, or the effective range if
<c>range</c> is <c>VK_WHOLE_SIZE</c>,  must be less than or equal to
<c>VkPhysicalDeviceLimits</c>::<c>maxUniformBufferRange</c>
</description></item><item><description>

If <c>descriptorType</c> is <c>VK_DESCRIPTOR_TYPE_STORAGE_BUFFER</c> or
<c>VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC</c>, the <c>range</c> member
of any given element of <c>pBufferInfo</c>, or the effective range if
<c>range</c> is <c>VK_WHOLE_SIZE</c>,  must be less than or equal to
<c>VkPhysicalDeviceLimits</c>::<c>maxStorageBufferRange</c>
</description></item><item><description>

If <c>descriptorType</c> is
<c>VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER</c>, the <c>VkBuffer</c> that
any given element of <c>pTexelBufferView</c> was created from  must have
been created with <c>VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT</c> set
</description></item><item><description>

If <c>descriptorType</c> is
<c>VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER</c>, the <c>VkBuffer</c> that
any given element of <c>pTexelBufferView</c> was created from  must have
been created with <c>VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT</c> set
</description></item><item><description>

If <c>descriptorType</c> is <c>VK_DESCRIPTOR_TYPE_STORAGE_IMAGE</c> or
<c>VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT</c>, the <c>imageView</c> member of
any given element of <c>pImageInfo</c> must  have been created with the
identity swizzle
</description></item><item><description>

If <c>descriptorType</c> is <c>VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE</c> or
<c>VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER</c>, the <c>imageView</c>
member of any given element of <c>pImageInfo</c> must have been created
with <c>VK_IMAGE_USAGE_SAMPLED_BIT</c> set
</description></item><item><description>

If <c>descriptorType</c> is <c>VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE</c> or
<c>VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER</c>, the <c>imageLayout</c>
member of any given element of <c>pImageInfo</c> must be
<c>VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL</c>,
<c>VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL</c> or
<c>VK_IMAGE_LAYOUT_GENERAL</c>
</description></item><item><description>

If <c>descriptorType</c> is <c>VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT</c>,
the <c>imageView</c> member of any given element of <c>pImageInfo</c> must have been created with <c>VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT</c>
set
</description></item><item><description>

If <c>descriptorType</c> is <c>VK_DESCRIPTOR_TYPE_STORAGE_IMAGE</c>, the
<c>imageView</c> member of any given element of <c>pImageInfo</c> must
have been created with <c>VK_IMAGE_USAGE_STORAGE_BIT</c> set
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>sType</c> must be <c>VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET</c>
</description></item><item><description>
<c>pNext</c> must be <c>NULL</c>
</description></item><item><description>
<c>descriptorType</c> must be a valid <see cref="T:VkDescriptorType" /> value
</description></item><item><description>
<c>descriptorCount</c> must be greater than <c>0</c>
</description></item><item><description>
 Both of <c>dstSet</c>, and the elements of <c>pTexelBufferView</c> that are valid handles  must have been created, allocated, or retrieved from the same <c>VkDevice</c>
</description></item></list>




The <c>VkWriteDescriptorSet</c> structure is defined as:


<code> typedef struct VkWriteDescriptorSet {
    VkStructureType                  sType;
    const void*                      pNext;
    VkDescriptorSet                  dstSet;
    uint32_t                         dstBinding;
    uint32_t                         dstArrayElement;
    uint32_t                         descriptorCount;
    VkDescriptorType                 descriptorType;
    const VkDescriptorImageInfo*     pImageInfo;
    const VkDescriptorBufferInfo*    pBufferInfo;
    const VkBufferView*              pTexelBufferView;
} VkWriteDescriptorSet; </code>

</remarks>
      <seealso cref="T:VkBufferView" />
      <seealso cref="T:VkDescriptorBufferInfo" />
      <seealso cref="T:VkDescriptorImageInfo" />
      <seealso cref="T:VkDescriptorSet" />
      <seealso cref="T:VkDescriptorType" />
      <seealso cref="T:VkStructureType" />
      <seealso cref="T:vkUpdateDescriptorSets" />
    </member>
    <member name="T:VkWriteDescriptorSet32">
      <summary>See: <see cref="T:IVkWriteDescriptorSet" /></summary>
      <seealso cref="T:IVkWriteDescriptorSet" />
    </member>
    <member name="T:VkWriteDescriptorSet64">
      <summary>See: <see cref="T:IVkWriteDescriptorSet" /></summary>
      <seealso cref="T:IVkWriteDescriptorSet" />
    </member>
    <member name="T:IVkPhysicalDeviceExternalImageFormatInfoKHX" />
    <member name="T:VkPhysicalDeviceExternalImageFormatInfoKHX32">
      <summary>See: <see cref="T:IVkPhysicalDeviceExternalImageFormatInfoKHX" /></summary>
      <seealso cref="T:IVkPhysicalDeviceExternalImageFormatInfoKHX" />
    </member>
    <member name="T:VkPhysicalDeviceExternalImageFormatInfoKHX64">
      <summary>See: <see cref="T:IVkPhysicalDeviceExternalImageFormatInfoKHX" /></summary>
      <seealso cref="T:IVkPhysicalDeviceExternalImageFormatInfoKHX" />
    </member>
    <member name="T:VkVertexInputBindingDescription">
      <summary>Structure specifying vertex input binding description</summary>
      <remarks>


Valid Usage
<list type="bullet"><item><description>
<c>binding</c> must be less than
<c>VkPhysicalDeviceLimits</c>::<c>maxVertexInputBindings</c>
</description></item><item><description>
<c>stride</c> must be less than or equal to
<c>VkPhysicalDeviceLimits</c>::<c>maxVertexInputBindingStride</c>
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>inputRate</c> must be a valid <see cref="T:VkVertexInputRate" /> value
</description></item></list>




The <c>VkVertexInputBindingDescription</c> structure is defined as:


<code> typedef struct VkVertexInputBindingDescription {
    uint32_t             binding;
    uint32_t             stride;
    VkVertexInputRate    inputRate;
} VkVertexInputBindingDescription; </code>

</remarks>
      <seealso cref="T:IVkPipelineVertexInputStateCreateInfo" />
      <seealso cref="T:VkVertexInputRate" />
    </member>
    <member name="T:vkGetPhysicalDeviceQueueFamilyProperties">
      <summary>Reports properties of the queues of the specified physical device</summary>
      <remarks>

If <c>pQueueFamilyProperties</c> is <c>NULL</c>, then the number of queue families
available is returned in <c>pQueueFamilyPropertyCount</c>.
Otherwise, <c>pQueueFamilyPropertyCount</c> must point to a variable set by
the user to the number of elements in the <c>pQueueFamilyProperties</c>
array, and on return the variable is overwritten with the number of
structures actually written to <c>pQueueFamilyProperties</c>.
If <c>pQueueFamilyPropertyCount</c> is less than the number of queue families
available, at most <c>pQueueFamilyPropertyCount</c> structures will be
written.



Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>physicalDevice</c> must be a valid <c>VkPhysicalDevice</c> handle
</description></item><item><description>
<c>pQueueFamilyPropertyCount</c> must be a pointer to a <c>uint32_t</c> value
</description></item><item><description>
 If the value referenced by <c>pQueueFamilyPropertyCount</c> is not <c>0</c>, and <c>pQueueFamilyProperties</c> is not <c>NULL</c>, <c>pQueueFamilyProperties</c> must be a pointer to an array of <c>pQueueFamilyPropertyCount</c><c>VkQueueFamilyProperties</c> structures
</description></item></list>




To query properties of queues available on a physical device, call:


<code> void vkGetPhysicalDeviceQueueFamilyProperties(
    VkPhysicalDevice                            physicalDevice,
    uint32_t*                                   pQueueFamilyPropertyCount,
    VkQueueFamilyProperties*                    pQueueFamilyProperties); </code>

</remarks>
      <seealso cref="T:VkPhysicalDevice" />
      <seealso cref="T:VkQueueFamilyProperties" />
    </member>
    <member name="T:IVkDeviceGroupBindSparseInfoKHX" />
    <member name="T:VkDeviceGroupBindSparseInfoKHX32">
      <summary>See: <see cref="T:IVkDeviceGroupBindSparseInfoKHX" /></summary>
      <seealso cref="T:IVkDeviceGroupBindSparseInfoKHX" />
    </member>
    <member name="T:VkDeviceGroupBindSparseInfoKHX64">
      <summary>See: <see cref="T:IVkDeviceGroupBindSparseInfoKHX" /></summary>
      <seealso cref="T:IVkDeviceGroupBindSparseInfoKHX" />
    </member>
    <member name="T:VkViewportWScalingNV" />
    <member name="T:IVkFenceCreateInfo">
      <summary>Structure specifying parameters of a newly created fence</summary>
      <remarks>


Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>sType</c> must be <c>VK_STRUCTURE_TYPE_FENCE_CREATE_INFO</c>
</description></item><item><description>
<c>pNext</c> must be <c>NULL</c>
</description></item><item><description>
<c>flags</c> must be a valid combination of <see cref="T:VkFenceCreateFlags" /> values
</description></item></list>




The <c>VkFenceCreateInfo</c> structure is defined as:


<code> typedef struct VkFenceCreateInfo {
    VkStructureType       sType;
    const void*           pNext;
    VkFenceCreateFlags    flags;
} VkFenceCreateInfo; </code>

</remarks>
      <seealso cref="T:VkFenceCreateFlags" />
      <seealso cref="T:VkStructureType" />
      <seealso cref="T:vkCreateFence" />
    </member>
    <member name="T:VkFenceCreateInfo32">
      <summary>See: <see cref="T:IVkFenceCreateInfo" /></summary>
      <seealso cref="T:IVkFenceCreateInfo" />
    </member>
    <member name="T:VkFenceCreateInfo64">
      <summary>See: <see cref="T:IVkFenceCreateInfo" /></summary>
      <seealso cref="T:IVkFenceCreateInfo" />
    </member>
    <member name="T:vkCmdCopyQueryPoolResults">
      <summary>Copy the results of queries in a query pool to a buffer object</summary>
      <remarks>

<c>vkCmdCopyQueryPoolResults</c> is guaranteed to see the effect of previous
uses of <c>vkCmdResetQueryPool</c> in the same queue, without any additional
synchronization.
Thus, the results will always reflect the most recent use of the query.


<c>flags</c> has the same possible values described above for the <c>flags</c>
parameter of <see cref="T:vkGetQueryPoolResults" />, but the different style of
execution causes some subtle behavioral differences.
Because <c>vkCmdCopyQueryPoolResults</c> executes in order with respect to
other query commands, there is less ambiguity about which use of a query is
being requested.


If no bits are set in <c>flags</c>, results for all requested queries in the
available state are written as 32-bit unsigned integer values, and nothing
is written for queries in the unavailable state.


If <c>VK_QUERY_RESULT_64_BIT</c> is set, the results are written as an array
of 64-bit unsigned integer values as described for
<see cref="T:vkGetQueryPoolResults" />.


If <c>VK_QUERY_RESULT_WAIT_BIT</c> is set, the implementation will wait for
each query&amp;#8217;s status to be in the available state before retrieving the
numerical results for that query.
This is guaranteed to reflect the most recent use of the query on the same
queue, assuming that the query is not being simultaneously used by other
queues.
If the query does not become available in a finite amount of time (e.g. due
to not issuing a query since the last reset), a <c>VK_ERROR_DEVICE_LOST</c>
error  may occur.


Similarly, if <c>VK_QUERY_RESULT_WITH_AVAILABILITY_BIT</c> is set and
<c>VK_QUERY_RESULT_WAIT_BIT</c> is not set, the availability is guaranteed to
reflect the most recent use of the query on the same queue, assuming that
the query is not being simultaneously used by other queues.
As with <c>vkGetQueryPoolResults</c>, implementations  must guarantee that if
they return a non-zero availability value, then the numerical results are
valid.


If <c>VK_QUERY_RESULT_PARTIAL_BIT</c> is set, <c>VK_QUERY_RESULT_WAIT_BIT</c>
is not set, and the query&amp;#8217;s status is unavailable, an intermediate result
value between zero and the final result value is written for that query.


<c>VK_QUERY_RESULT_PARTIAL_BIT</c> must not be used if the pool&amp;#8217;s
<c>queryType</c> is <c>VK_QUERY_TYPE_TIMESTAMP</c>.


<c>vkCmdCopyQueryPoolResults</c> is considered to be a transfer operation,
and its writes to buffer memory  must be synchronized using
<c>VK_PIPELINE_STAGE_TRANSFER_BIT</c> and <c>VK_ACCESS_TRANSFER_WRITE_BIT</c>
before using the results.



Valid Usage
<list type="bullet"><item><description>
<c>dstOffset</c> must be less than the size of <c>dstBuffer</c>
</description></item><item><description>
<c>firstQuery</c> must be less than the number of queries in
<c>queryPool</c>
</description></item><item><description>

The sum of <c>firstQuery</c> and <c>queryCount</c> must be less than or
equal to the number of queries in <c>queryPool</c>
</description></item><item><description>

If <c>VK_QUERY_RESULT_64_BIT</c> is not set in <c>flags</c> then
<c>dstOffset</c> and <c>stride</c> must be multiples of <c>4</c>
</description></item><item><description>

If <c>VK_QUERY_RESULT_64_BIT</c> is set in <c>flags</c> then
<c>dstOffset</c> and <c>stride</c> must be multiples of <c>8</c>
</description></item><item><description>
<c>dstBuffer</c> must have enough storage, from <c>dstOffset</c>, to
contain the result of each query, as described
<a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#queries-operation-memorylayout">here</a>
</description></item><item><description>
<c>dstBuffer</c> must have been created with
<c>VK_BUFFER_USAGE_TRANSFER_DST_BIT</c> usage flag
</description></item><item><description>

If <c>dstBuffer</c> is non-sparse then it  must be bound completely and
contiguously to a single <c>VkDeviceMemory</c> object
</description></item><item><description>

If the <c>queryType</c> used to create <c>queryPool</c> was
<c>VK_QUERY_TYPE_TIMESTAMP</c>, <c>flags</c> must not contain
<c>VK_QUERY_RESULT_PARTIAL_BIT</c>
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>commandBuffer</c> must be a valid <c>VkCommandBuffer</c> handle
</description></item><item><description>
<c>queryPool</c> must be a valid <c>VkQueryPool</c> handle
</description></item><item><description>
<c>dstBuffer</c> must be a valid <c>VkBuffer</c> handle
</description></item><item><description>
<c>flags</c> must be a valid combination of <see cref="T:VkQueryResultFlags" /> values
</description></item><item><description>
<c>commandBuffer</c> must be in the  recording state
</description></item><item><description>
 The <c>VkCommandPool</c> that <c>commandBuffer</c> was allocated from  must support graphics, or compute operations
</description></item><item><description>
 This command  must only be called outside of a render pass instance
</description></item><item><description>
 Each of <c>commandBuffer</c>, <c>dstBuffer</c>, and <c>queryPool</c> must have been created, allocated, or retrieved from the same <c>VkDevice</c>
</description></item></list>




Host Synchronization
<list type="bullet"><item><description>
Host access to <c>commandBuffer</c> must  be externally synchronized
</description></item><item><description>
Host access to the <c>VkCommandPool</c> that <c>commandBuffer</c> was allocated from  must be externally synchronized
</description></item></list>




Command Properties
<list type="table">       <listheader><tr><term> Command Buffer Levels </term><term> Render Pass Scope </term><term> Supported Queue Types </term><term> Pipeline Type </term></tr></listheader>
<item><term>
Primary<br />
Secondary
</term><term>
Outside
</term><term>
Graphics<br />
compute
</term><term>
Transfer
</term></item>
</list>



To copy query statuses and numerical results directly to buffer memory,
call:


<code> void vkCmdCopyQueryPoolResults(
    VkCommandBuffer                             commandBuffer,
    VkQueryPool                                 queryPool,
    uint32_t                                    firstQuery,
    uint32_t                                    queryCount,
    VkBuffer                                    dstBuffer,
    VkDeviceSize                                dstOffset,
    VkDeviceSize                                stride,
    VkQueryResultFlags                          flags); </code>

</remarks>
      <seealso cref="T:VkBuffer" />
      <seealso cref="T:VkCommandBuffer" />
      <seealso cref="T:VkQueryPool" />
      <seealso cref="T:VkQueryResultFlags" />
    </member>
    <member name="T:IVkBindBufferMemoryInfoKHX" />
    <member name="T:VkBindBufferMemoryInfoKHX32">
      <summary>See: <see cref="T:IVkBindBufferMemoryInfoKHX" /></summary>
      <seealso cref="T:IVkBindBufferMemoryInfoKHX" />
    </member>
    <member name="T:VkBindBufferMemoryInfoKHX64">
      <summary>See: <see cref="T:IVkBindBufferMemoryInfoKHX" /></summary>
      <seealso cref="T:IVkBindBufferMemoryInfoKHX" />
    </member>
    <member name="T:VkExternalImageFormatPropertiesNV" />
    <member name="T:vkGetImageSubresourceLayout">
      <summary>Retrieve information about an image subresource</summary>
      <remarks>

<see cref="T:vkGetImageSubresourceLayout" /> is invariant for the lifetime of a single
image.



Valid Usage
<list type="bullet"><item><description>
<c>image</c> must have been created with <c>tiling</c> equal to
<c>VK_IMAGE_TILING_LINEAR</c>
</description></item><item><description>

The <c>aspectMask</c> member of <c>pSubresource</c> must  only have a
single bit set
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>device</c> must be a valid <c>VkDevice</c> handle
</description></item><item><description>
<c>image</c> must be a valid <c>VkImage</c> handle
</description></item><item><description>
<c>pSubresource</c> must be a pointer to a valid <c>VkImageSubresource</c> structure
</description></item><item><description>
<c>pLayout</c> must be a pointer to a <c>VkSubresourceLayout</c> structure
</description></item><item><description>
<c>image</c> must have been created, allocated, or retrieved from <c>device</c>
</description></item></list>




To query the host access layout of an image subresource, for an image
created with linear tiling, call:


<code> void vkGetImageSubresourceLayout(
    VkDevice                                    device,
    VkImage                                     image,
    const VkImageSubresource*                   pSubresource,
    VkSubresourceLayout*                        pLayout); </code>

</remarks>
      <seealso cref="T:VkDevice" />
      <seealso cref="T:VkImage" />
      <seealso cref="T:VkImageSubresource" />
      <seealso cref="T:VkSubresourceLayout" />
    </member>
    <member name="T:IVkPipelineColorBlendStateCreateInfo">
      <summary>Structure specifying parameters of a newly created pipeline color blend state</summary>
      <remarks>

Each element of the <c>pAttachments</c> array is a
<see cref="T:VkPipelineColorBlendAttachmentState" /> structure specifying per-target
blending state for each individual color attachment.
If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-independentBlend">independent blending</a> feature
is not enabled on the device, all <see cref="T:VkPipelineColorBlendAttachmentState" />
elements in the <c>pAttachments</c> array  must be identical.



Valid Usage
<list type="bullet"><item><description>

If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-independentBlend">independent blending</a>
feature is not enabled, all elements of <c>pAttachments</c> must  be
identical
</description></item><item><description>

If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-logicOp">logic operations</a> feature is not
enabled, <c>logicOpEnable</c> must be <c>VK_FALSE</c>
</description></item><item><description>

If <c>logicOpEnable</c> is <c>VK_TRUE</c>, <c>logicOp</c> must be a valid
<see cref="T:VkLogicOp" /> value
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>sType</c> must be <c>VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO</c>
</description></item><item><description>
<c>pNext</c> must be <c>NULL</c>
</description></item><item><description>
<c>flags</c> must be <c>0</c>
</description></item><item><description>
 If <c>attachmentCount</c> is not <c>0</c>, <c>pAttachments</c> must be a pointer to an array of <c>attachmentCount</c> valid <c>VkPipelineColorBlendAttachmentState</c> structures
</description></item></list>




The <c>VkPipelineColorBlendStateCreateInfo</c> structure is defined as:


<code> typedef struct VkPipelineColorBlendStateCreateInfo {
    VkStructureType                               sType;
    const void*                                   pNext;
    VkPipelineColorBlendStateCreateFlags          flags;
    VkBool32                                      logicOpEnable;
    VkLogicOp                                     logicOp;
    uint32_t                                      attachmentCount;
    const VkPipelineColorBlendAttachmentState*    pAttachments;
    float                                         blendConstants[4];
} VkPipelineColorBlendStateCreateInfo; </code>

</remarks>
      <seealso cref="T:IVkGraphicsPipelineCreateInfo" />
      <seealso cref="T:VkLogicOp" />
      <seealso cref="T:VkPipelineColorBlendAttachmentState" />
      <seealso cref="T:VkPipelineColorBlendStateCreateFlags" />
      <seealso cref="T:VkStructureType" />
    </member>
    <member name="T:VkPipelineColorBlendStateCreateInfo32">
      <summary>See: <see cref="T:IVkPipelineColorBlendStateCreateInfo" /></summary>
      <seealso cref="T:IVkPipelineColorBlendStateCreateInfo" />
    </member>
    <member name="T:VkPipelineColorBlendStateCreateInfo64">
      <summary>See: <see cref="T:IVkPipelineColorBlendStateCreateInfo" /></summary>
      <seealso cref="T:IVkPipelineColorBlendStateCreateInfo" />
    </member>
    <member name="T:IVkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX" />
    <member name="T:VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX32">
      <summary>See: <see cref="T:IVkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX" /></summary>
      <seealso cref="T:IVkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX" />
    </member>
    <member name="T:VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX64">
      <summary>See: <see cref="T:IVkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX" /></summary>
      <seealso cref="T:IVkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX" />
    </member>
    <member name="T:VkClearColorValue">
      <summary>Structure specifying a clear color value</summary>
      <remarks>

The four array elements of the clear color map to R, G, B, and A components
of image formats, in order.


If the image has more than one sample, the same value is written to all
samples for any pixels being cleared.



The <c>VkClearColorValue</c> structure is defined as:


<code> typedef union VkClearColorValue {
    float       float32[4];
    int32_t     int32[4];
    uint32_t    uint32[4];
} VkClearColorValue; </code>

</remarks>
      <seealso cref="T:VkClearValue" />
      <seealso cref="T:vkCmdClearColorImage" />
    </member>
    <member name="T:VkObjectTablePipelineEntryNVX" />
    <member name="T:IVkPhysicalDeviceDiscardRectanglePropertiesEXT" />
    <member name="T:VkPhysicalDeviceDiscardRectanglePropertiesEXT32">
      <summary>See: <see cref="T:IVkPhysicalDeviceDiscardRectanglePropertiesEXT" /></summary>
      <seealso cref="T:IVkPhysicalDeviceDiscardRectanglePropertiesEXT" />
    </member>
    <member name="T:VkPhysicalDeviceDiscardRectanglePropertiesEXT64">
      <summary>See: <see cref="T:IVkPhysicalDeviceDiscardRectanglePropertiesEXT" /></summary>
      <seealso cref="T:IVkPhysicalDeviceDiscardRectanglePropertiesEXT" />
    </member>
    <member name="T:vkQueueBindSparse">
      <summary>Bind device memory to a sparse resource object</summary>
      <remarks>

<c>vkQueueBindSparse</c> is a <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#devsandqueues-submission">queue submission
command</a>, with each batch defined by an element of <c>pBindInfo</c> as an
instance of the <see cref="T:IVkBindSparseInfo" /> structure.
Batches begin execution in the order they appear in <c>pBindInfo</c>, but
 may complete out of order.


Within a batch, a given range of a resource  must not be bound more than
once.
Across batches, if a range is to be bound to one allocation and offset and
then to another allocation and offset, then the application  must guarantee
(usually using semaphores) that the binding operations are executed in the
correct order, as well as to order binding operations against the execution
of command buffer submissions.


As no operation to <see cref="T:vkQueueBindSparse" /> causes any pipeline stage to
access memory, synchronization primitives used in this command effectively
only define execution dependencies.


Additional information about fence and semaphore operation is described in
<a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization">the synchronization chapter</a>.



Valid Usage
<list type="bullet"><item><description>

If <c>fence</c> is not <see cref="!:VK_NULL_HANDLE" />, <c>fence</c> must  be
unsignaled
</description></item><item><description>

If <c>fence</c> is not <see cref="!:VK_NULL_HANDLE" />, <c>fence</c> must  not be
associated with any other queue command that has not yet completed
execution on that queue
</description></item><item><description>

Any given element of the <c>pSignalSemaphores</c> member of any element
of <c>pBindInfo</c> must  be unsignaled when the semaphore signal
operation it defines is executed on the device
</description></item><item><description>

When a semaphore unsignal operation defined by any element of the
<c>pWaitSemaphores</c> member of any element of <c>pBindInfo</c> executes
on <c>queue</c>, no other queue  must be waiting on the same semaphore.
</description></item><item><description>

All elements of the <c>pWaitSemaphores</c> member of all elements of
<c>pBindInfo</c> must be semaphores that are signaled, or have
<a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-semaphores-signaling">semaphore signal operations</a>
previously submitted for execution.
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>queue</c> must be a valid <c>VkQueue</c> handle
</description></item><item><description>
 If <c>bindInfoCount</c> is not <c>0</c>, <c>pBindInfo</c> must be a pointer to an array of <c>bindInfoCount</c> valid <c>VkBindSparseInfo</c> structures
</description></item><item><description>
 If <c>fence</c> is not <see cref="!:VK_NULL_HANDLE" />, <c>fence</c> must be a valid <c>VkFence</c> handle
</description></item><item><description>
 The <c>queue</c> must  support sparse binding operations
</description></item><item><description>
 Both of <c>fence</c>, and <c>queue</c> that are valid handles  must have been created, allocated, or retrieved from the same <c>VkDevice</c>
</description></item></list>




Host Synchronization
<list type="bullet"><item><description>
Host access to <c>queue</c> must  be externally synchronized
</description></item><item><description>
Host access to <c>pBindInfo</c>[].pWaitSemaphores[]  must be externally synchronized
</description></item><item><description>
Host access to <c>pBindInfo</c>[].pSignalSemaphores[]  must be externally synchronized
</description></item><item><description>
Host access to <c>pBindInfo</c>[].pBufferBinds[].buffer  must be externally synchronized
</description></item><item><description>
Host access to <c>pBindInfo</c>[].pImageOpaqueBinds[].image  must be externally synchronized
</description></item><item><description>
Host access to <c>pBindInfo</c>[].pImageBinds[].image  must be externally synchronized
</description></item><item><description>
Host access to <c>fence</c> must  be externally synchronized
</description></item></list>




Command Properties
<list type="table">       <listheader><tr><term> Command Buffer Levels </term><term> Render Pass Scope </term><term> Supported Queue Types </term><term> Pipeline Type </term></tr></listheader>
<item><term>
-
</term><term>
-
</term><term>
SPARSE_BINDING
</term><term>
-
</term></item>
</list>



Return Codes
<dl><dt>On success, this command returns</dt><dd>
<list type="bullet"><item><description>
<c>VK_SUCCESS</c>
</description></item></list>
</dd><dt>On failure, this command returns</dt><dd>
<list type="bullet"><item><description>
<c>VK_ERROR_OUT_OF_HOST_MEMORY</c>
</description></item><item><description>
<c>VK_ERROR_OUT_OF_DEVICE_MEMORY</c>
</description></item><item><description>
<c>VK_ERROR_DEVICE_LOST</c>
</description></item></list>
</dd></dl>




To submit sparse binding operations to a queue, call:


<code> VkResult vkQueueBindSparse(
    VkQueue                                     queue,
    uint32_t                                    bindInfoCount,
    const VkBindSparseInfo*                     pBindInfo,
    VkFence                                     fence); </code>

</remarks>
      <seealso cref="T:IVkBindSparseInfo" />
      <seealso cref="T:VkFence" />
      <seealso cref="T:VkQueue" />
    </member>
    <member name="T:vkCmdCopyImageToBuffer">
      <summary>Copy image data into a buffer</summary>
      <remarks>

Each region in <c>pRegions</c> is copied from the specified region of the
source image to the specified region of the destination buffer.



Valid Usage
<list type="bullet"><item><description>

The image region specified by a given element of <c>pRegions</c> must be
a region that is contained within <c>srcImage</c>
</description></item><item><description>

The buffer region specified by a given element of <c>pRegions</c> must
be a region that is contained within <c>dstBuffer</c>
</description></item><item><description>

The union of all source regions, and the union of all destination
regions, specified by the elements of <c>pRegions</c>,  must not overlap
in memory
</description></item><item><description>
<c>srcImage</c> must have been created with
<c>VK_IMAGE_USAGE_TRANSFER_SRC_BIT</c> usage flag
</description></item><item><description>

If <c>srcImage</c> is non-sparse then it  must be bound completely and
contiguously to a single <c>VkDeviceMemory</c> object
</description></item><item><description>
<c>srcImage</c> must have a sample count equal to
<c>VK_SAMPLE_COUNT_1_BIT</c>
</description></item><item><description>
<c>srcImageLayout</c> must specify the layout of the image subresources
of <c>srcImage</c> specified in <c>pRegions</c> at the time this command
is executed on a <c>VkDevice</c>
</description></item><item><description>
<c>srcImageLayout</c> must be <c>VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL</c>
or <c>VK_IMAGE_LAYOUT_GENERAL</c>
</description></item><item><description>
<c>dstBuffer</c> must have been created with
<c>VK_BUFFER_USAGE_TRANSFER_DST_BIT</c> usage flag
</description></item><item><description>

If <c>dstBuffer</c> is non-sparse then it  must be bound completely and
contiguously to a single <c>VkDeviceMemory</c> object
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>commandBuffer</c> must be a valid <c>VkCommandBuffer</c> handle
</description></item><item><description>
<c>srcImage</c> must be a valid <c>VkImage</c> handle
</description></item><item><description>
<c>srcImageLayout</c> must be a valid <see cref="T:VkImageLayout" /> value
</description></item><item><description>
<c>dstBuffer</c> must be a valid <c>VkBuffer</c> handle
</description></item><item><description>
<c>pRegions</c> must be a pointer to an array of <c>regionCount</c> valid <c>VkBufferImageCopy</c> structures
</description></item><item><description>
<c>commandBuffer</c> must be in the  recording state
</description></item><item><description>
 The <c>VkCommandPool</c> that <c>commandBuffer</c> was allocated from  must support transfer, graphics, or compute operations
</description></item><item><description>
 This command  must only be called outside of a render pass instance
</description></item><item><description>
<c>regionCount</c> must be greater than <c>0</c>
</description></item><item><description>
 Each of <c>commandBuffer</c>, <c>dstBuffer</c>, and <c>srcImage</c> must have been created, allocated, or retrieved from the same <c>VkDevice</c>
</description></item></list>




Host Synchronization
<list type="bullet"><item><description>
Host access to <c>commandBuffer</c> must  be externally synchronized
</description></item><item><description>
Host access to the <c>VkCommandPool</c> that <c>commandBuffer</c> was allocated from  must be externally synchronized
</description></item></list>




Command Properties
<list type="table">       <listheader><tr><term> Command Buffer Levels </term><term> Render Pass Scope </term><term> Supported Queue Types </term><term> Pipeline Type </term></tr></listheader>
<item><term>
Primary<br />
Secondary
</term><term>
Outside
</term><term>
Transfer<br />
graphics<br />
compute
</term><term>
Transfer
</term></item>
</list>



To copy data from an image object to a buffer object, call:


<code> void vkCmdCopyImageToBuffer(
    VkCommandBuffer                             commandBuffer,
    VkImage                                     srcImage,
    VkImageLayout                               srcImageLayout,
    VkBuffer                                    dstBuffer,
    uint32_t                                    regionCount,
    const VkBufferImageCopy*                    pRegions); </code>

</remarks>
      <seealso cref="T:VkBuffer" />
      <seealso cref="T:VkBufferImageCopy" />
      <seealso cref="T:VkCommandBuffer" />
      <seealso cref="T:VkImage" />
      <seealso cref="T:VkImageLayout" />
    </member>
    <member name="T:vkCmdSetDepthBias">
      <summary>Set the depth bias dynamic state</summary>
      <remarks>

If <c>depthBiasEnable</c> is <c>VK_FALSE</c>, no depth bias is applied and the
fragment&amp;#8217;s depth values are unchanged.


<c>depthBiasSlopeFactor</c> scales the maximum depth slope of the polygon,
and <c>depthBiasConstantFactor</c> scales an implementation-dependent
constant that relates to the usable resolution of the depth buffer.
The resulting values are summed to produce the depth bias value which is
then clamped to a minimum or maximum value specified by
<c>depthBiasClamp</c>.
<c>depthBiasSlopeFactor</c>, <c>depthBiasConstantFactor</c>, and
<c>depthBiasClamp</c> can  each be positive, negative, or zero.


The maximum depth slope  m of a triangle is



\[m = \sqrt{ \left({{\partial z_f} \over {\partial x_f}}\right)^2
        +  \left({{\partial z_f} \over {\partial y_f}}\right)^2}\]



where  (x<sub>f</sub>, y<sub>f</sub>, z<sub>f</sub>) is a point on the triangle.
 m may  be approximated as



\[m = \max\left( \left| { {\partial z_f} \over {\partial x_f} } \right|,
               \left| { {\partial z_f} \over {\partial y_f} } \right|
       \right).\]



The minimum resolvable difference  r is an implementation-dependent
parameter that depends on the depth buffer representation.
It is the smallest difference in framebuffer coordinate  z values that
is guaranteed to remain distinct throughout polygon rasterization and in the
depth buffer.
All pairs of fragments generated by the rasterization of two polygons with
otherwise identical vertices, but  <c>z</c><sub>f</sub> values that differ by
$r$, will have distinct depth values.


For fixed-point depth buffer representations,  r is constant throughout
the range of the entire depth buffer.
For floating-point depth buffers, there is no single minimum resolvable
difference.
In this case, the minimum resolvable difference for a given polygon is
dependent on the maximum exponent,  e, in the range of  z values
spanned by the primitive.
If  n is the number of bits in the floating-point mantissa, the minimum
resolvable difference,  r, for the given primitive is defined as

<dl><dt></dt><dd>
 r = 2<sup>e-n</sup> 
</dd></dl>

If no depth buffer is present,  r is undefined.


The bias value  o for a polygon is



\[o =
\begin{cases}
    m \times depthBiasSlopeFactor +
         r \times depthBiasConstantFactor  &amp; depthBiasClamp = 0\ or\ NaN \\
    \min(m \times depthBiasSlopeFactor +
         r \times depthBiasConstantFactor,
         depthBiasClamp)                   &amp; depthBiasClamp &gt; 0  \\
    \max(m \times depthBiasSlopeFactor +
         r \times depthBiasConstantFactor,
         depthBiasClamp)                   &amp; depthBiasClamp &lt; 0  \\
\end{cases}\]



 m is computed as described above.
If the depth buffer uses a fixed-point representation,  m is a function
of depth values in the range  [0,1], and  o is applied to depth
values in the same range.


For fixed-point depth buffers, fragment depth values are always limited to
the range  [0,1] by clamping after depth bias addition is performed.
Fragment depth values are clamped even when the depth buffer uses a
floating-point representation.



Valid Usage
<list type="bullet"><item><description>

The currently bound graphics pipeline  must have been created with the
<c>VK_DYNAMIC_STATE_DEPTH_BIAS</c> dynamic state enabled
</description></item><item><description>

If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-depthBiasClamp">depth bias clamping</a> feature
is not enabled, <c>depthBiasClamp</c> must be <c>0</c>.0
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>commandBuffer</c> must be a valid <c>VkCommandBuffer</c> handle
</description></item><item><description>
<c>commandBuffer</c> must be in the  recording state
</description></item><item><description>
 The <c>VkCommandPool</c> that <c>commandBuffer</c> was allocated from  must support graphics operations
</description></item></list>




Host Synchronization
<list type="bullet"><item><description>
Host access to <c>commandBuffer</c> must  be externally synchronized
</description></item><item><description>
Host access to the <c>VkCommandPool</c> that <c>commandBuffer</c> was allocated from  must be externally synchronized
</description></item></list>




Command Properties
<list type="table">       <listheader><tr><term> Command Buffer Levels </term><term> Render Pass Scope </term><term> Supported Queue Types </term><term> Pipeline Type </term></tr></listheader>
<item><term>
Primary<br />
Secondary
</term><term>
Both
</term><term>
Graphics
</term><term></term></item>
</list>



The depth values of all fragments generated by the rasterization of a
polygon  can be offset by a single value that is computed for that polygon.
This behavior is controlled by the <c>depthBiasEnable</c>,
<c>depthBiasConstantFactor</c>, <c>depthBiasClamp</c>, and
<c>depthBiasSlopeFactor</c> members of
<see cref="T:IVkPipelineRasterizationStateCreateInfo" />, or by the corresponding
parameters to the <c>vkCmdSetDepthBias</c> command if depth bias state is
dynamic.


<code> void vkCmdSetDepthBias(
    VkCommandBuffer                             commandBuffer,
    float                                       depthBiasConstantFactor,
    float                                       depthBiasClamp,
    float                                       depthBiasSlopeFactor); </code>

</remarks>
      <seealso cref="T:VkCommandBuffer" />
    </member>
    <member name="T:VkPhysicalDevice">
      <summary>Opaque handle to a physical device object</summary>
      <remarks>

Vulkan separates the concept of  physical and  logical devices.
A physical device usually represents a single device in a system (perhaps
made up of several individual hardware devices working together), of which
there are a finite number.
A logical device represents an application&amp;#8217;s view of the device.


Physical devices are represented by <c>VkPhysicalDevice</c> handles:


<code> VK_DEFINE_HANDLE(VkPhysicalDevice) </code>

</remarks>
      <seealso cref="T:vkCreateDevice" />
      <seealso cref="T:vkEnumerateDeviceExtensionProperties" />
      <seealso cref="T:vkEnumerateDeviceLayerProperties" />
      <seealso cref="T:vkEnumeratePhysicalDevices" />
      <seealso cref="T:vkGetPhysicalDeviceFeatures" />
      <seealso cref="T:vkGetPhysicalDeviceFormatProperties" />
      <seealso cref="T:vkGetPhysicalDeviceImageFormatProperties" />
      <seealso cref="T:vkGetPhysicalDeviceMemoryProperties" />
      <seealso cref="T:vkGetPhysicalDeviceProperties" />
      <seealso cref="T:vkGetPhysicalDeviceQueueFamilyProperties" />
      <seealso cref="T:vkGetPhysicalDeviceSparseImageFormatProperties" />
    </member>
    <member name="T:VkPhysicalDeviceMemoryProperties">
      <summary>Structure specifying physical device memory properties</summary>
      <remarks>

The <c>VkPhysicalDeviceMemoryProperties</c> structure describes a number of
 memory heaps as well as a number of  memory types that  can be used to
access memory allocated in those heaps.
Each heap describes a memory resource of a particular size, and each memory
type describes a set of memory properties (e.g. host cached vs uncached)
that  can be used with a given memory heap.
Allocations using a particular memory type will consume resources from the
heap indicated by that memory type&amp;#8217;s heap index.
More than one memory type  may share each heap, and the heaps and memory
types provide a mechanism to advertise an accurate size of the physical
memory resources while allowing the memory to be used with a variety of
different properties.


The number of memory heaps is given by <c>memoryHeapCount</c> and is less
than or equal to <c>VK_MAX_MEMORY_HEAPS</c>.
Each heap is described by an element of the <c>memoryHeaps</c> array, as a
<c>VkMemoryHeap</c> structure.
The number of memory types available across all memory heaps is given by
<c>memoryTypeCount</c> and is less than or equal to
<c>VK_MAX_MEMORY_TYPES</c>.
Each memory type is described by an element of the <c>memoryTypes</c> array,
as a <c>VkMemoryType</c> structure.


At least one heap  must include <c>VK_MEMORY_HEAP_DEVICE_LOCAL_BIT</c> in
<see cref="T:VkMemoryHeap" />::<c>flags</c>.
If there are multiple heaps that all have similar performance
characteristics, they  may all include
<c>VK_MEMORY_HEAP_DEVICE_LOCAL_BIT</c>.
In a unified memory architecture (UMA) system, there is often only a single
memory heap which is considered to be equally &amp;#8220;local&amp;#8221; to the host and to
the device, and such an implementation  must advertise the heap as
device-local.


Each memory type returned by <see cref="T:vkGetPhysicalDeviceMemoryProperties" /> must
have its <c>propertyFlags</c> set to one of the following values:

<list type="bullet"><item><description>
0
</description></item><item><description>
<c>VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT</c> |
<c>VK_MEMORY_PROPERTY_HOST_COHERENT_BIT</c>
</description></item><item><description>
<c>VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT</c> |
<c>VK_MEMORY_PROPERTY_HOST_CACHED_BIT</c>
</description></item><item><description>
<c>VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT</c> |
<c>VK_MEMORY_PROPERTY_HOST_CACHED_BIT</c> |
<c>VK_MEMORY_PROPERTY_HOST_COHERENT_BIT</c>
</description></item><item><description>
<c>VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT</c>
</description></item><item><description>
<c>VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT</c> |
<c>VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT</c> |
<c>VK_MEMORY_PROPERTY_HOST_COHERENT_BIT</c>
</description></item><item><description>
<c>VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT</c> |
<c>VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT</c> |
<c>VK_MEMORY_PROPERTY_HOST_CACHED_BIT</c>
</description></item><item><description>
<c>VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT</c> |
<c>VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT</c> |
<c>VK_MEMORY_PROPERTY_HOST_CACHED_BIT</c> |
<c>VK_MEMORY_PROPERTY_HOST_COHERENT_BIT</c>
</description></item><item><description>
<c>VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT</c> |
<c>VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT</c>
</description></item></list>

There  must be at least one memory type with both the
<c>VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT</c> and
<c>VK_MEMORY_PROPERTY_HOST_COHERENT_BIT</c> bits set in its
<c>propertyFlags</c>.
There  must be at least one memory type with the
<c>VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT</c> bit set in its
<c>propertyFlags</c>.


The memory types are sorted according to a preorder which serves to aid in
easily selecting an appropriate memory type.
Given two memory types X and Y, the preorder defines  X ≤ Y if:

<list type="bullet"><item><description>
the memory property bits set for X are a strict subset of the memory
property bits set for Y.
Or,
</description></item><item><description>
the memory property bits set for X are the same as the memory property
bits set for Y, and X uses a memory heap with greater or equal
performance (as determined in an implementation-specific manner).
</description></item></list>

Memory types are ordered in the list such that X is assigned a lesser
<c>memoryTypeIndex</c> than Y if  (X ≤ Y) ∧ ¬ (Y ≤ X)
according to the preorder.
Note that the list of all allowed memory property flag combinations above
satisfies this preorder, but other orders would as well.
The goal of this ordering is to enable applications to use a simple search
loop in selecting the proper memory type, along the lines of:


<code> // Find a memory type in "memoryTypeBits" that includes all of "properties"
int32_t FindProperties(uint32_t memoryTypeBits, VkMemoryPropertyFlags properties)
{
    for (int32_t i = 0; i &lt; memoryTypeCount; ++i)
    {
        if ((memoryTypeBits &amp; (1 &lt;&lt; i)) &amp;&amp;
            ((memoryTypes[i].propertyFlags &amp; properties) == properties))
            return i;
    }
    return -1;
}

// Try to find an optimal memory type, or if it does not exist
// find any compatible memory type
VkMemoryRequirements memoryRequirements;
vkGetImageMemoryRequirements(device, image, &amp;memoryRequirements);
int32_t memoryType = FindProperties(memoryRequirements.memoryTypeBits, optimalProperties);
if (memoryType == -1)
    memoryType = FindProperties(memoryRequirements.memoryTypeBits, requiredProperties); </code>


The loop will find the first supported memory type that has all bits
requested in <c>properties</c> set.
If there is no exact match, it will find a closest match (i.e. a memory type
with the fewest additional bits set), which has some additional bits set but
which are not detrimental to the behaviors requested by <c>properties</c>.
The application  can first search for the optimal properties, e.g. a memory
type that is device-local or supports coherent cached accesses, as
appropriate for the intended usage, and if such a memory type is not present
 can fallback to searching for a less optimal but guaranteed set of
properties such as "0" or "host-visible and coherent".



The <c>VkPhysicalDeviceMemoryProperties</c> structure is defined as:


<code> typedef struct VkPhysicalDeviceMemoryProperties {
    uint32_t        memoryTypeCount;
    VkMemoryType    memoryTypes[VK_MAX_MEMORY_TYPES];
    uint32_t        memoryHeapCount;
    VkMemoryHeap    memoryHeaps[VK_MAX_MEMORY_HEAPS];
} VkPhysicalDeviceMemoryProperties; </code>

</remarks>
      <seealso cref="T:VkMemoryHeap" />
      <seealso cref="T:VkMemoryType" />
      <seealso cref="T:vkGetPhysicalDeviceMemoryProperties" />
    </member>
    <member name="T:vkCmdSetStencilCompareMask">
      <summary>Set the stencil compare mask dynamic state</summary>
      <remarks>


Valid Usage
<list type="bullet"><item><description>

The currently bound graphics pipeline  must have been created with the
<c>VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK</c> dynamic state enabled
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>commandBuffer</c> must be a valid <c>VkCommandBuffer</c> handle
</description></item><item><description>
<c>faceMask</c> must be a valid combination of <see cref="T:VkStencilFaceFlags" /> values
</description></item><item><description>
<c>faceMask</c> must not be <c>0</c>
</description></item><item><description>
<c>commandBuffer</c> must be in the  recording state
</description></item><item><description>
 The <c>VkCommandPool</c> that <c>commandBuffer</c> was allocated from  must support graphics operations
</description></item></list>




Host Synchronization
<list type="bullet"><item><description>
Host access to <c>commandBuffer</c> must  be externally synchronized
</description></item><item><description>
Host access to the <c>VkCommandPool</c> that <c>commandBuffer</c> was allocated from  must be externally synchronized
</description></item></list>




Command Properties
<list type="table">       <listheader><tr><term> Command Buffer Levels </term><term> Render Pass Scope </term><term> Supported Queue Types </term><term> Pipeline Type </term></tr></listheader>
<item><term>
Primary<br />
Secondary
</term><term>
Both
</term><term>
Graphics
</term><term></term></item>
</list>



If the pipeline state object is created with the
<c>VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK</c> dynamic state enabled, then to
dynamically set the stencil compare mask call:


<code> void vkCmdSetStencilCompareMask(
    VkCommandBuffer                             commandBuffer,
    VkStencilFaceFlags                          faceMask,
    uint32_t                                    compareMask); </code>

</remarks>
      <seealso cref="T:VkCommandBuffer" />
      <seealso cref="T:VkStencilFaceFlags" />
    </member>
    <member name="T:vkCmdBindVertexBuffers">
      <summary>Bind vertex buffers to a command buffer</summary>
      <remarks>

The values taken from elements  i of <c>pBuffers</c> and <c>pOffsets</c>
replace the current state for the vertex input binding
 <c>firstBinding</c> +  i, for  i in  [0,
<c>bindingCount</c>).
The vertex input binding is updated to start at the offset indicated by
<c>pOffsets</c>[i] from the start of the buffer <c>pBuffers</c>[i].
All vertex input attributes that use each of these bindings will use these
updated addresses in their address calculations for subsequent draw
commands.



Valid Usage
<list type="bullet"><item><description>
<c>firstBinding</c> must be less than
<c>VkPhysicalDeviceLimits</c>::<c>maxVertexInputBindings</c>
</description></item><item><description>

The sum of <c>firstBinding</c> and <c>bindingCount</c> must be less than
or equal to <c>VkPhysicalDeviceLimits</c>::<c>maxVertexInputBindings</c>
</description></item><item><description>

All elements of <c>pOffsets</c> must be less than the size of the
corresponding element in <c>pBuffers</c>
</description></item><item><description>

All elements of <c>pBuffers</c> must have been created with the
<c>VK_BUFFER_USAGE_VERTEX_BUFFER_BIT</c> flag
</description></item><item><description>

Each element of <c>pBuffers</c> that is non-sparse  must be bound
completely and contiguously to a single <c>VkDeviceMemory</c> object
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>commandBuffer</c> must be a valid <c>VkCommandBuffer</c> handle
</description></item><item><description>
<c>pBuffers</c> must be a pointer to an array of <c>bindingCount</c> valid <c>VkBuffer</c> handles
</description></item><item><description>
<c>pOffsets</c> must be a pointer to an array of <c>bindingCount</c><c>VkDeviceSize</c> values
</description></item><item><description>
<c>commandBuffer</c> must be in the  recording state
</description></item><item><description>
 The <c>VkCommandPool</c> that <c>commandBuffer</c> was allocated from  must support graphics operations
</description></item><item><description>
<c>bindingCount</c> must be greater than <c>0</c>
</description></item><item><description>
 Both of <c>commandBuffer</c>, and the elements of <c>pBuffers</c> must have been created, allocated, or retrieved from the same <c>VkDevice</c>
</description></item></list>




Host Synchronization
<list type="bullet"><item><description>
Host access to <c>commandBuffer</c> must  be externally synchronized
</description></item><item><description>
Host access to the <c>VkCommandPool</c> that <c>commandBuffer</c> was allocated from  must be externally synchronized
</description></item></list>




Command Properties
<list type="table">       <listheader><tr><term> Command Buffer Levels </term><term> Render Pass Scope </term><term> Supported Queue Types </term><term> Pipeline Type </term></tr></listheader>
<item><term>
Primary<br />
Secondary
</term><term>
Both
</term><term>
Graphics
</term><term></term></item>
</list>



To bind vertex buffers to a command buffer for use in subsequent draw
commands, call:


<code> void vkCmdBindVertexBuffers(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    firstBinding,
    uint32_t                                    bindingCount,
    const VkBuffer*                             pBuffers,
    const VkDeviceSize*                         pOffsets); </code>

</remarks>
      <seealso cref="T:VkBuffer" />
      <seealso cref="T:VkCommandBuffer" />
    </member>
    <member name="T:IVkDisplayPropertiesKHR" />
    <member name="T:VkDisplayPropertiesKHR32">
      <summary>See: <see cref="T:IVkDisplayPropertiesKHR" /></summary>
      <seealso cref="T:IVkDisplayPropertiesKHR" />
    </member>
    <member name="T:VkDisplayPropertiesKHR64">
      <summary>See: <see cref="T:IVkDisplayPropertiesKHR" /></summary>
      <seealso cref="T:IVkDisplayPropertiesKHR" />
    </member>
    <member name="T:IVkGraphicsPipelineCreateInfo">
      <summary>Structure specifying parameters of a newly created graphics pipeline</summary>
      <remarks>

The parameters <c>basePipelineHandle</c> and <c>basePipelineIndex</c> are
described in more detail in <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#pipelines-pipeline-derivatives">Pipeline
Derivatives</a>.


<c>pStages</c> points to an array of <see cref="T:IVkPipelineShaderStageCreateInfo" />
structures, which were previously described in <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#pipelines-compute">Compute
Pipelines</a>.


<c>pDynamicState</c> points to a structure of type
<c>VkPipelineDynamicStateCreateInfo</c>.



Valid Usage
<list type="bullet"><item><description>

If <c>flags</c> contains the <c>VK_PIPELINE_CREATE_DERIVATIVE_BIT</c>
flag, and <c>basePipelineIndex</c> is -1, <c>basePipelineHandle</c> must
be a valid handle to a graphics <c>VkPipeline</c>
</description></item><item><description>

If <c>flags</c> contains the <c>VK_PIPELINE_CREATE_DERIVATIVE_BIT</c>
flag, and <c>basePipelineHandle</c> is <see cref="!:VK_NULL_HANDLE" />,
<c>basePipelineIndex</c> must be a valid index into the calling
command&amp;#8217;s <c>pCreateInfos</c> parameter
</description></item><item><description>

If <c>flags</c> contains the <c>VK_PIPELINE_CREATE_DERIVATIVE_BIT</c>
flag, and <c>basePipelineIndex</c> is not -1, <c>basePipelineHandle</c> must be <see cref="!:VK_NULL_HANDLE" />
</description></item><item><description>

If <c>flags</c> contains the <c>VK_PIPELINE_CREATE_DERIVATIVE_BIT</c>
flag, and <c>basePipelineHandle</c> is not <see cref="!:VK_NULL_HANDLE" />,
<c>basePipelineIndex</c> must  be -1
</description></item><item><description>

The <c>stage</c> member of each element of <c>pStages</c> must  be unique
</description></item><item><description>

The <c>stage</c> member of one element of <c>pStages</c> must be
<c>VK_SHADER_STAGE_VERTEX_BIT</c>
</description></item><item><description>

The <c>stage</c> member of any given element of <c>pStages</c> must not
be <c>VK_SHADER_STAGE_COMPUTE_BIT</c>
</description></item><item><description>

If <c>pStages</c> includes a tessellation control shader stage, it  must
include a tessellation evaluation shader stage
</description></item><item><description>

If <c>pStages</c> includes a tessellation evaluation shader stage, it
 must include a tessellation control shader stage
</description></item><item><description>

If <c>pStages</c> includes a tessellation control shader stage and a
tessellation evaluation shader stage, <c>pTessellationState</c> must be
a pointer to a valid <c>VkPipelineTessellationStateCreateInfo</c>
structure
</description></item><item><description>

If <c>pStages</c> includes tessellation shader stages, the shader code of
at least one stage  must contain an <c>OpExecutionMode</c> instruction
that specifies the type of subdivision in the pipeline
</description></item><item><description>

If <c>pStages</c> includes tessellation shader stages, and the shader
code of both stages contain an <c>OpExecutionMode</c> instruction that
specifies the type of subdivision in the pipeline, they  must both
specify the same subdivision mode
</description></item><item><description>

If <c>pStages</c> includes tessellation shader stages, the shader code of
at least one stage  must contain an <c>OpExecutionMode</c> instruction
that specifies the output patch size in the pipeline
</description></item><item><description>

If <c>pStages</c> includes tessellation shader stages, and the shader
code of both contain an <c>OpExecutionMode</c> instruction that specifies
the out patch size in the pipeline, they  must both specify the same
patch size
</description></item><item><description>

If <c>pStages</c> includes tessellation shader stages, the <c>topology</c>
member of <c>pInputAssembly</c> must be
<c>VK_PRIMITIVE_TOPOLOGY_PATCH_LIST</c>
</description></item><item><description>

If the <c>topology</c> member of <c>pInputAssembly</c> is
<c>VK_PRIMITIVE_TOPOLOGY_PATCH_LIST</c>, <c>pStages</c> must  include
tessellation shader stages
</description></item><item><description>

If <c>pStages</c> includes a geometry shader stage, and does not include
any tessellation shader stages, its shader code  must contain an
<c>OpExecutionMode</c> instruction that specifies an input primitive type
that is <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#shaders-geometry-execution">compatible</a> with the primitive
topology specified in <c>pInputAssembly</c>
</description></item><item><description>

If <c>pStages</c> includes a geometry shader stage, and also includes
tessellation shader stages, its shader code  must contain an
<c>OpExecutionMode</c> instruction that specifies an input primitive type
that is <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#shaders-geometry-execution">compatible</a> with the primitive
topology that is output by the tessellation stages
</description></item><item><description>

If <c>pStages</c> includes a fragment shader stage and a geometry shader
stage, and the fragment shader code reads from an input variable that is
decorated with <c>PrimitiveID</c>, then the geometry shader code  must
write to a matching output variable, decorated with <c>PrimitiveID</c>, in
all execution paths
</description></item><item><description>

If <c>pStages</c> includes a fragment shader stage, its shader code  must
not read from any input attachment that is defined as
<c>VK_ATTACHMENT_UNUSED</c> in <c>subpass</c>
</description></item><item><description>

The shader code for the entry points identified by <c>pStages</c>, and
the rest of the state identified by this structure  must adhere to the
pipeline linking rules described in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#interfaces">Shader Interfaces</a>
chapter
</description></item><item><description>

If rasterization is not disabled and <c>subpass</c> uses a depth/stencil
attachment in <c>renderpass</c> that has a layout of
<c>VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL</c> in the
<c>VkAttachmentReference</c> defined by <c>subpass</c>, the
<c>depthWriteEnable</c> member of <c>pDepthStencilState</c> must be
<c>VK_FALSE</c>
</description></item><item><description>

If rasterization is not disabled and <c>subpass</c> uses a depth/stencil
attachment in <c>renderpass</c> that has a layout of
<c>VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL</c> in the
<c>VkAttachmentReference</c> defined by <c>subpass</c>, the <c>failOp</c>,
<c>passOp</c> and <c>depthFailOp</c> members of each of the <c>front</c>
and <c>back</c> members of <c>pDepthStencilState</c> must be
<c>VK_STENCIL_OP_KEEP</c>
</description></item><item><description>

If rasterization is not disabled and the subpass uses color attachments,
then for each color attachment in the subpass the <c>blendEnable</c>
member of the corresponding element of the <c>pAttachment</c> member of
<c>pColorBlendState</c> must be <c>VK_FALSE</c> if the <c>format</c> of
the attachment does not support color blend operations, as specified by
the <c>VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT</c> flag in
<c>VkFormatProperties</c>::<c>linearTilingFeatures</c> or
<c>VkFormatProperties</c>::<c>optimalTilingFeatures</c> returned by
<c>vkGetPhysicalDeviceFormatProperties</c>
</description></item><item><description>

If rasterization is not disabled and the subpass uses color attachments,
the <c>attachmentCount</c> member of <c>pColorBlendState</c> must be
equal to the <c>colorAttachmentCount</c> used to create <c>subpass</c>
</description></item><item><description>

If no element of the <c>pDynamicStates</c> member of <c>pDynamicState</c>
is <c>VK_DYNAMIC_STATE_VIEWPORT</c>, the <c>pViewports</c> member of
<c>pViewportState</c> must be a pointer to an array of
<c>pViewportState</c>::<c>viewportCount</c><c>VkViewport</c> structures
</description></item><item><description>

If no element of the <c>pDynamicStates</c> member of <c>pDynamicState</c>
is <c>VK_DYNAMIC_STATE_SCISSOR</c>, the <c>pScissors</c> member of
<c>pViewportState</c> must be a pointer to an array of
<c>pViewportState</c>::<c>scissorCount</c><c>VkRect2D</c> structures
</description></item><item><description>

If the wide lines feature is not enabled, and no element of the
<c>pDynamicStates</c> member of <c>pDynamicState</c> is
<c>VK_DYNAMIC_STATE_LINE_WIDTH</c>, the <c>lineWidth</c> member of
<c>pRasterizationState</c> must be <c>1.0</c>
</description></item><item><description>

If the <c>rasterizerDiscardEnable</c> member of <c>pRasterizationState</c>
is <c>VK_FALSE</c>, <c>pViewportState</c> must be a pointer to a valid
<c>VkPipelineViewportStateCreateInfo</c> structure
</description></item><item><description>

If the <c>rasterizerDiscardEnable</c> member of <c>pRasterizationState</c>
is <c>VK_FALSE</c>, <c>pMultisampleState</c> must be a pointer to a valid
<c>VkPipelineMultisampleStateCreateInfo</c> structure
</description></item><item><description>

If the <c>rasterizerDiscardEnable</c> member of <c>pRasterizationState</c>
is <c>VK_FALSE</c>, and <c>subpass</c> uses a depth/stencil attachment,
<c>pDepthStencilState</c> must be a pointer to a valid
<c>VkPipelineDepthStencilStateCreateInfo</c> structure
</description></item><item><description>

If the <c>rasterizerDiscardEnable</c> member of <c>pRasterizationState</c>
is <c>VK_FALSE</c>, and <c>subpass</c> uses color attachments,
<c>pColorBlendState</c> must be a pointer to a valid
<c>VkPipelineColorBlendStateCreateInfo</c> structure
</description></item><item><description>

If the depth bias clamping feature is not enabled, no element of the
<c>pDynamicStates</c> member of <c>pDynamicState</c> is
<c>VK_DYNAMIC_STATE_DEPTH_BIAS</c>, and the <c>depthBiasEnable</c> member
of <c>pDepthStencil</c> is <c>VK_TRUE</c>, the <c>depthBiasClamp</c> member
of <c>pDepthStencil</c> must be <c>0.0</c>
</description></item><item><description>

If no element of the <c>pDynamicStates</c> member of <c>pDynamicState</c>
is <c>VK_DYNAMIC_STATE_DEPTH_BOUNDS</c>, and the
<c>depthBoundsTestEnable</c> member of <c>pDepthStencil</c> is
<c>VK_TRUE</c>, the <c>minDepthBounds</c> and <c>maxDepthBounds</c> members
of <c>pDepthStencil</c> must be between <c>0.0</c> and <c>1.0</c>, inclusive
</description></item><item><description>
<c>layout</c> must be
<a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#descriptorsets-pipelinelayout-consistency">consistent</a> with all
shaders specified in <c>pStages</c>
</description></item><item><description>

If <c>subpass</c> uses color and/or depth/stencil attachments, then the
<c>rasterizationSamples</c> member of <c>pMultisampleState</c> must  be
the same as the sample count for those subpass attachments
</description></item><item><description>

If <c>subpass</c> does not use any color and/or depth/stencil
attachments, then the <c>rasterizationSamples</c> member of
<c>pMultisampleState</c> must follow the rules for a
<a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#renderpass-noattachments">zero-attachment subpass</a>
</description></item><item><description>
<c>subpass</c> must be a valid subpass within <c>renderpass</c>
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>sType</c> must be <c>VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO</c>
</description></item><item><description>
<c>pNext</c> must be <c>NULL</c>
</description></item><item><description>
<c>flags</c> must be a valid combination of <see cref="T:VkPipelineCreateFlags" /> values
</description></item><item><description>
<c>pStages</c> must be a pointer to an array of <c>stageCount</c> valid <c>VkPipelineShaderStageCreateInfo</c> structures
</description></item><item><description>
<c>pVertexInputState</c> must be a pointer to a valid <c>VkPipelineVertexInputStateCreateInfo</c> structure
</description></item><item><description>
<c>pInputAssemblyState</c> must be a pointer to a valid <c>VkPipelineInputAssemblyStateCreateInfo</c> structure
</description></item><item><description>
<c>pRasterizationState</c> must be a pointer to a valid <c>VkPipelineRasterizationStateCreateInfo</c> structure
</description></item><item><description>
 If <c>pDynamicState</c> is not <c>NULL</c>, <c>pDynamicState</c> must be a pointer to a valid <c>VkPipelineDynamicStateCreateInfo</c> structure
</description></item><item><description>
<c>layout</c> must be a valid <c>VkPipelineLayout</c> handle
</description></item><item><description>
<c>renderPass</c> must be a valid <c>VkRenderPass</c> handle
</description></item><item><description>
<c>stageCount</c> must be greater than <c>0</c>
</description></item><item><description>
 Each of <c>basePipelineHandle</c>, <c>layout</c>, and <c>renderPass</c> that are valid handles  must have been created, allocated, or retrieved from the same <c>VkDevice</c>
</description></item></list>




The <c>VkGraphicsPipelineCreateInfo</c> structure is defined as:


<code> typedef struct VkGraphicsPipelineCreateInfo {
    VkStructureType                                  sType;
    const void*                                      pNext;
    VkPipelineCreateFlags                            flags;
    uint32_t                                         stageCount;
    const VkPipelineShaderStageCreateInfo*           pStages;
    const VkPipelineVertexInputStateCreateInfo*      pVertexInputState;
    const VkPipelineInputAssemblyStateCreateInfo*    pInputAssemblyState;
    const VkPipelineTessellationStateCreateInfo*     pTessellationState;
    const VkPipelineViewportStateCreateInfo*         pViewportState;
    const VkPipelineRasterizationStateCreateInfo*    pRasterizationState;
    const VkPipelineMultisampleStateCreateInfo*      pMultisampleState;
    const VkPipelineDepthStencilStateCreateInfo*     pDepthStencilState;
    const VkPipelineColorBlendStateCreateInfo*       pColorBlendState;
    const VkPipelineDynamicStateCreateInfo*          pDynamicState;
    VkPipelineLayout                                 layout;
    VkRenderPass                                     renderPass;
    uint32_t                                         subpass;
    VkPipeline                                       basePipelineHandle;
    int32_t                                          basePipelineIndex;
} VkGraphicsPipelineCreateInfo; </code>

</remarks>
      <seealso cref="T:VkPipeline" />
      <seealso cref="T:IVkPipelineColorBlendStateCreateInfo" />
      <seealso cref="T:VkPipelineCreateFlags" />
      <seealso cref="T:IVkPipelineDepthStencilStateCreateInfo" />
      <seealso cref="T:IVkPipelineDynamicStateCreateInfo" />
      <seealso cref="T:IVkPipelineInputAssemblyStateCreateInfo" />
      <seealso cref="T:VkPipelineLayout" />
      <seealso cref="T:IVkPipelineMultisampleStateCreateInfo" />
      <seealso cref="T:IVkPipelineRasterizationStateCreateInfo" />
      <seealso cref="T:IVkPipelineShaderStageCreateInfo" />
      <seealso cref="T:IVkPipelineTessellationStateCreateInfo" />
      <seealso cref="T:IVkPipelineVertexInputStateCreateInfo" />
      <seealso cref="T:IVkPipelineViewportStateCreateInfo" />
      <seealso cref="T:VkRenderPass" />
      <seealso cref="T:VkStructureType" />
      <seealso cref="T:vkCreateGraphicsPipelines" />
    </member>
    <member name="T:VkGraphicsPipelineCreateInfo32">
      <summary>See: <see cref="T:IVkGraphicsPipelineCreateInfo" /></summary>
      <seealso cref="T:IVkGraphicsPipelineCreateInfo" />
    </member>
    <member name="T:VkGraphicsPipelineCreateInfo64">
      <summary>See: <see cref="T:IVkGraphicsPipelineCreateInfo" /></summary>
      <seealso cref="T:IVkGraphicsPipelineCreateInfo" />
    </member>
    <member name="T:vkCmdDebugMarkerEndEXT" />
    <member name="T:IVkPipelineMultisampleStateCreateInfo">
      <summary>Structure specifying parameters of a newly created pipeline multisample state</summary>
      <remarks>


Valid Usage
<list type="bullet"><item><description>

If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-sampleRateShading">sample rate shading</a>
feature is not enabled, <c>sampleShadingEnable</c> must be
<c>VK_FALSE</c>
</description></item><item><description>

If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-alphaToOne">alpha to one</a> feature is not
enabled, <c>alphaToOneEnable</c> must be <c>VK_FALSE</c>
</description></item><item><description>
<c>minSampleShading</c> must be in the range  [0,1]
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>sType</c> must be <c>VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO</c>
</description></item><item><description>
<c>pNext</c> must be <c>NULL</c>
</description></item><item><description>
<c>flags</c> must be <c>0</c>
</description></item><item><description>
<c>rasterizationSamples</c> must be a valid <see cref="T:VkSampleCountFlags" /> value
</description></item><item><description>
 If <c>pSampleMask</c> is not <c>NULL</c>, <c>pSampleMask</c> must be a pointer to an array of \(\lceil{\mathit{rasterizationSamples} \over 32}\rceil\) <c>VkSampleMask</c> values
</description></item></list>




The <c>VkPipelineMultisampleStateCreateInfo</c> structure is defined as:


<code> typedef struct VkPipelineMultisampleStateCreateInfo {
    VkStructureType                          sType;
    const void*                              pNext;
    VkPipelineMultisampleStateCreateFlags    flags;
    VkSampleCountFlagBits                    rasterizationSamples;
    VkBool32                                 sampleShadingEnable;
    float                                    minSampleShading;
    const VkSampleMask*                      pSampleMask;
    VkBool32                                 alphaToCoverageEnable;
    VkBool32                                 alphaToOneEnable;
} VkPipelineMultisampleStateCreateInfo; </code>

</remarks>
      <seealso cref="T:IVkGraphicsPipelineCreateInfo" />
      <seealso cref="T:VkPipelineMultisampleStateCreateFlags" />
      <seealso cref="T:VkSampleCountFlags" />
      <seealso cref="T:VkStructureType" />
    </member>
    <member name="T:VkPipelineMultisampleStateCreateInfo32">
      <summary>See: <see cref="T:IVkPipelineMultisampleStateCreateInfo" /></summary>
      <seealso cref="T:IVkPipelineMultisampleStateCreateInfo" />
    </member>
    <member name="T:VkPipelineMultisampleStateCreateInfo64">
      <summary>See: <see cref="T:IVkPipelineMultisampleStateCreateInfo" /></summary>
      <seealso cref="T:IVkPipelineMultisampleStateCreateInfo" />
    </member>
    <member name="T:IVkDescriptorUpdateTemplateCreateInfoKHR" />
    <member name="T:VkDescriptorUpdateTemplateCreateInfoKHR32">
      <summary>See: <see cref="T:IVkDescriptorUpdateTemplateCreateInfoKHR" /></summary>
      <seealso cref="T:IVkDescriptorUpdateTemplateCreateInfoKHR" />
    </member>
    <member name="T:VkDescriptorUpdateTemplateCreateInfoKHR64">
      <summary>See: <see cref="T:IVkDescriptorUpdateTemplateCreateInfoKHR" /></summary>
      <seealso cref="T:IVkDescriptorUpdateTemplateCreateInfoKHR" />
    </member>
    <member name="T:vkCmdDrawIndirect">
      <summary>Issue an indirect draw into a command buffer</summary>
      <remarks>

<c>vkCmdDrawIndirect</c> behaves similarly to <see cref="T:vkCmdDraw" /> except that the
parameters are read by the device from a buffer during execution.
<c>drawCount</c> draws are executed by the command, with parameters taken
from <c>buffer</c> starting at <c>offset</c> and increasing by <c>stride</c>
bytes for each successive draw.
The parameters of each draw are encoded in an array of
<see cref="T:VkDrawIndirectCommand" /> structures.
If <c>drawCount</c> is less than or equal to one, <c>stride</c> is ignored.



Valid Usage
<list type="bullet"><item><description>

If <c>buffer</c> is non-sparse then it  must be bound completely and
contiguously to a single <c>VkDeviceMemory</c> object
</description></item><item><description>
<c>offset</c> must be a multiple of <c>4</c>
</description></item><item><description>

If <c>drawCount</c> is greater than <c>1</c>, <c>stride</c> must be a multiple
of <c>4</c> and  must be greater than or equal to
sizeof(<c>VkDrawIndirectCommand</c>)
</description></item><item><description>

If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-multiDrawIndirect">multi-draw indirect</a>
feature is not enabled, <c>drawCount</c> must be <c>0</c> or <c>1</c>
</description></item><item><description>

If the
<a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-drawIndirectFirstInstance">drawIndirectFirstInstance</a>
feature is not enabled, all the <c>firstInstance</c> members of the
<c>VkDrawIndirectCommand</c> structures accessed by this command  must be
<c>0</c>
</description></item><item><description>

The current render pass  must be <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#renderpass-compatibility">compatible</a>
with the <c>renderPass</c> member of the
<c>VkGraphicsPipelineCreateInfo</c> structure specified when creating the
<c>VkPipeline</c> currently bound to
<c>VK_PIPELINE_BIND_POINT_GRAPHICS</c>.
</description></item><item><description>

The subpass index of the current render pass  must be equal to the
<c>subpass</c> member of the <c>VkGraphicsPipelineCreateInfo</c> structure
specified when creating the <c>VkPipeline</c> currently bound to
<c>VK_PIPELINE_BIND_POINT_GRAPHICS</c>.
</description></item><item><description>

For each set  n that is statically used by the <c>VkPipeline</c>
currently bound to <c>VK_PIPELINE_BIND_POINT_GRAPHICS</c>, a descriptor
set  must have been bound to  n at
<c>VK_PIPELINE_BIND_POINT_GRAPHICS</c>, with a <c>VkPipelineLayout</c>
that is compatible for set  n, with the <c>VkPipelineLayout</c> used to
create the current <c>VkPipeline</c>, as described in
<a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#descriptorsets-compatibility">../../html/vkspec.html#descriptorsets-compatibility</a>
</description></item><item><description>

For each push constant that is statically used by the <c>VkPipeline</c>
currently bound to <c>VK_PIPELINE_BIND_POINT_GRAPHICS</c>, a push
constant value  must have been set for
<c>VK_PIPELINE_BIND_POINT_GRAPHICS</c>, with a <c>VkPipelineLayout</c>
that is compatible for push constants, with the <c>VkPipelineLayout</c>
used to create the current <c>VkPipeline</c>, as described in
<a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#descriptorsets-compatibility">../../html/vkspec.html#descriptorsets-compatibility</a>
</description></item><item><description>

Descriptors in each bound descriptor set, specified via
<c>vkCmdBindDescriptorSets</c>,  must be valid if they are statically
used by the currently bound <c>VkPipeline</c> object, specified via
<c>vkCmdBindPipeline</c>
</description></item><item><description>

All vertex input bindings accessed via vertex input variables declared
in the vertex shader entry point&amp;#8217;s interface  must have valid buffers
bound
</description></item><item><description>

A valid graphics pipeline  must be bound to the current command buffer
with <c>VK_PIPELINE_BIND_POINT_GRAPHICS</c>
</description></item><item><description>

If the <c>VkPipeline</c> object currently bound to
<c>VK_PIPELINE_BIND_POINT_GRAPHICS</c> requires any dynamic state, that
state  must have been set on the current command buffer
</description></item><item><description>

If <c>drawCount</c> is equal to <c>1</c>,  (<c>offset</c> + 
sizeof(<see cref="T:VkDrawIndirectCommand" />)) must be less than or equal to the
size of <c>buffer</c>
</description></item><item><description>

If <c>drawCount</c> is greater than <c>1</c>,  (<c>stride</c> ×
(<c>drawCount</c> - 1) +  <c>offset</c> + 
sizeof(<see cref="T:VkDrawIndirectCommand" />)) must be less than or equal to the
size of <c>buffer</c>
</description></item><item><description>
<c>drawCount</c> must be less than or equal to
<c>VkPhysicalDeviceLimits</c>::<c>maxDrawIndirectCount</c>
</description></item><item><description>

Every input attachment used by the current subpass  must be bound to the
pipeline via a descriptor set
</description></item><item><description>

If any <c>VkSampler</c> object that is accessed from a shader by the
<c>VkPipeline</c> currently bound to
<c>VK_PIPELINE_BIND_POINT_GRAPHICS</c> uses unnormalized coordinates, it
 must not be used to sample from any <c>VkImage</c> with a
<c>VkImageView</c> of the type <c>VK_IMAGE_VIEW_TYPE_3D</c>,
<c>VK_IMAGE_VIEW_TYPE_CUBE</c>, <c>VK_IMAGE_VIEW_TYPE_1D_ARRAY</c>,
<c>VK_IMAGE_VIEW_TYPE_2D_ARRAY</c> or
<c>VK_IMAGE_VIEW_TYPE_CUBE_ARRAY</c>, in any shader stage
</description></item><item><description>

If any <c>VkSampler</c> object that is accessed from a shader by the
<c>VkPipeline</c> currently bound to
<c>VK_PIPELINE_BIND_POINT_GRAPHICS</c> uses unnormalized coordinates, it
 must not be used with any of the SPIR-V <c>OpImageSample*</c> or
<c>OpImageSparseSample*</c> instructions with <c>ImplicitLod</c>, <c>Dref</c> or
<c>Proj</c> in their name, in any shader stage
</description></item><item><description>

If any <c>VkSampler</c> object that is accessed from a shader by the
<c>VkPipeline</c> currently bound to
<c>VK_PIPELINE_BIND_POINT_GRAPHICS</c> uses unnormalized coordinates, it
 must not be used with any of the SPIR-V <c>OpImageSample*</c> or
<c>OpImageSparseSample*</c> instructions that includes a LOD bias or any
offset values, in any shader stage
</description></item><item><description>

If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-robustBufferAccess">robust buffer access</a>
feature is not enabled, and any shader stage in the <c>VkPipeline</c>
object currently bound to <c>VK_PIPELINE_BIND_POINT_GRAPHICS</c> accesses
a uniform buffer, it  must not access values outside of the range of
that buffer specified in the currently bound descriptor set
</description></item><item><description>

If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-robustBufferAccess">robust buffer access</a>
feature is not enabled, and any shader stage in the <c>VkPipeline</c>
object currently bound to <c>VK_PIPELINE_BIND_POINT_GRAPHICS</c> accesses
a storage buffer, it  must not access values outside of the range of
that buffer specified in the currently bound descriptor set
</description></item><item><description>

Any <c>VkImageView</c> being sampled with <c>VK_FILTER_LINEAR</c> as a
result of this command  must be of a format which supports linear
filtering, as specified by the
<c>VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT</c> flag in
<c>VkFormatProperties</c>::<c>linearTilingFeatures</c> (for a linear
image) or <c>VkFormatProperties</c>::<c>optimalTilingFeatures</c>(for an
optimally tiled image) returned by
<c>vkGetPhysicalDeviceFormatProperties</c>
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>commandBuffer</c> must be a valid <c>VkCommandBuffer</c> handle
</description></item><item><description>
<c>buffer</c> must be a valid <c>VkBuffer</c> handle
</description></item><item><description>
<c>commandBuffer</c> must be in the  recording state
</description></item><item><description>
 The <c>VkCommandPool</c> that <c>commandBuffer</c> was allocated from  must support graphics operations
</description></item><item><description>
 This command  must only be called inside of a render pass instance
</description></item><item><description>
 Both of <c>buffer</c>, and <c>commandBuffer</c> must have been created, allocated, or retrieved from the same <c>VkDevice</c>
</description></item></list>




Host Synchronization
<list type="bullet"><item><description>
Host access to <c>commandBuffer</c> must  be externally synchronized
</description></item><item><description>
Host access to the <c>VkCommandPool</c> that <c>commandBuffer</c> was allocated from  must be externally synchronized
</description></item></list>




Command Properties
<list type="table">       <listheader><tr><term> Command Buffer Levels </term><term> Render Pass Scope </term><term> Supported Queue Types </term><term> Pipeline Type </term></tr></listheader>
<item><term>
Primary<br />
Secondary
</term><term>
Inside
</term><term>
Graphics
</term><term>
Graphics
</term></item>
</list>



To record a non-indexed indirect draw, call:


<code> void vkCmdDrawIndirect(
    VkCommandBuffer                             commandBuffer,
    VkBuffer                                    buffer,
    VkDeviceSize                                offset,
    uint32_t                                    drawCount,
    uint32_t                                    stride); </code>

</remarks>
      <seealso cref="T:VkBuffer" />
      <seealso cref="T:VkCommandBuffer" />
    </member>
    <member name="T:IVkDeviceGroupSubmitInfoKHX" />
    <member name="T:VkDeviceGroupSubmitInfoKHX32">
      <summary>See: <see cref="T:IVkDeviceGroupSubmitInfoKHX" /></summary>
      <seealso cref="T:IVkDeviceGroupSubmitInfoKHX" />
    </member>
    <member name="T:VkDeviceGroupSubmitInfoKHX64">
      <summary>See: <see cref="T:IVkDeviceGroupSubmitInfoKHX" /></summary>
      <seealso cref="T:IVkDeviceGroupSubmitInfoKHX" />
    </member>
    <member name="T:PFN_vkInternalFreeNotification">
      <summary>Application-defined memory free notification function</summary>
      <remarks>

The type of <c>pfnInternalFree</c> is:


<code> typedef void (VKAPI_PTR *PFN_vkInternalFreeNotification)(
    void*                                       pUserData,
    size_t                                      size,
    VkInternalAllocationType                    allocationType,
    VkSystemAllocationScope                     allocationScope); </code>

</remarks>
      <seealso cref="T:IVkAllocationCallbacks" />
    </member>
    <member name="T:vkGetDeviceProcAddr">
      <summary>Return a function pointer for a command</summary>
      <remarks>

The returned function pointer is of type <see cref="T:PFN_vkVoidFunction" />, and must
be cast to the type of the command being queried.

<para>Table 1. vkGetDeviceProcAddr behavior</para><list type="table">      <listheader><tr><term><c>device</c></term><term><c>pName</c></term><term>return value</term></tr></listheader>
<item><term>
<c>NULL</c>
</term><term>
*
</term><term>
undefined
</term></item><item><term>
invalid device
</term><term>
*
</term><term>
undefined
</term></item><item><term>
device
</term><term>
<c>NULL</c>
</term><term>
undefined
</term></item><item><term>
device
</term><term>
core Vulkan command
</term><term>
fp<sup>1</sup>
</term></item><item><term>
device
</term><term>
enabled extension commands
</term><term>
fp<sup>1</sup>
</term></item><item><term>
device
</term><term>
* (any <c>pName</c> not covered above)
</term><term>
<c>NULL</c>
</term></item>
</list>
<dl><dt>1</dt><dd>
The returned function pointer  must only be called with a dispatchable
object (the first parameter) that is <c>device</c> or a child of
<c>device</c>.
e.g. <c>VkDevice</c>, <c>VkQueue</c>, or <c>VkCommandBuffer</c>.
</dd></dl>


Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>device</c> must be a valid <c>VkDevice</c> handle
</description></item><item><description>
<c>pName</c> must  be a null-terminated UTF-8 string
</description></item></list>




In order to support systems with multiple Vulkan implementations comprising
heterogeneous collections of hardware and software, the function pointers
returned by <c>vkGetInstanceProcAddr</c> may point to dispatch code, which
calls a different real implementation for different <c>VkDevice</c> objects
(and objects created from them).
The overhead of this internal dispatch  can be avoided by obtaining
device-specific function pointers for any commands that use a device or
device-child object as their dispatchable object.
Such function pointers  can be obtained with the command:


<code> PFN_vkVoidFunction vkGetDeviceProcAddr(
    VkDevice                                    device,
    const char*                                 pName); </code>

</remarks>
      <seealso cref="T:PFN_vkVoidFunction" />
      <seealso cref="T:VkDevice" />
    </member>
    <member name="T:VkImageBlit">
      <summary>Structure specifying an image blit operation</summary>
      <remarks>

For each element of the <c>pRegions</c> array, a blit operation is performed
the specified source and destination regions.



Valid Usage
<list type="bullet"><item><description>

The <c>aspectMask</c> member of <c>srcSubresource</c> and
<c>dstSubresource</c> must  match
</description></item><item><description>

The <c>layerCount</c> member of <c>srcSubresource</c> and
<c>dstSubresource</c> must  match
</description></item><item><description>

If either of the calling command&amp;#8217;s <c>srcImage</c> or <c>dstImage</c>
parameters are of <see cref="T:VkImageType" /><c>VK_IMAGE_TYPE_3D</c>, the
<c>baseArrayLayer</c> and <c>layerCount</c> members of both
<c>srcSubresource</c> and <c>dstSubresource</c> must be <c>0</c> and <c>1</c>,
respectively
</description></item><item><description>

The <c>aspectMask</c> member of <c>srcSubresource</c> must specify
aspects present in the calling command&amp;#8217;s <c>srcImage</c>
</description></item><item><description>

The <c>aspectMask</c> member of <c>dstSubresource</c> must specify
aspects present in the calling command&amp;#8217;s <c>dstImage</c>
</description></item><item><description>
<c>srcOffset</c>[0].<c>x</c> and <c>srcOffset</c>[1].<c>x</c> must both be
greater than or equal to <c>0</c> and less than or equal to the source image
subresource width
</description></item><item><description>
<c>srcOffset</c>[0].<c>y</c> and <c>srcOffset</c>[1].<c>y</c> must both be
greater than or equal to <c>0</c> and less than or equal to the source image
subresource height
</description></item><item><description>

If the calling command&amp;#8217;s <c>srcImage</c> is of type
<c>VK_IMAGE_TYPE_1D</c>, then <c>srcOffset</c>[0].y  must be <c>0</c> and
<c>srcOffset</c>[1].y  must be <c>1</c>.
</description></item><item><description>
<c>srcOffset</c>[0].<c>z</c> and <c>srcOffset</c>[1].<c>z</c> must both be
greater than or equal to <c>0</c> and less than or equal to the source image
subresource depth
</description></item><item><description>

If the calling command&amp;#8217;s <c>srcImage</c> is of type
<c>VK_IMAGE_TYPE_1D</c> or <c>VK_IMAGE_TYPE_2D</c>, then
<c>srcOffset</c>[0].z  must be <c>0</c> and <c>srcOffset</c>[1].z  must be <c>1</c>.
</description></item><item><description>
<c>dstOffset</c>[0].<c>x</c> and <c>dstOffset</c>[1].<c>x</c> must both be
greater than or equal to <c>0</c> and less than or equal to the destination
image subresource width
</description></item><item><description>
<c>dstOffset</c>[0].<c>y</c> and <c>dstOffset</c>[1].<c>y</c> must both be
greater than or equal to <c>0</c> and less than or equal to the destination
image subresource height
</description></item><item><description>

If the calling command&amp;#8217;s <c>dstImage</c> is of type
<c>VK_IMAGE_TYPE_1D</c>, then <c>dstOffset</c>[0].y  must be <c>0</c> and
<c>dstOffset</c>[1].y  must be <c>1</c>.
</description></item><item><description>
<c>dstOffset</c>[0].<c>z</c> and <c>dstOffset</c>[1].<c>z</c> must both be
greater than or equal to <c>0</c> and less than or equal to the destination
image subresource depth
</description></item><item><description>

If the calling command&amp;#8217;s <c>dstImage</c> is of type
<c>VK_IMAGE_TYPE_1D</c> or <c>VK_IMAGE_TYPE_2D</c>, then
<c>dstOffset</c>[0].z  must be <c>0</c> and <c>dstOffset</c>[1].z  must be <c>1</c>.
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>srcSubresource</c> must be a valid <c>VkImageSubresourceLayers</c> structure
</description></item><item><description>
<c>dstSubresource</c> must be a valid <c>VkImageSubresourceLayers</c> structure
</description></item></list>




The <c>VkImageBlit</c> structure is defined as:


<code> typedef struct VkImageBlit {
    VkImageSubresourceLayers    srcSubresource;
    VkOffset3D                  srcOffsets[2];
    VkImageSubresourceLayers    dstSubresource;
    VkOffset3D                  dstOffsets[2];
} VkImageBlit; </code>

</remarks>
      <seealso cref="T:VkImageSubresourceLayers" />
      <seealso cref="T:VkOffset3D" />
      <seealso cref="T:vkCmdBlitImage" />
    </member>
    <member name="T:vkResetEvent">
      <summary>Reset an event to non-signaled state</summary>
      <remarks>

When <see cref="T:vkResetEvent" /> is executed on the host, it defines an  event
unsignal operation which resets the event to the unsignaled state.


If <c>event</c> is already in the unsignaled state when <see cref="T:vkResetEvent" /> is
executed, then <see cref="T:vkResetEvent" /> has no effect, and no event unsignal
operation occurs.



Valid Usage
<list type="bullet"><item><description>
<c>event</c> must not be waited on by a <c>vkCmdWaitEvents</c> command
that is currently executing
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>device</c> must be a valid <c>VkDevice</c> handle
</description></item><item><description>
<c>event</c> must be a valid <c>VkEvent</c> handle
</description></item><item><description>
<c>event</c> must have been created, allocated, or retrieved from <c>device</c>
</description></item></list>




Host Synchronization
<list type="bullet"><item><description>
Host access to <c>event</c> must  be externally synchronized
</description></item></list>




Return Codes
<dl><dt>On success, this command returns</dt><dd>
<list type="bullet"><item><description>
<c>VK_SUCCESS</c>
</description></item></list>
</dd><dt>On failure, this command returns</dt><dd>
<list type="bullet"><item><description>
<c>VK_ERROR_OUT_OF_HOST_MEMORY</c>
</description></item><item><description>
<c>VK_ERROR_OUT_OF_DEVICE_MEMORY</c>
</description></item></list>
</dd></dl>




To set the state of an event to unsignaled from the host, call:


<code> VkResult vkResetEvent(
    VkDevice                                    device,
    VkEvent                                     event); </code>

</remarks>
      <seealso cref="T:VkDevice" />
      <seealso cref="T:VkEvent" />
    </member>
    <member name="T:vkUpdateDescriptorSetWithTemplateKHR" />
    <member name="T:vkBindImageMemory">
      <summary>Bind device memory to an image object</summary>
      <remarks>


Valid Usage
<list type="bullet"><item><description>
<c>image</c> must  not already be backed by a memory object
</description></item><item><description>
<c>image</c> must  not have been created with any sparse memory binding
flags
</description></item><item><description>
<c>memoryOffset</c> must be less than the size of <c>memory</c>
</description></item><item><description>
<c>memory</c> must have been allocated using one of the memory types
allowed in the <c>memoryTypeBits</c> member of the
<c>VkMemoryRequirements</c> structure returned from a call to
<c>vkGetImageMemoryRequirements</c> with <c>image</c>
</description></item><item><description>
<c>memoryOffset</c> must be an integer multiple of the <c>alignment</c>
member of the <c>VkMemoryRequirements</c> structure returned from a call
to <c>vkGetImageMemoryRequirements</c> with <c>image</c>
</description></item><item><description>

The <c>size</c> member of the <c>VkMemoryRequirements</c> structure
returned from a call to <c>vkGetImageMemoryRequirements</c> with
<c>image</c> must be less than or equal to the size of <c>memory</c>
minus <c>memoryOffset</c>
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>device</c> must be a valid <c>VkDevice</c> handle
</description></item><item><description>
<c>image</c> must be a valid <c>VkImage</c> handle
</description></item><item><description>
<c>memory</c> must be a valid <c>VkDeviceMemory</c> handle
</description></item><item><description>
<c>image</c> must have been created, allocated, or retrieved from <c>device</c>
</description></item><item><description>
<c>memory</c> must have been created, allocated, or retrieved from <c>device</c>
</description></item></list>




Host Synchronization
<list type="bullet"><item><description>
Host access to <c>image</c> must  be externally synchronized
</description></item></list>




Return Codes
<dl><dt>On success, this command returns</dt><dd>
<list type="bullet"><item><description>
<c>VK_SUCCESS</c>
</description></item></list>
</dd><dt>On failure, this command returns</dt><dd>
<list type="bullet"><item><description>
<c>VK_ERROR_OUT_OF_HOST_MEMORY</c>
</description></item><item><description>
<c>VK_ERROR_OUT_OF_DEVICE_MEMORY</c>
</description></item></list>
</dd></dl>




To attach memory to an image object, call:


<code> VkResult vkBindImageMemory(
    VkDevice                                    device,
    VkImage                                     image,
    VkDeviceMemory                              memory,
    VkDeviceSize                                memoryOffset); </code>

</remarks>
      <seealso cref="T:VkDevice" />
      <seealso cref="T:VkDeviceMemory" />
      <seealso cref="T:VkImage" />
    </member>
    <member name="T:IVkPhysicalDeviceBlendOperationAdvancedFeaturesEXT" />
    <member name="T:VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT32">
      <summary>See: <see cref="T:IVkPhysicalDeviceBlendOperationAdvancedFeaturesEXT" /></summary>
      <seealso cref="T:IVkPhysicalDeviceBlendOperationAdvancedFeaturesEXT" />
    </member>
    <member name="T:VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT64">
      <summary>See: <see cref="T:IVkPhysicalDeviceBlendOperationAdvancedFeaturesEXT" /></summary>
      <seealso cref="T:IVkPhysicalDeviceBlendOperationAdvancedFeaturesEXT" />
    </member>
    <member name="T:VkPresentTimeGOOGLE" />
    <member name="T:vkCmdDispatchBaseKHX" />
    <member name="T:VkDispatchIndirectCommand">
      <summary>Structure specifying a dispatch indirect command</summary>
      <remarks>

The members of <c>VkDispatchIndirectCommand</c> have the same meaning as the
corresponding parameters of <see cref="T:vkCmdDispatch" />.



Valid Usage
<list type="bullet"><item><description>
<c>x</c> must be less than or equal to
<c>VkPhysicalDeviceLimits</c>::<c>maxComputeWorkGroupCount</c>[0]
</description></item><item><description>
<c>y</c> must be less than or equal to
<c>VkPhysicalDeviceLimits</c>::<c>maxComputeWorkGroupCount</c>[1]
</description></item><item><description>
<c>z</c> must be less than or equal to
<c>VkPhysicalDeviceLimits</c>::<c>maxComputeWorkGroupCount</c>[2]
</description></item></list>




The <c>VkDispatchIndirectCommand</c> structure is defined as:


<code> typedef struct VkDispatchIndirectCommand {
    uint32_t    x;
    uint32_t    y;
    uint32_t    z;
} VkDispatchIndirectCommand; </code>

</remarks>
      <seealso cref="T:vkCmdDispatchIndirect" />
    </member>
    <member name="T:IVkDescriptorSetLayoutCreateInfo">
      <summary>Structure specifying parameters of a newly created descriptor set layout</summary>
      <remarks>


Valid Usage
<list type="bullet"><item><description>

The <see cref="T:IVkDescriptorSetLayoutBinding" />::<c>binding</c> members of the
elements of the <c>pBindings</c> array  must each have different values.
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>sType</c> must be <c>VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO</c>
</description></item><item><description>
<c>pNext</c> must be <c>NULL</c>
</description></item><item><description>
<c>flags</c> must be a valid combination of <see cref="T:VkDescriptorSetLayoutCreateFlags" /> values
</description></item><item><description>
 If <c>bindingCount</c> is not <c>0</c>, <c>pBindings</c> must be a pointer to an array of <c>bindingCount</c> valid <c>VkDescriptorSetLayoutBinding</c> structures
</description></item></list>




Information about the descriptor set layout is passed in an instance of the
<c>VkDescriptorSetLayoutCreateInfo</c> structure:


<code> typedef struct VkDescriptorSetLayoutCreateInfo {
    VkStructureType                        sType;
    const void*                            pNext;
    VkDescriptorSetLayoutCreateFlags       flags;
    uint32_t                               bindingCount;
    const VkDescriptorSetLayoutBinding*    pBindings;
} VkDescriptorSetLayoutCreateInfo; </code>

</remarks>
      <seealso cref="T:IVkDescriptorSetLayoutBinding" />
      <seealso cref="T:VkDescriptorSetLayoutCreateFlags" />
      <seealso cref="T:VkStructureType" />
      <seealso cref="T:vkCreateDescriptorSetLayout" />
    </member>
    <member name="T:VkDescriptorSetLayoutCreateInfo32">
      <summary>See: <see cref="T:IVkDescriptorSetLayoutCreateInfo" /></summary>
      <seealso cref="T:IVkDescriptorSetLayoutCreateInfo" />
    </member>
    <member name="T:VkDescriptorSetLayoutCreateInfo64">
      <summary>See: <see cref="T:IVkDescriptorSetLayoutCreateInfo" /></summary>
      <seealso cref="T:IVkDescriptorSetLayoutCreateInfo" />
    </member>
    <member name="T:VkClearDepthStencilValue">
      <summary>Structure specifying a clear depth stencil value</summary>
      <remarks>


Valid Usage
<list type="bullet"><item><description>
<c>depth</c> must be between <c>0.0</c> and <c>1.0</c>, inclusive
</description></item></list>




The <c>VkClearDepthStencilValue</c> structure is defined as:


<code> typedef struct VkClearDepthStencilValue {
    float       depth;
    uint32_t    stencil;
} VkClearDepthStencilValue; </code>

</remarks>
      <seealso cref="T:VkClearValue" />
      <seealso cref="T:vkCmdClearDepthStencilImage" />
    </member>
    <member name="T:IVkPhysicalDeviceProperties">
      <summary>Structure specifying physical device properties</summary>
      <remarks>

The <c>vendorID</c> and <c>deviceID</c> fields are provided to allow
applications to adapt to device characteristics that are not adequately
exposed by other Vulkan queries.
These  may include performance profiles, hardware errata, or other
characteristics.
In PCI-based implementations, the low sixteen bits of <c>vendorID</c> and
<c>deviceID</c> must contain (respectively) the PCI vendor and device IDs
associated with the hardware device, and the remaining bits  must be set to
zero.
In non-PCI implementations, the choice of what values to return  may be
dictated by operating system or platform policies.
It is otherwise at the discretion of the implementer, subject to the
following constraints and guidelines:

<list type="bullet"><item><description>
For purposes of physical device identification, the  vendor of a
physical device is the entity responsible for the most salient
characteristics of the hardware represented by the physical device
handle.
In the case of a discrete GPU, this  should be the GPU chipset vendor.
In the case of a GPU or other accelerator integrated into a
system-on-chip (SoC), this  should be the supplier of the silicon IP
used to create the GPU or other accelerator.
</description></item><item><description>
If the vendor of the physical device has a valid PCI vendor ID issued by
<a href="https://pcisig.com/">PCI-SIG</a>, that ID  should be used to construct
<c>vendorID</c> as described above for PCI-based implementations.
Implementations that do not return a PCI vendor ID in <c>vendorID</c> must return a valid Khronos vendor ID, obtained as described in the
<a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vulkan-styleguide">Vulkan Documentation and Extensions</a> document in
the section &amp;#8220;Registering a Vendor ID with Khronos&amp;#8221;.
Khronos vendor IDs are allocated starting at 0x10000, to distinguish
them from the PCI vendor ID namespace.
</description></item><item><description>
The vendor of the physical device is responsible for selecting
<c>deviceID</c>.
The value selected  should uniquely identify both the device version and
any major configuration options (for example, core count in the case of
multicore devices).
The same device ID  should be used for all physical implementations of
that device version and configuration.
For example, all uses of a specific silicon IP GPU version and
configuration  should use the same device ID, even if those uses occur
in different SoCs.
</description></item></list>


The <c>VkPhysicalDeviceProperties</c> structure is defined as:


<code> typedef struct VkPhysicalDeviceProperties {
    uint32_t                            apiVersion;
    uint32_t                            driverVersion;
    uint32_t                            vendorID;
    uint32_t                            deviceID;
    VkPhysicalDeviceType                deviceType;
    char                                deviceName[VK_MAX_PHYSICAL_DEVICE_NAME_SIZE];
    uint8_t                             pipelineCacheUUID[VK_UUID_SIZE];
    VkPhysicalDeviceLimits              limits;
    VkPhysicalDeviceSparseProperties    sparseProperties;
} VkPhysicalDeviceProperties; </code>

</remarks>
      <seealso cref="T:IVkPhysicalDeviceLimits" />
      <seealso cref="T:VkPhysicalDeviceSparseProperties" />
      <seealso cref="T:VkPhysicalDeviceType" />
      <seealso cref="T:vkGetPhysicalDeviceProperties" />
    </member>
    <member name="T:VkPhysicalDeviceProperties32">
      <summary>See: <see cref="T:IVkPhysicalDeviceProperties" /></summary>
      <seealso cref="T:IVkPhysicalDeviceProperties" />
    </member>
    <member name="T:VkPhysicalDeviceProperties64">
      <summary>See: <see cref="T:IVkPhysicalDeviceProperties" /></summary>
      <seealso cref="T:IVkPhysicalDeviceProperties" />
    </member>
    <member name="T:vkDestroyShaderModule">
      <summary>Destroy a shader module module</summary>
      <remarks>

A shader module  can be destroyed while pipelines created using its shaders
are still in use.



Valid Usage
<list type="bullet"><item><description>

If <c>VkAllocationCallbacks</c> were provided when <c>shaderModule</c> was
created, a compatible set of callbacks  must be provided here
</description></item><item><description>

If no <c>VkAllocationCallbacks</c> were provided when <c>shaderModule</c>
was created, <c>pAllocator</c> must be <c>NULL</c>
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>device</c> must be a valid <c>VkDevice</c> handle
</description></item><item><description>
 If <c>shaderModule</c> is not <see cref="!:VK_NULL_HANDLE" />, <c>shaderModule</c> must be a valid <c>VkShaderModule</c> handle
</description></item><item><description>
 If <c>pAllocator</c> is not <c>NULL</c>, <c>pAllocator</c> must be a pointer to a valid <c>VkAllocationCallbacks</c> structure
</description></item><item><description>
 If <c>shaderModule</c> is a valid handle, it  must have been created, allocated, or retrieved from <c>device</c>
</description></item></list>




Host Synchronization
<list type="bullet"><item><description>
Host access to <c>shaderModule</c> must  be externally synchronized
</description></item></list>




To destroy a shader module, call:


<code> void vkDestroyShaderModule(
    VkDevice                                    device,
    VkShaderModule                              shaderModule,
    const VkAllocationCallbacks*                pAllocator); </code>

</remarks>
      <seealso cref="T:IVkAllocationCallbacks" />
      <seealso cref="T:VkDevice" />
      <seealso cref="T:VkShaderModule" />
    </member>
    <member name="T:IVkSwapchainCreateInfoKHR" />
    <member name="T:VkSwapchainCreateInfoKHR32">
      <summary>See: <see cref="T:IVkSwapchainCreateInfoKHR" /></summary>
      <seealso cref="T:IVkSwapchainCreateInfoKHR" />
    </member>
    <member name="T:VkSwapchainCreateInfoKHR64">
      <summary>See: <see cref="T:IVkSwapchainCreateInfoKHR" /></summary>
      <seealso cref="T:IVkSwapchainCreateInfoKHR" />
    </member>
    <member name="T:vkDestroyBuffer">
      <summary>Destroy a buffer object</summary>
      <remarks>


Valid Usage
<list type="bullet"><item><description>

All submitted commands that refer to <c>buffer</c>, either directly or
via a <c>VkBufferView</c>,  must have completed execution
</description></item><item><description>

If <c>VkAllocationCallbacks</c> were provided when <c>buffer</c> was
created, a compatible set of callbacks  must be provided here
</description></item><item><description>

If no <c>VkAllocationCallbacks</c> were provided when <c>buffer</c> was
created, <c>pAllocator</c> must be <c>NULL</c>
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>device</c> must be a valid <c>VkDevice</c> handle
</description></item><item><description>
 If <c>buffer</c> is not <see cref="!:VK_NULL_HANDLE" />, <c>buffer</c> must be a valid <c>VkBuffer</c> handle
</description></item><item><description>
 If <c>pAllocator</c> is not <c>NULL</c>, <c>pAllocator</c> must be a pointer to a valid <c>VkAllocationCallbacks</c> structure
</description></item><item><description>
 If <c>buffer</c> is a valid handle, it  must have been created, allocated, or retrieved from <c>device</c>
</description></item></list>




Host Synchronization
<list type="bullet"><item><description>
Host access to <c>buffer</c> must  be externally synchronized
</description></item></list>




To destroy a buffer, call:


<code> void vkDestroyBuffer(
    VkDevice                                    device,
    VkBuffer                                    buffer,
    const VkAllocationCallbacks*                pAllocator); </code>

</remarks>
      <seealso cref="T:IVkAllocationCallbacks" />
      <seealso cref="T:VkBuffer" />
      <seealso cref="T:VkDevice" />
    </member>
    <member name="T:vkGetPhysicalDeviceImageFormatProperties">
      <summary>Lists physical device's image format capabilities</summary>
      <remarks>

The <c>format</c>, <c>type</c>, <c>tiling</c>, <c>usage</c>, and <c>flags</c>
parameters correspond to parameters that would be consumed by
<see cref="T:vkCreateImage" /> (as members of <c>VkImageCreateInfo</c>).


If <c>format</c> is not a supported image format, or if the combination of
<c>format</c>, <c>type</c>, <c>tiling</c>, <c>usage</c>, and <c>flags</c> is not
supported for images, then <c>vkGetPhysicalDeviceImageFormatProperties</c>
returns <c>VK_ERROR_FORMAT_NOT_SUPPORTED</c>.


The limitations on an image format that are reported by
<c>vkGetPhysicalDeviceImageFormatProperties</c> have the following property:
if <c>usage1</c> and <c>usage2</c> of type <see cref="T:VkImageUsageFlags" /> are such that
the bits set in <c>usage1</c> are a subset of the bits set in <c>usage2</c>, and
<c>flags1</c> and <c>flags2</c> of type <see cref="T:VkImageCreateFlags" /> are such that
the bits set in <c>flags1</c> are a subset of the bits set in <c>flags2</c>,
then the limitations for <c>usage1</c> and <c>flags1</c> must be no more strict
than the limitations for <c>usage2</c> and <c>flags2</c>, for all values of
<c>format</c>, <c>type</c>, and <c>tiling</c>.



Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>physicalDevice</c> must be a valid <c>VkPhysicalDevice</c> handle
</description></item><item><description>
<c>format</c> must be a valid <see cref="T:VkFormat" /> value
</description></item><item><description>
<c>type</c> must be a valid <see cref="T:VkImageType" /> value
</description></item><item><description>
<c>tiling</c> must be a valid <see cref="T:VkImageTiling" /> value
</description></item><item><description>
<c>usage</c> must be a valid combination of <see cref="T:VkImageUsageFlags" /> values
</description></item><item><description>
<c>usage</c> must not be <c>0</c>
</description></item><item><description>
<c>flags</c> must be a valid combination of <see cref="T:VkImageCreateFlags" /> values
</description></item><item><description>
<c>pImageFormatProperties</c> must be a pointer to a <c>VkImageFormatProperties</c> structure
</description></item></list>




Return Codes
<dl><dt>On success, this command returns</dt><dd>
<list type="bullet"><item><description>
<c>VK_SUCCESS</c>
</description></item></list>
</dd><dt>On failure, this command returns</dt><dd>
<list type="bullet"><item><description>
<c>VK_ERROR_OUT_OF_HOST_MEMORY</c>
</description></item><item><description>
<c>VK_ERROR_OUT_OF_DEVICE_MEMORY</c>
</description></item><item><description>
<c>VK_ERROR_FORMAT_NOT_SUPPORTED</c>
</description></item></list>
</dd></dl>




To query additional capabilities specific to image types, call:


<code> VkResult vkGetPhysicalDeviceImageFormatProperties(
    VkPhysicalDevice                            physicalDevice,
    VkFormat                                    format,
    VkImageType                                 type,
    VkImageTiling                               tiling,
    VkImageUsageFlags                           usage,
    VkImageCreateFlags                          flags,
    VkImageFormatProperties*                    pImageFormatProperties); </code>

</remarks>
      <seealso cref="T:VkFormat" />
      <seealso cref="T:VkImageCreateFlags" />
      <seealso cref="T:VkImageFormatProperties" />
      <seealso cref="T:VkImageTiling" />
      <seealso cref="T:VkImageType" />
      <seealso cref="T:VkImageUsageFlags" />
      <seealso cref="T:VkPhysicalDevice" />
    </member>
    <member name="T:vkUnmapMemory">
      <summary>Unmap a previously mapped memory object</summary>
      <remarks>


Valid Usage
<list type="bullet"><item><description>
<c>memory</c> must  currently be mapped
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>device</c> must be a valid <c>VkDevice</c> handle
</description></item><item><description>
<c>memory</c> must be a valid <c>VkDeviceMemory</c> handle
</description></item><item><description>
<c>memory</c> must have been created, allocated, or retrieved from <c>device</c>
</description></item></list>




Host Synchronization
<list type="bullet"><item><description>
Host access to <c>memory</c> must  be externally synchronized
</description></item></list>




To unmap a memory object once host access to it is no longer needed by the
application, call:


<code> void vkUnmapMemory(
    VkDevice                                    device,
    VkDeviceMemory                              memory); </code>

</remarks>
      <seealso cref="T:VkDevice" />
      <seealso cref="T:VkDeviceMemory" />
    </member>
    <member name="T:IVkDeviceQueueCreateInfo">
      <summary>Structure specifying parameters of a newly created device queue</summary>
      <remarks>


Valid Usage
<list type="bullet"><item><description>
<c>queueFamilyIndex</c> must be less than
<c>pQueueFamilyPropertyCount</c> returned by
<c>vkGetPhysicalDeviceQueueFamilyProperties</c>
</description></item><item><description>
<c>queueCount</c> must be less than or equal to the <c>queueCount</c>
member of the <c>VkQueueFamilyProperties</c> structure, as returned by
<c>vkGetPhysicalDeviceQueueFamilyProperties</c> in the
<c>pQueueFamilyProperties</c>[<c>queueFamilyIndex</c>]
</description></item><item><description>

Each element of <c>pQueuePriorities</c> must be between <c>0.0</c> and <c>1.0</c>
inclusive
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>sType</c> must be <c>VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO</c>
</description></item><item><description>
<c>pNext</c> must be <c>NULL</c>
</description></item><item><description>
<c>flags</c> must be <c>0</c>
</description></item><item><description>
<c>pQueuePriorities</c> must be a pointer to an array of <c>queueCount</c><c>float</c> values
</description></item><item><description>
<c>queueCount</c> must be greater than <c>0</c>
</description></item></list>




The <c>VkDeviceQueueCreateInfo</c> structure is defined as:


<code> typedef struct VkDeviceQueueCreateInfo {
    VkStructureType             sType;
    const void*                 pNext;
    VkDeviceQueueCreateFlags    flags;
    uint32_t                    queueFamilyIndex;
    uint32_t                    queueCount;
    const float*                pQueuePriorities;
} VkDeviceQueueCreateInfo; </code>

</remarks>
      <seealso cref="T:IVkDeviceCreateInfo" />
      <seealso cref="T:VkDeviceQueueCreateFlags" />
      <seealso cref="T:VkStructureType" />
    </member>
    <member name="T:VkDeviceQueueCreateInfo32">
      <summary>See: <see cref="T:IVkDeviceQueueCreateInfo" /></summary>
      <seealso cref="T:IVkDeviceQueueCreateInfo" />
    </member>
    <member name="T:VkDeviceQueueCreateInfo64">
      <summary>See: <see cref="T:IVkDeviceQueueCreateInfo" /></summary>
      <seealso cref="T:IVkDeviceQueueCreateInfo" />
    </member>
    <member name="T:VkDescriptorImageInfo">
      <summary>Structure specifying descriptor image info</summary>
      <remarks>

Members of <c>VkDescriptorImageInfo</c> that are not used in an update (as
described above) are ignored.



Valid Usage
<list type="bullet"><item><description>
<c>imageLayout</c> must match the actual <see cref="T:VkImageLayout" /> of each
subresource accessible from <c>imageView</c> at the time this descriptor
is accessed
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
 Both of <c>imageView</c>, and <c>sampler</c> that are valid handles  must have been created, allocated, or retrieved from the same <c>VkDevice</c>
</description></item></list>




The <c>VkDescriptorImageInfo</c> structure is defined as:


<code> typedef struct VkDescriptorImageInfo {
    VkSampler        sampler;
    VkImageView      imageView;
    VkImageLayout    imageLayout;
} VkDescriptorImageInfo; </code>

</remarks>
      <seealso cref="T:VkImageLayout" />
      <seealso cref="T:VkImageView" />
      <seealso cref="T:VkSampler" />
      <seealso cref="T:IVkWriteDescriptorSet" />
    </member>
    <member name="T:VkSurfaceCapabilitiesKHR" />
    <member name="T:VkDescriptorPoolSize">
      <summary>Structure specifying descriptor pool size</summary>
      <remarks>


Valid Usage
<list type="bullet"><item><description>
<c>descriptorCount</c> must be greater than <c>0</c>
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>type</c> must be a valid <see cref="T:VkDescriptorType" /> value
</description></item></list>




The <c>VkDescriptorPoolSize</c> structure is defined as:


<code> typedef struct VkDescriptorPoolSize {
    VkDescriptorType    type;
    uint32_t            descriptorCount;
} VkDescriptorPoolSize; </code>

</remarks>
      <seealso cref="T:IVkDescriptorPoolCreateInfo" />
      <seealso cref="T:VkDescriptorType" />
    </member>
    <member name="T:VkDisplayPlaneCapabilitiesKHR" />
    <member name="T:IVkExportSemaphoreCreateInfoKHX" />
    <member name="T:VkExportSemaphoreCreateInfoKHX32">
      <summary>See: <see cref="T:IVkExportSemaphoreCreateInfoKHX" /></summary>
      <seealso cref="T:IVkExportSemaphoreCreateInfoKHX" />
    </member>
    <member name="T:VkExportSemaphoreCreateInfoKHX64">
      <summary>See: <see cref="T:IVkExportSemaphoreCreateInfoKHX" /></summary>
      <seealso cref="T:IVkExportSemaphoreCreateInfoKHX" />
    </member>
    <member name="T:IVkFormatProperties2KHR" />
    <member name="T:VkFormatProperties2KHR32">
      <summary>See: <see cref="T:IVkFormatProperties2KHR" /></summary>
      <seealso cref="T:IVkFormatProperties2KHR" />
    </member>
    <member name="T:VkFormatProperties2KHR64">
      <summary>See: <see cref="T:IVkFormatProperties2KHR" /></summary>
      <seealso cref="T:IVkFormatProperties2KHR" />
    </member>
    <member name="T:VkBufferCopy">
      <summary>Structure specifying a buffer copy operation</summary>
      <remarks>

The <c>VkBufferCopy</c> structure is defined as:


<code> typedef struct VkBufferCopy {
    VkDeviceSize    srcOffset;
    VkDeviceSize    dstOffset;
    VkDeviceSize    size;
} VkBufferCopy; </code>

</remarks>
      <seealso cref="T:vkCmdCopyBuffer" />
    </member>
    <member name="T:IVkDebugMarkerObjectNameInfoEXT" />
    <member name="T:VkDebugMarkerObjectNameInfoEXT32">
      <summary>See: <see cref="T:IVkDebugMarkerObjectNameInfoEXT" /></summary>
      <seealso cref="T:IVkDebugMarkerObjectNameInfoEXT" />
    </member>
    <member name="T:VkDebugMarkerObjectNameInfoEXT64">
      <summary>See: <see cref="T:IVkDebugMarkerObjectNameInfoEXT" /></summary>
      <seealso cref="T:IVkDebugMarkerObjectNameInfoEXT" />
    </member>
    <member name="T:vkGetDisplayModePropertiesKHR" />
    <member name="T:VkImageFormatProperties">
      <summary>Structure specifying a image format properties</summary>
      <remarks>
<list type="table"><tr><td><i title="Note"></i></td><td>
Note

There is no mechanism to query the size of an image before creating it, to
compare that size against <c>maxResourceSize</c>.
If an application attempts to create an image that exceeds this limit, the
creation will fail or the image will be invalid.
While the advertised limit  must be at least 2<sup>31</sup>, it  may not be possible
to create an image that approaches that size, particularly for
<c>VK_IMAGE_TYPE_1D</c>.

</td></tr></list>

If the combination of parameters to
<c>vkGetPhysicalDeviceImageFormatProperties</c> is not supported by the
implementation for use in <see cref="T:vkCreateImage" />, then all members of
<c>VkImageFormatProperties</c> will be filled with zero.



The <c>VkImageFormatProperties</c> structure is defined as:


<code> typedef struct VkImageFormatProperties {
    VkExtent3D            maxExtent;
    uint32_t              maxMipLevels;
    uint32_t              maxArrayLayers;
    VkSampleCountFlags    sampleCounts;
    VkDeviceSize          maxResourceSize;
} VkImageFormatProperties; </code>

</remarks>
      <seealso cref="T:VkExtent3D" />
      <seealso cref="T:VkSampleCountFlags" />
      <seealso cref="T:vkGetPhysicalDeviceImageFormatProperties" />
    </member>
    <member name="T:vkCmdDispatchIndirect">
      <summary>Dispatch compute work items using indirect parameters</summary>
      <remarks>

<c>vkCmdDispatchIndirect</c> behaves similarly to <see cref="T:vkCmdDispatch" /> except
that the parameters are read by the device from a buffer during execution.
The parameters of the dispatch are encoded in a
<see cref="T:VkDispatchIndirectCommand" /> structure taken from <c>buffer</c> starting
at <c>offset</c>.



Valid Usage
<list type="bullet"><item><description>

If <c>buffer</c> is non-sparse then it  must be bound completely and
contiguously to a single <c>VkDeviceMemory</c> object
</description></item><item><description>

For each set  n that is statically used by the <c>VkPipeline</c>
currently bound to <c>VK_PIPELINE_BIND_POINT_COMPUTE</c>, a descriptor
set  must have been bound to  n at
<c>VK_PIPELINE_BIND_POINT_COMPUTE</c>, with a <c>VkPipelineLayout</c> that
is compatible for set  n, with the <c>VkPipelineLayout</c> used to
create the current <c>VkPipeline</c>, as described in
<a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#descriptorsets-compatibility">../../html/vkspec.html#descriptorsets-compatibility</a>
</description></item><item><description>

Descriptors in each bound descriptor set, specified via
<c>vkCmdBindDescriptorSets</c>,  must be valid if they are statically
used by the currently bound <c>VkPipeline</c> object, specified via
<c>vkCmdBindPipeline</c>
</description></item><item><description>

A valid compute pipeline  must be bound to the current command buffer
with <c>VK_PIPELINE_BIND_POINT_COMPUTE</c>
</description></item><item><description>
<c>buffer</c> must have been created with the
<c>VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT</c> bit set
</description></item><item><description>
<c>offset</c> must be a multiple of <c>4</c>
</description></item><item><description>

The sum of <c>offset</c> and the size of <c>VkDispatchIndirectCommand</c> must be less than or equal to the size of <c>buffer</c>
</description></item><item><description>

For each push constant that is statically used by the <c>VkPipeline</c>
currently bound to <c>VK_PIPELINE_BIND_POINT_COMPUTE</c>, a push constant
value  must have been set for <c>VK_PIPELINE_BIND_POINT_COMPUTE</c>, with
a <c>VkPipelineLayout</c> that is compatible for push constants with the
one used to create the current <c>VkPipeline</c>, as described in
<a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#descriptorsets-compatibility">../../html/vkspec.html#descriptorsets-compatibility</a>
</description></item><item><description>

If any <c>VkSampler</c> object that is accessed from a shader by the
<c>VkPipeline</c> currently bound to <c>VK_PIPELINE_BIND_POINT_COMPUTE</c>
uses unnormalized coordinates, it  must not be used to sample from any
<c>VkImage</c> with a <c>VkImageView</c> of the type
<c>VK_IMAGE_VIEW_TYPE_3D</c>, <c>VK_IMAGE_VIEW_TYPE_CUBE</c>,
<c>VK_IMAGE_VIEW_TYPE_1D_ARRAY</c>, <c>VK_IMAGE_VIEW_TYPE_2D_ARRAY</c> or
<c>VK_IMAGE_VIEW_TYPE_CUBE_ARRAY</c>, in any shader stage
</description></item><item><description>

If any <c>VkSampler</c> object that is accessed from a shader by the
<c>VkPipeline</c> currently bound to <c>VK_PIPELINE_BIND_POINT_COMPUTE</c>
uses unnormalized coordinates, it  must not be used with any of the
SPIR-V <c>OpImageSample*</c> or <c>OpImageSparseSample*</c> instructions with
<c>ImplicitLod</c>, <c>Dref</c> or <c>Proj</c> in their name, in any shader
stage
</description></item><item><description>

If any <c>VkSampler</c> object that is accessed from a shader by the
<c>VkPipeline</c> currently bound to <c>VK_PIPELINE_BIND_POINT_COMPUTE</c>
uses unnormalized coordinates, it  must not be used with any of the
SPIR-V <c>OpImageSample*</c> or <c>OpImageSparseSample*</c> instructions that
includes a LOD bias or any offset values, in any shader stage
</description></item><item><description>

If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-robustBufferAccess">robust buffer access</a>
feature is not enabled, and any shader stage in the <c>VkPipeline</c>
object currently bound to <c>VK_PIPELINE_BIND_POINT_COMPUTE</c> accesses
a uniform buffer, it  must not access values outside of the range of
that buffer specified in the currently bound descriptor set
</description></item><item><description>

If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-robustBufferAccess">robust buffer access</a>
feature is not enabled, and any shader stage in the <c>VkPipeline</c>
object currently bound to <c>VK_PIPELINE_BIND_POINT_COMPUTE</c> accesses
a storage buffer, it  must not access values outside of the range of
that buffer specified in the currently bound descriptor set
</description></item><item><description>

Any <c>VkImageView</c> being sampled with <c>VK_FILTER_LINEAR</c> as a
result of this command  must be of a format which supports linear
filtering, as specified by the
<c>VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT</c> flag in
<c>VkFormatProperties</c>::<c>linearTilingFeatures</c> (for a linear
image) or <c>VkFormatProperties</c>::<c>optimalTilingFeatures</c>(for an
optimally tiled image) returned by
<c>vkGetPhysicalDeviceFormatProperties</c>
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>commandBuffer</c> must be a valid <c>VkCommandBuffer</c> handle
</description></item><item><description>
<c>buffer</c> must be a valid <c>VkBuffer</c> handle
</description></item><item><description>
<c>commandBuffer</c> must be in the  recording state
</description></item><item><description>
 The <c>VkCommandPool</c> that <c>commandBuffer</c> was allocated from  must support compute operations
</description></item><item><description>
 This command  must only be called outside of a render pass instance
</description></item><item><description>
 Both of <c>buffer</c>, and <c>commandBuffer</c> must have been created, allocated, or retrieved from the same <c>VkDevice</c>
</description></item></list>




Host Synchronization
<list type="bullet"><item><description>
Host access to <c>commandBuffer</c> must  be externally synchronized
</description></item><item><description>
Host access to the <c>VkCommandPool</c> that <c>commandBuffer</c> was allocated from  must be externally synchronized
</description></item></list>




Command Properties
<list type="table">       <listheader><tr><term> Command Buffer Levels </term><term> Render Pass Scope </term><term> Supported Queue Types </term><term> Pipeline Type </term></tr></listheader>
<item><term>
Primary<br />
Secondary
</term><term>
Outside
</term><term>
Compute
</term><term>
Compute
</term></item>
</list>



To record an indirect command dispatch, call:


<code> void vkCmdDispatchIndirect(
    VkCommandBuffer                             commandBuffer,
    VkBuffer                                    buffer,
    VkDeviceSize                                offset); </code>

</remarks>
      <seealso cref="T:VkBuffer" />
      <seealso cref="T:VkCommandBuffer" />
    </member>
    <member name="T:vkGetPhysicalDeviceProperties">
      <summary>Returns properties of a physical device</summary>
      <remarks>


Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>physicalDevice</c> must be a valid <c>VkPhysicalDevice</c> handle
</description></item><item><description>
<c>pProperties</c> must be a pointer to a <c>VkPhysicalDeviceProperties</c> structure
</description></item></list>




To query general properties of physical devices once enumerated, call:


<code> void vkGetPhysicalDeviceProperties(
    VkPhysicalDevice                            physicalDevice,
    VkPhysicalDeviceProperties*                 pProperties); </code>

</remarks>
      <seealso cref="T:VkPhysicalDevice" />
      <seealso cref="T:IVkPhysicalDeviceProperties" />
    </member>
    <member name="T:vkRegisterObjectsNVX" />
    <member name="T:IVkDescriptorPoolCreateInfo">
      <summary>Structure specifying parameters of a newly created descriptor pool</summary>
      <remarks>

If multiple <c>VkDescriptorPoolSize</c> structures appear in the
<c>pPoolSizes</c> array then the pool will be created with enough storage for
the total number of descriptors of each type.


Fragmentation of a descriptor pool is possible and  may lead to descriptor
set allocation failures.
A failure due to fragmentation is defined as failing a descriptor set
allocation despite the sum of all outstanding descriptor set allocations
from the pool plus the requested allocation requiring no more than the total
number of descriptors requested at pool creation.
Implementations provide certain guarantees of when fragmentation  must not
cause allocation failure, as described below.


If a descriptor pool has not had any descriptor sets freed since it was
created or most recently reset then fragmentation  must not cause an
allocation failure (note that this is always the case for a pool created
without the <c>VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT</c> bit
set).
Additionally, if all sets allocated from the pool since it was created or
most recently reset use the same number of descriptors (of each type) and
the requested allocation also uses that same number of descriptors (of each
type), then fragmentation  must not cause an allocation failure.


If an allocation failure occurs due to fragmentation, an application  can
create an additional descriptor pool to perform further descriptor set
allocations.



Valid Usage
<list type="bullet"><item><description>
<c>maxSets</c> must be greater than <c>0</c>
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>sType</c> must be <c>VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO</c>
</description></item><item><description>
<c>pNext</c> must be <c>NULL</c>
</description></item><item><description>
<c>flags</c> must be a valid combination of <see cref="T:VkDescriptorPoolCreateFlags" /> values
</description></item><item><description>
<c>pPoolSizes</c> must be a pointer to an array of <c>poolSizeCount</c> valid <c>VkDescriptorPoolSize</c> structures
</description></item><item><description>
<c>poolSizeCount</c> must be greater than <c>0</c>
</description></item></list>




Additional information about the pool is passed in an instance of the
<c>VkDescriptorPoolCreateInfo</c> structure:


<code> typedef struct VkDescriptorPoolCreateInfo {
    VkStructureType                sType;
    const void*                    pNext;
    VkDescriptorPoolCreateFlags    flags;
    uint32_t                       maxSets;
    uint32_t                       poolSizeCount;
    const VkDescriptorPoolSize*    pPoolSizes;
} VkDescriptorPoolCreateInfo; </code>

</remarks>
      <seealso cref="T:VkDescriptorPoolCreateFlags" />
      <seealso cref="T:VkDescriptorPoolSize" />
      <seealso cref="T:VkStructureType" />
      <seealso cref="T:vkCreateDescriptorPool" />
    </member>
    <member name="T:VkDescriptorPoolCreateInfo32">
      <summary>See: <see cref="T:IVkDescriptorPoolCreateInfo" /></summary>
      <seealso cref="T:IVkDescriptorPoolCreateInfo" />
    </member>
    <member name="T:VkDescriptorPoolCreateInfo64">
      <summary>See: <see cref="T:IVkDescriptorPoolCreateInfo" /></summary>
      <seealso cref="T:IVkDescriptorPoolCreateInfo" />
    </member>
    <member name="T:VkAttachmentReference">
      <summary>Structure specifying an attachment reference</summary>
      <remarks>


Valid Usage
<list type="bullet"><item><description>
<c>layout</c> must not be <c>VK_IMAGE_LAYOUT_UNDEFINED</c> or
<c>VK_IMAGE_LAYOUT_PREINITIALIZED</c>
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>layout</c> must be a valid <see cref="T:VkImageLayout" /> value
</description></item></list>




The <c>VkAttachmentReference</c> structure is defined as:


<code> typedef struct VkAttachmentReference {
    uint32_t         attachment;
    VkImageLayout    layout;
} VkAttachmentReference; </code>

</remarks>
      <seealso cref="T:VkImageLayout" />
      <seealso cref="T:IVkSubpassDescription" />
    </member>
    <member name="T:IVkCommandBufferBeginInfo">
      <summary>Structure specifying a command buffer begin operation</summary>
      <remarks>


Valid Usage
<list type="bullet"><item><description>

If <c>flags</c> contains
<c>VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT</c>, the
<c>renderPass</c> member of <c>pInheritanceInfo</c> must be a valid
<c>VkRenderPass</c>
</description></item><item><description>

If <c>flags</c> contains
<c>VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT</c>, the
<c>subpass</c> member of <c>pInheritanceInfo</c> must be a valid subpass
index within the <c>renderPass</c> member of <c>pInheritanceInfo</c>
</description></item><item><description>

If <c>flags</c> contains
<c>VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT</c>, the
<c>framebuffer</c> member of <c>pInheritanceInfo</c> must be either
<see cref="!:VK_NULL_HANDLE" />, or a valid <c>VkFramebuffer</c> that is compatible
with the <c>renderPass</c> member of <c>pInheritanceInfo</c>
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>sType</c> must be <c>VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO</c>
</description></item><item><description>
<c>pNext</c> must be <c>NULL</c>
</description></item><item><description>
<c>flags</c> must be a valid combination of <see cref="T:VkCommandBufferUsageFlags" /> values
</description></item></list>




The <c>VkCommandBufferBeginInfo</c> structure is defined as:


<code> typedef struct VkCommandBufferBeginInfo {
    VkStructureType                          sType;
    const void*                              pNext;
    VkCommandBufferUsageFlags                flags;
    const VkCommandBufferInheritanceInfo*    pInheritanceInfo;
} VkCommandBufferBeginInfo; </code>

</remarks>
      <seealso cref="T:IVkCommandBufferInheritanceInfo" />
      <seealso cref="T:VkCommandBufferUsageFlags" />
      <seealso cref="T:VkStructureType" />
      <seealso cref="T:vkBeginCommandBuffer" />
    </member>
    <member name="T:VkCommandBufferBeginInfo32">
      <summary>See: <see cref="T:IVkCommandBufferBeginInfo" /></summary>
      <seealso cref="T:IVkCommandBufferBeginInfo" />
    </member>
    <member name="T:VkCommandBufferBeginInfo64">
      <summary>See: <see cref="T:IVkCommandBufferBeginInfo" /></summary>
      <seealso cref="T:IVkCommandBufferBeginInfo" />
    </member>
    <member name="T:IVkAllocationCallbacks">
      <summary>Structure containing callback function pointers for memory allocation</summary>
      <remarks>


Valid Usage
<list type="bullet"><item><description>
<c>pfnAllocation</c> must be a pointer to a valid user-defined
<see cref="T:PFN_vkAllocationFunction" />
</description></item><item><description>
<c>pfnReallocation</c> must be a pointer to a valid user-defined
<see cref="T:PFN_vkReallocationFunction" />
</description></item><item><description>
<c>pfnFree</c> must be a pointer to a valid user-defined
<see cref="T:PFN_vkFreeFunction" />
</description></item><item><description>

If either of <c>pfnInternalAllocation</c> or <c>pfnInternalFree</c> is not
<c>NULL</c>, both  must be valid callbacks
</description></item></list>




Allocators are provided by the application as a pointer to a
<c>VkAllocationCallbacks</c> structure:


<code> typedef struct VkAllocationCallbacks {
    void*                                   pUserData;
    PFN_vkAllocationFunction                pfnAllocation;
    PFN_vkReallocationFunction              pfnReallocation;
    PFN_vkFreeFunction                      pfnFree;
    PFN_vkInternalAllocationNotification    pfnInternalAllocation;
    PFN_vkInternalFreeNotification          pfnInternalFree;
} VkAllocationCallbacks; </code>

</remarks>
      <seealso cref="T:PFN_vkAllocationFunction" />
      <seealso cref="T:PFN_vkFreeFunction" />
      <seealso cref="T:PFN_vkInternalAllocationNotification" />
      <seealso cref="T:PFN_vkInternalFreeNotification" />
      <seealso cref="T:PFN_vkReallocationFunction" />
      <seealso cref="T:vkAllocateMemory" />
      <seealso cref="T:vkCreateBuffer" />
      <seealso cref="T:vkCreateBufferView" />
      <seealso cref="T:vkCreateCommandPool" />
      <seealso cref="T:vkCreateComputePipelines" />
      <seealso cref="T:vkCreateDescriptorPool" />
      <seealso cref="T:vkCreateDescriptorSetLayout" />
      <seealso cref="T:vkCreateDevice" />
      <seealso cref="T:vkCreateEvent" />
      <seealso cref="T:vkCreateFence" />
      <seealso cref="T:vkCreateFramebuffer" />
      <seealso cref="T:vkCreateGraphicsPipelines" />
      <seealso cref="T:vkCreateImage" />
      <seealso cref="T:vkCreateImageView" />
      <seealso cref="T:vkCreateInstance" />
      <seealso cref="T:vkCreatePipelineCache" />
      <seealso cref="T:vkCreatePipelineLayout" />
      <seealso cref="T:vkCreateQueryPool" />
      <seealso cref="T:vkCreateRenderPass" />
      <seealso cref="T:vkCreateSampler" />
      <seealso cref="T:vkCreateSemaphore" />
      <seealso cref="T:vkCreateShaderModule" />
      <seealso cref="T:vkDestroyBuffer" />
      <seealso cref="T:vkDestroyBufferView" />
      <seealso cref="T:vkDestroyCommandPool" />
      <seealso cref="T:vkDestroyDescriptorPool" />
      <seealso cref="T:vkDestroyDescriptorSetLayout" />
      <seealso cref="T:vkDestroyDevice" />
      <seealso cref="T:vkDestroyEvent" />
      <seealso cref="T:vkDestroyFence" />
      <seealso cref="T:vkDestroyFramebuffer" />
      <seealso cref="T:vkDestroyImage" />
      <seealso cref="T:vkDestroyImageView" />
      <seealso cref="T:vkDestroyInstance" />
      <seealso cref="T:vkDestroyPipeline" />
      <seealso cref="T:vkDestroyPipelineCache" />
      <seealso cref="T:vkDestroyPipelineLayout" />
      <seealso cref="T:vkDestroyQueryPool" />
      <seealso cref="T:vkDestroyRenderPass" />
      <seealso cref="T:vkDestroySampler" />
      <seealso cref="T:vkDestroySemaphore" />
      <seealso cref="T:vkDestroyShaderModule" />
      <seealso cref="T:vkFreeMemory" />
    </member>
    <member name="T:VkAllocationCallbacks32">
      <summary>See: <see cref="T:IVkAllocationCallbacks" /></summary>
      <seealso cref="T:IVkAllocationCallbacks" />
    </member>
    <member name="T:VkAllocationCallbacks64">
      <summary>See: <see cref="T:IVkAllocationCallbacks" /></summary>
      <seealso cref="T:IVkAllocationCallbacks" />
    </member>
    <member name="T:vkCmdBindPipeline">
      <summary>Bind a pipeline object to a command buffer</summary>
      <remarks>

Once bound, a pipeline binding affects subsequent graphics or compute
commands in the command buffer until a different pipeline is bound to the
bind point.
The pipeline bound to <c>VK_PIPELINE_BIND_POINT_COMPUTE</c> controls the
behavior of <see cref="T:vkCmdDispatch" /> and <see cref="T:vkCmdDispatchIndirect" />.
The pipeline bound to <c>VK_PIPELINE_BIND_POINT_GRAPHICS</c> controls the
behavior of <see cref="T:vkCmdDraw" />, <see cref="T:vkCmdDrawIndexed" />,
<see cref="T:vkCmdDrawIndirect" />, and <see cref="T:vkCmdDrawIndexedIndirect" />.
No other commands are affected by the pipeline state.



Valid Usage
<list type="bullet"><item><description>

If <c>pipelineBindPoint</c> is <c>VK_PIPELINE_BIND_POINT_COMPUTE</c>, the
<c>VkCommandPool</c> that <c>commandBuffer</c> was allocated from  must
support compute operations
</description></item><item><description>

If <c>pipelineBindPoint</c> is <c>VK_PIPELINE_BIND_POINT_GRAPHICS</c>, the
<c>VkCommandPool</c> that <c>commandBuffer</c> was allocated from  must
support graphics operations
</description></item><item><description>

If <c>pipelineBindPoint</c> is <c>VK_PIPELINE_BIND_POINT_COMPUTE</c>,
<c>pipeline</c> must  be a compute pipeline
</description></item><item><description>

If <c>pipelineBindPoint</c> is <c>VK_PIPELINE_BIND_POINT_GRAPHICS</c>,
<c>pipeline</c> must  be a graphics pipeline
</description></item><item><description>

If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-variableMultisampleRate">variable multisample
rate</a> feature is not supported, <c>pipeline</c> is a graphics pipeline,
the current subpass has no attachments, and this is not the first call
to this function with a graphics pipeline after transitioning to the
current subpass, then the sample count specified by this pipeline  must
match that set in the previous pipeline
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>commandBuffer</c> must be a valid <c>VkCommandBuffer</c> handle
</description></item><item><description>
<c>pipelineBindPoint</c> must be a valid <see cref="T:VkPipelineBindPoint" /> value
</description></item><item><description>
<c>pipeline</c> must be a valid <c>VkPipeline</c> handle
</description></item><item><description>
<c>commandBuffer</c> must be in the  recording state
</description></item><item><description>
 The <c>VkCommandPool</c> that <c>commandBuffer</c> was allocated from  must support graphics, or compute operations
</description></item><item><description>
 Both of <c>commandBuffer</c>, and <c>pipeline</c> must have been created, allocated, or retrieved from the same <c>VkDevice</c>
</description></item></list>




Host Synchronization
<list type="bullet"><item><description>
Host access to <c>commandBuffer</c> must  be externally synchronized
</description></item><item><description>
Host access to the <c>VkCommandPool</c> that <c>commandBuffer</c> was allocated from  must be externally synchronized
</description></item></list>




Command Properties
<list type="table">       <listheader><tr><term> Command Buffer Levels </term><term> Render Pass Scope </term><term> Supported Queue Types </term><term> Pipeline Type </term></tr></listheader>
<item><term>
Primary<br />
Secondary
</term><term>
Both
</term><term>
Graphics<br />
compute
</term><term></term></item>
</list>



Once a pipeline has been created, it  can be bound to the command buffer
using the command:


<code> void vkCmdBindPipeline(
    VkCommandBuffer                             commandBuffer,
    VkPipelineBindPoint                         pipelineBindPoint,
    VkPipeline                                  pipeline); </code>

</remarks>
      <seealso cref="T:VkCommandBuffer" />
      <seealso cref="T:VkPipeline" />
      <seealso cref="T:VkPipelineBindPoint" />
    </member>
    <member name="T:VkClearRect">
      <summary>Structure specifying a clear rectangle</summary>
      <remarks>

The layers  [<c>baseArrayLayer</c>, <c>baseArrayLayer</c> + 
<c>layerCount</c>) counting from the base layer of the attachment image view
are cleared.



The <c>VkClearRect</c> structure is defined as:


<code> typedef struct VkClearRect {
    VkRect2D    rect;
    uint32_t    baseArrayLayer;
    uint32_t    layerCount;
} VkClearRect; </code>

</remarks>
      <seealso cref="T:VkRect2D" />
      <seealso cref="T:vkCmdClearAttachments" />
    </member>
    <member name="T:IVkPhysicalDeviceBlendOperationAdvancedPropertiesEXT" />
    <member name="T:VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT32">
      <summary>See: <see cref="T:IVkPhysicalDeviceBlendOperationAdvancedPropertiesEXT" /></summary>
      <seealso cref="T:IVkPhysicalDeviceBlendOperationAdvancedPropertiesEXT" />
    </member>
    <member name="T:VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT64">
      <summary>See: <see cref="T:IVkPhysicalDeviceBlendOperationAdvancedPropertiesEXT" /></summary>
      <seealso cref="T:IVkPhysicalDeviceBlendOperationAdvancedPropertiesEXT" />
    </member>
    <member name="T:IVkSubpassDescription">
      <summary>Structure specifying a subpass description</summary>
      <remarks>

The contents of an attachment within the render area become undefined at the
start of a subpass  S if all of the following conditions are true:

<list type="bullet"><item><description>
The attachment is used as a color, depth/stencil, or resolve attachment
in any subpass in the render pass.
</description></item><item><description>
There is a subpass  S<sub>1</sub> that uses or preserves the attachment, and a
subpass dependency from  S<sub>1</sub> to  S.
</description></item><item><description>
The attachment is not used or preserved in subpass  S.
</description></item></list>

Once the contents of an attachment become undefined in subpass  S, they
remain undefined for subpasses in subpass dependency chains starting with
subpass  S until they are written again.
However, they remain valid for subpasses in other subpass dependency chains
starting with subpass  S<sub>1</sub> if those subpasses use or preserve the
attachment.



Valid Usage
<list type="bullet"><item><description>
<c>pipelineBindPoint</c> must be <c>VK_PIPELINE_BIND_POINT_GRAPHICS</c>
</description></item><item><description>
<c>colorAttachmentCount</c> must be less than or equal to
<c>VkPhysicalDeviceLimits</c>::<c>maxColorAttachments</c>
</description></item><item><description>

If the first use of an attachment in this render pass is as an input
attachment, and the attachment is not also used as a color or
depth/stencil attachment in the same subpass, then <c>loadOp</c> must
not be <c>VK_ATTACHMENT_LOAD_OP_CLEAR</c>
</description></item><item><description>

If <c>pResolveAttachments</c> is not <c>NULL</c>, for each resolve attachment
that does not have the value <c>VK_ATTACHMENT_UNUSED</c>, the
corresponding color attachment  must not have the value
<c>VK_ATTACHMENT_UNUSED</c>
</description></item><item><description>

If <c>pResolveAttachments</c> is not <c>NULL</c>, the sample count of each
element of <c>pColorAttachments</c> must be anything other than
<c>VK_SAMPLE_COUNT_1_BIT</c>
</description></item><item><description>

Any given element of <c>pResolveAttachments</c> must have a sample count
of <c>VK_SAMPLE_COUNT_1_BIT</c>
</description></item><item><description>

Any given element of <c>pResolveAttachments</c> must have the same
<see cref="T:VkFormat" /> as its corresponding color attachment
</description></item><item><description>

All attachments in <c>pColorAttachments</c> that are not
<c>VK_ATTACHMENT_UNUSED</c> must  have the same sample count
</description></item><item><description>

If <c>pDepthStencilAttachment</c> is not <c>VK_ATTACHMENT_UNUSED</c> and
any attachments in <c>pColorAttachments</c> are not
<c>VK_ATTACHMENT_UNUSED</c>, they  must have the same sample count
</description></item><item><description>

If any input attachments are <c>VK_ATTACHMENT_UNUSED</c>, then any
pipelines bound during the subpass  must not access those input
attachments from the fragment shader
</description></item><item><description>

The <c>attachment</c> member of any element of <c>pPreserveAttachments</c> must not be <c>VK_ATTACHMENT_UNUSED</c>
</description></item><item><description>

Any given element of <c>pPreserveAttachments</c> must  not also be an
element of any other member of the subpass description
</description></item><item><description>

If any attachment is used as both an input attachment and a color or
depth/stencil attachment, then each use  must use the same <c>layout</c>
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>flags</c> must be a valid combination of <see cref="T:VkSubpassDescriptionFlags" /> values
</description></item><item><description>
<c>pipelineBindPoint</c> must be a valid <see cref="T:VkPipelineBindPoint" /> value
</description></item><item><description>
 If <c>inputAttachmentCount</c> is not <c>0</c>, <c>pInputAttachments</c> must be a pointer to an array of <c>inputAttachmentCount</c> valid <c>VkAttachmentReference</c> structures
</description></item><item><description>
 If <c>colorAttachmentCount</c> is not <c>0</c>, <c>pColorAttachments</c> must be a pointer to an array of <c>colorAttachmentCount</c> valid <c>VkAttachmentReference</c> structures
</description></item><item><description>
 If <c>colorAttachmentCount</c> is not <c>0</c>, and <c>pResolveAttachments</c> is not <c>NULL</c>, <c>pResolveAttachments</c> must be a pointer to an array of <c>colorAttachmentCount</c> valid <c>VkAttachmentReference</c> structures
</description></item><item><description>
 If <c>pDepthStencilAttachment</c> is not <c>NULL</c>, <c>pDepthStencilAttachment</c> must be a pointer to a valid <c>VkAttachmentReference</c> structure
</description></item><item><description>
 If <c>preserveAttachmentCount</c> is not <c>0</c>, <c>pPreserveAttachments</c> must be a pointer to an array of <c>preserveAttachmentCount</c><c>uint32_t</c> values
</description></item></list>




The <c>VkSubpassDescription</c> structure is defined as:


<code> typedef struct VkSubpassDescription {
    VkSubpassDescriptionFlags       flags;
    VkPipelineBindPoint             pipelineBindPoint;
    uint32_t                        inputAttachmentCount;
    const VkAttachmentReference*    pInputAttachments;
    uint32_t                        colorAttachmentCount;
    const VkAttachmentReference*    pColorAttachments;
    const VkAttachmentReference*    pResolveAttachments;
    const VkAttachmentReference*    pDepthStencilAttachment;
    uint32_t                        preserveAttachmentCount;
    const uint32_t*                 pPreserveAttachments;
} VkSubpassDescription; </code>

</remarks>
      <seealso cref="T:VkAttachmentReference" />
      <seealso cref="T:VkPipelineBindPoint" />
      <seealso cref="T:IVkRenderPassCreateInfo" />
      <seealso cref="T:VkSubpassDescriptionFlags" />
    </member>
    <member name="T:VkSubpassDescription32">
      <summary>See: <see cref="T:IVkSubpassDescription" /></summary>
      <seealso cref="T:IVkSubpassDescription" />
    </member>
    <member name="T:VkSubpassDescription64">
      <summary>See: <see cref="T:IVkSubpassDescription" /></summary>
      <seealso cref="T:IVkSubpassDescription" />
    </member>
    <member name="T:VkComponentMapping">
      <summary>Structure specifying a color component mapping</summary>
      <remarks>


Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>r</c> must be a valid <see cref="T:VkComponentSwizzle" /> value
</description></item><item><description>
<c>g</c> must be a valid <see cref="T:VkComponentSwizzle" /> value
</description></item><item><description>
<c>b</c> must be a valid <see cref="T:VkComponentSwizzle" /> value
</description></item><item><description>
<c>a</c> must be a valid <see cref="T:VkComponentSwizzle" /> value
</description></item></list>




The <c>VkComponentMapping</c> structure is defined as:


<code> typedef struct VkComponentMapping {
    VkComponentSwizzle    r;
    VkComponentSwizzle    g;
    VkComponentSwizzle    b;
    VkComponentSwizzle    a;
} VkComponentMapping; </code>

</remarks>
      <seealso cref="T:VkComponentSwizzle" />
      <seealso cref="T:IVkImageViewCreateInfo" />
    </member>
    <member name="T:vkCreateEvent">
      <summary>Create a new event object</summary>
      <remarks>

When created, the event object is in the unsignaled state.



Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>device</c> must be a valid <c>VkDevice</c> handle
</description></item><item><description>
<c>pCreateInfo</c> must be a pointer to a valid <c>VkEventCreateInfo</c> structure
</description></item><item><description>
 If <c>pAllocator</c> is not <c>NULL</c>, <c>pAllocator</c> must be a pointer to a valid <c>VkAllocationCallbacks</c> structure
</description></item><item><description>
<c>pEvent</c> must be a pointer to a <c>VkEvent</c> handle
</description></item></list>




Return Codes
<dl><dt>On success, this command returns</dt><dd>
<list type="bullet"><item><description>
<c>VK_SUCCESS</c>
</description></item></list>
</dd><dt>On failure, this command returns</dt><dd>
<list type="bullet"><item><description>
<c>VK_ERROR_OUT_OF_HOST_MEMORY</c>
</description></item><item><description>
<c>VK_ERROR_OUT_OF_DEVICE_MEMORY</c>
</description></item></list>
</dd></dl>




To create an event, call:


<code> VkResult vkCreateEvent(
    VkDevice                                    device,
    const VkEventCreateInfo*                    pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkEvent*                                    pEvent); </code>

</remarks>
      <seealso cref="T:IVkAllocationCallbacks" />
      <seealso cref="T:VkDevice" />
      <seealso cref="T:VkEvent" />
      <seealso cref="T:IVkEventCreateInfo" />
    </member>
    <member name="T:VkRefreshCycleDurationGOOGLE" />
    <member name="T:VkQueueFamilyProperties">
      <summary>Structure providing information about a queue family</summary>
      <remarks>

The value returned in <c>minImageTransferGranularity</c> has a unit of
compressed texel blocks for images having a block-compressed format, and a
unit of texels otherwise.


Possible values of <c>minImageTransferGranularity</c> are:

<list type="bullet"><item><description>
 (0,0,0) which indicates that only whole mip levels  must be
transferred using the image transfer operations on the corresponding
queues.
In this case, the following restrictions apply to all offset and extent
parameters of image transfer operations:
<list type="bullet"><item><description>
The <c>x</c>, <c>y</c>, and <c>z</c> members of a <see cref="T:VkOffset3D" />
parameter  must always be zero.
</description></item><item><description>
The <c>width</c>, <c>height</c>, and <c>depth</c> members of a
<see cref="T:VkExtent3D" /> parameter  must always match the width, height, and
depth of the image subresource corresponding to the parameter,
respectively.
</description></item></list>
</description></item><item><description>
 (A<sub>x</sub>, A<sub>y</sub>, A<sub>z</sub>) where  A<sub>x</sub>,  A<sub>y</sub>, and  A<sub>z</sub>
are all integer powers of two.
In this case the following restrictions apply to all image transfer
operations:
<list type="bullet"><item><description>
<c>x</c>, <c>y</c>, and <c>z</c> of a <see cref="T:VkOffset3D" /> parameter  must be
integer multiples of  A<sub>x</sub>,  A<sub>y</sub>, and  A<sub>z</sub>,
respectively.
</description></item><item><description>
<c>width</c> of a <see cref="T:VkExtent3D" /> parameter  must be an integer
multiple of  A<sub>x</sub>, or else  <c>x</c> +  <c>width</c> must 
equal the width of the image subresource corresponding to the
parameter.
</description></item><item><description>
<c>height</c> of a <see cref="T:VkExtent3D" /> parameter  must be an integer
multiple of  A<sub>y</sub>, or else  <c>y</c> +  <c>height</c> must 
equal the height of the image subresource corresponding to the
parameter.
</description></item><item><description>
<c>depth</c> of a <see cref="T:VkExtent3D" /> parameter  must be an integer
multiple of  A<sub>z</sub>, or else  <c>z</c> +  <c>depth</c> must 
equal the depth of the image subresource corresponding to the
parameter.
</description></item><item><description>
If the format of the image corresponding to the parameters is one of
the block-compressed formats then for the purposes of the above
calculations the granularity  must be scaled up by the compressed texel
block dimensions.
</description></item></list>
</description></item></list>

Queues supporting graphics and/or compute operations  must report
 (1,1,1) in <c>minImageTransferGranularity</c>, meaning that there are
no additional restrictions on the granularity of image transfer operations
for these queues.
Other queues supporting image transfer operations are only  required to
support whole mip level transfers, thus <c>minImageTransferGranularity</c>
for queues belonging to such queue families  may be  (0,0,0).


The <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#memory-device">Device Memory</a> section describes memory properties
queried from the physical device.


For physical device feature queries see the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features">Features</a> chapter.



The <c>VkQueueFamilyProperties</c> structure is defined as:


<code> typedef struct VkQueueFamilyProperties {
    VkQueueFlags    queueFlags;
    uint32_t        queueCount;
    uint32_t        timestampValidBits;
    VkExtent3D      minImageTransferGranularity;
} VkQueueFamilyProperties; </code>

</remarks>
      <seealso cref="T:VkExtent3D" />
      <seealso cref="T:VkQueueFlags" />
      <seealso cref="T:vkGetPhysicalDeviceQueueFamilyProperties" />
    </member>
    <member name="T:vkGetPhysicalDeviceFeatures">
      <summary>Reports capabilities of a physical device</summary>
      <remarks>


Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>physicalDevice</c> must be a valid <c>VkPhysicalDevice</c> handle
</description></item><item><description>
<c>pFeatures</c> must be a pointer to a <c>VkPhysicalDeviceFeatures</c> structure
</description></item></list>




To query supported features, call:


<code> void vkGetPhysicalDeviceFeatures(
    VkPhysicalDevice                            physicalDevice,
    VkPhysicalDeviceFeatures*                   pFeatures); </code>

</remarks>
      <seealso cref="T:VkPhysicalDevice" />
      <seealso cref="T:VkPhysicalDeviceFeatures" />
    </member>
    <member name="T:VkAttachmentDescription">
      <summary>Structure specifying an attachment description</summary>
      <remarks>

If the attachment uses a color format, then <c>loadOp</c> and <c>storeOp</c>
are used, and <c>stencilLoadOp</c> and <c>stencilStoreOp</c> are ignored.
If the format has depth and/or stencil components, <c>loadOp</c> and
<c>storeOp</c> apply only to the depth data, while <c>stencilLoadOp</c> and
<c>stencilStoreOp</c> define how the stencil data is handled.
<c>loadOp</c> and <c>stencilLoadOp</c> define the  load operations that
execute as part of the first subpass that uses the attachment.
<c>storeOp</c> and <c>stencilStoreOp</c> define the  store operations that
execute as part of the last subpass that uses the attachment.


The load operation for each value in an attachment used by a subpass
happens-before any command recorded into that subpass reads from that value.
Load operations for attachments with a depth/stencil format execute in the
<c>VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT</c> pipeline stage.
Load operations for attachments with a color format execute in the
<c>VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT</c> pipeline stage.


Store operations for each value in an attachment used by a subpass
happen-after any command recorded into that subpass writes to that value.
Store operations for attachments with a depth/stencil format execute in the
<c>VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT</c> pipeline stage.
Store operations for attachments with a color format execute in the
<c>VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT</c> pipeline stage.


If an attachment is not used by any subpass, then <c>loadOp</c>,
<c>storeOp</c>, <c>stencilStoreOp</c>, and <c>stencilLoadOp</c> are ignored,
and the attachment&amp;#8217;s memory contents will not be modified by execution of a
render pass instance.


During a render pass instance, input/color attachments with color formats
that have a component size of 8, 16, or 32 bits  must be represented in the
attachment&amp;#8217;s format throughout the instance.
Attachments with other floating- or fixed-point color formats, or with depth
components  may be represented in a format with a precision higher than the
attachment format, but  must be represented with the same range.
When such a component is loaded via the <c>loadOp</c>, it will be converted
into an implementation-dependent format used by the render pass.
Such components  must be converted from the render pass format, to the
format of the attachment, before they are resolved or stored at the end of a
render pass instance via <c>storeOp</c>.
Conversions occur as described in <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#fundamentals-numerics">Numeric
Representation and Computation</a> and <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#fundamentals-fixedconv">Fixed-Point
Data Conversions</a>.


If <c>flags</c> includes <c>VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT</c>, then
the attachment is treated as if it shares physical memory with another
attachment in the same render pass.
This information limits the ability of the implementation to reorder certain
operations (like layout transitions and the <c>loadOp</c>) such that it is
not improperly reordered against other uses of the same physical memory via
a different attachment.
This is described in more detail below.



Valid Usage
<list type="bullet"><item><description>
<c>finalLayout</c> must not be <c>VK_IMAGE_LAYOUT_UNDEFINED</c> or
<c>VK_IMAGE_LAYOUT_PREINITIALIZED</c>
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>flags</c> must be a valid combination of <see cref="T:VkAttachmentDescriptionFlags" /> values
</description></item><item><description>
<c>format</c> must be a valid <see cref="T:VkFormat" /> value
</description></item><item><description>
<c>samples</c> must be a valid <see cref="T:VkSampleCountFlags" /> value
</description></item><item><description>
<c>loadOp</c> must be a valid <see cref="T:VkAttachmentLoadOp" /> value
</description></item><item><description>
<c>storeOp</c> must be a valid <see cref="T:VkAttachmentStoreOp" /> value
</description></item><item><description>
<c>stencilLoadOp</c> must be a valid <see cref="T:VkAttachmentLoadOp" /> value
</description></item><item><description>
<c>stencilStoreOp</c> must be a valid <see cref="T:VkAttachmentStoreOp" /> value
</description></item><item><description>
<c>initialLayout</c> must be a valid <see cref="T:VkImageLayout" /> value
</description></item><item><description>
<c>finalLayout</c> must be a valid <see cref="T:VkImageLayout" /> value
</description></item></list>




The <c>VkAttachmentDescription</c> structure is defined as:


<code> typedef struct VkAttachmentDescription {
    VkAttachmentDescriptionFlags    flags;
    VkFormat                        format;
    VkSampleCountFlagBits           samples;
    VkAttachmentLoadOp              loadOp;
    VkAttachmentStoreOp             storeOp;
    VkAttachmentLoadOp              stencilLoadOp;
    VkAttachmentStoreOp             stencilStoreOp;
    VkImageLayout                   initialLayout;
    VkImageLayout                   finalLayout;
} VkAttachmentDescription; </code>

</remarks>
      <seealso cref="T:VkAttachmentDescriptionFlags" />
      <seealso cref="T:VkAttachmentLoadOp" />
      <seealso cref="T:VkAttachmentStoreOp" />
      <seealso cref="T:VkFormat" />
      <seealso cref="T:VkImageLayout" />
      <seealso cref="T:IVkRenderPassCreateInfo" />
      <seealso cref="T:VkSampleCountFlags" />
    </member>
    <member name="T:IVkImageViewCreateInfo">
      <summary>Structure specifying parameters of a newly created image view</summary>
      <remarks>

If <c>image</c> was created with the <c>VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT</c>
flag, <c>format</c> can be different from the image&amp;#8217;s format, but if they
are not equal they  must be  compatible.
Image format compatibility is defined in the
<a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-formats-compatibility-classes">Format Compatibility Classes</a>
section.
Views of compatible formats will have the same mapping between texel
coordinates and memory locations irrespective of the <c>format</c>, with only
the interpretation of the bit pattern changing.

<para>Table 1. Image and image view parameter compatibility requirements</para><list type="table">      <listheader><tr><term>Dim, Arrayed, MS</term><term>Image parameters</term><term>View parameters</term></tr></listheader>
<item><th></th><term>
<c>imageType</c> = ci.<c>imageType</c><br /><c>width</c> = ci.<c>extent.width</c><br /><c>height</c> = ci.<c>extent.height</c><br /><c>depth</c> = ci.<c>extent.depth</c><br /><c>arrayLayers</c> = ci.<c>arrayLayers</c><br /><c>samples</c> = ci.<c>samples</c><br /><c>flags</c> = ci.<c>flags</c><br />
    where ci is the <see cref="T:IVkImageCreateInfo" /> used to create <c>image</c>.
</term><term>
<c>baseArrayLayer</c> and <c>layerCount</c>
    are members of the <c>subresourceRange</c> member.
</term></item><item><th>
1D, 0, 0
</th><term>
<c>imageType</c> = <c>VK_IMAGE_TYPE_1D</c><br /><c>width</c> ≥ 1<br /><c>height</c> = 1<br /><c>depth</c> = 1<br /><c>arrayLayers</c> ≥ 1<br /><c>samples</c> = 1
</term><term>
<c>viewType</c> = <c>VK_IMAGE_VIEW_TYPE_1D</c><br /><c>baseArrayLayer</c> ≥ 0<br /><c>layerCount</c> = 1
</term></item><item><th>
1D, 1, 0
</th><term>
<c>imageType</c> = <c>VK_IMAGE_TYPE_1D</c><br /><c>width</c> ≥ 1<br /><c>height</c> = 1<br /><c>depth</c> = 1<br /><c>arrayLayers</c> ≥ 1<br /><c>samples</c> = 1
</term><term>
<c>viewType</c> = <c>VK_IMAGE_VIEW_TYPE_1D_ARRAY</c><br /><c>baseArrayLayer</c> ≥ 0<br /><c>layerCount</c> ≥ 1
</term></item><item><th>
2D, 0, 0
</th><term>
<c>imageType</c> = <c>VK_IMAGE_TYPE_2D</c><br /><c>width</c> ≥ 1<br /><c>height</c> ≥ 1<br /><c>depth</c> = 1<br /><c>arrayLayers</c> ≥ 1<br /><c>samples</c> = 1
</term><term>
<c>viewType</c> = <c>VK_IMAGE_VIEW_TYPE_2D</c><br /><c>baseArrayLayer</c> ≥ 0<br /><c>layerCount</c> = 1
</term></item><item><th>
2D, 1, 0
</th><term>
<c>imageType</c> = <c>VK_IMAGE_TYPE_2D</c><br /><c>width</c> ≥ 1<br /><c>height</c> ≥ 1<br /><c>depth</c> = 1<br /><c>arrayLayers</c> ≥ 1<br /><c>samples</c> = 1
</term><term>
<c>viewType</c> = <c>VK_IMAGE_VIEW_TYPE_2D_ARRAY</c><br /><c>baseArrayLayer</c> ≥ 0<br /><c>layerCount</c> ≥ 1
</term></item><item><th>
2D, 0, 1
</th><term>
<c>imageType</c> = <c>VK_IMAGE_TYPE_2D</c><br /><c>width</c> ≥ 1<br /><c>height</c> ≥ 1<br /><c>depth</c> = 1<br /><c>arrayLayers</c> ≥ 1<br /><c>samples</c> &gt; 1
</term><term>
<c>viewType</c> = <c>VK_IMAGE_VIEW_TYPE_2D</c><br /><c>baseArrayLayer</c> ≥ 0<br /><c>layerCount</c> = 1
</term></item><item><th>
2D, 1, 1
</th><term>
<c>imageType</c> = <c>VK_IMAGE_TYPE_2D</c><br /><c>width</c> ≥ 1<br /><c>height</c> ≥ 1<br /><c>depth</c> = 1<br /><c>arrayLayers</c> ≥ 1<br /><c>samples</c> &gt; 1
</term><term>
<c>viewType</c> = <c>VK_IMAGE_VIEW_TYPE_2D_ARRAY</c><br /><c>baseArrayLayer</c> ≥ 0<br /><c>layerCount</c> ≥ 1
</term></item><item><th>
CUBE, 0, 0
</th><term>
<c>imageType</c> = <c>VK_IMAGE_TYPE_2D</c><br /><c>width</c> ≥ 1<br /><c>height</c> = <c>width</c><br /><c>depth</c> = 1<br /><c>arrayLayers</c> ≥ 6<br /><c>samples</c> = 1<br /><c>flags</c> includes <c>VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT</c>
</term><term>
<c>viewType</c> = <c>VK_IMAGE_VIEW_TYPE_CUBE</c><br /><c>baseArrayLayer</c> ≥ 0<br /><c>layerCount</c> = 6
</term></item><item><th>
CUBE, 1, 0
</th><term>
<c>imageType</c> = <c>VK_IMAGE_TYPE_2D</c><br /><c>width</c> ≥ 1<br /><c>height</c> = width<br /><c>depth</c> = 1<br /> N  ≥ 1<br /><c>arrayLayers</c> ≥ 6 ×  N<br /><c>samples</c> = 1<br /><c>flags</c> includes <c>VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT</c>
</term><term>
<c>viewType</c> = <c>VK_IMAGE_VIEW_TYPE_CUBE_ARRAY</c><br /><c>baseArrayLayer</c> ≥ 0<br /><c>layerCount</c> = 6 ×  N,  N ≥ 1
</term></item><item><th>
3D, 0, 0
</th><term>
<c>imageType</c> = <c>VK_IMAGE_TYPE_3D</c><br /><c>width</c> ≥ 1<br /><c>height</c> ≥ 1<br /><c>depth</c> ≥ 1<br /><c>arrayLayers</c> = 1<br /><c>samples</c> = 1
</term><term>
<c>viewType</c> = <c>VK_IMAGE_VIEW_TYPE_3D</c><br /><c>baseArrayLayer</c> = 0<br /><c>layerCount</c> = 1
</term></item>
</list>


Valid Usage
<list type="bullet"><item><description>

If <c>image</c> was not created with
<c>VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT</c> then <c>viewType</c> must not
be <c>VK_IMAGE_VIEW_TYPE_CUBE</c> or <c>VK_IMAGE_VIEW_TYPE_CUBE_ARRAY</c>
</description></item><item><description>

If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-imageCubeArray">image cubemap arrays</a> feature
is not enabled, <c>viewType</c> must not be
<c>VK_IMAGE_VIEW_TYPE_CUBE_ARRAY</c>
</description></item><item><description>

If <c>image</c> was created with <c>VK_IMAGE_TILING_LINEAR</c>,
<c>format</c> must be format that has at least one supported feature bit
present in the value of
<c>VkFormatProperties</c>::<c>linearTilingFeatures</c> returned by
<c>vkGetPhysicalDeviceFormatProperties</c> with the same value of
<c>format</c>
</description></item><item><description>
<c>image</c> must have been created with a <c>usage</c> value containing
at least one of <c>VK_IMAGE_USAGE_SAMPLED_BIT</c>,
<c>VK_IMAGE_USAGE_STORAGE_BIT</c>,
<c>VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT</c>,
<c>VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT</c>, or
<c>VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT</c>
</description></item><item><description>

If <c>image</c> was created with <c>VK_IMAGE_TILING_LINEAR</c> and
<c>usage</c> contains <c>VK_IMAGE_USAGE_SAMPLED_BIT</c>, <c>format</c> must be supported for sampled images, as specified by the
<c>VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT</c> flag in
<c>VkFormatProperties</c>::<c>linearTilingFeatures</c> returned by
<c>vkGetPhysicalDeviceFormatProperties</c> with the same value of
<c>format</c>
</description></item><item><description>

If <c>image</c> was created with <c>VK_IMAGE_TILING_LINEAR</c> and
<c>usage</c> contains <c>VK_IMAGE_USAGE_STORAGE_BIT</c>, <c>format</c> must be supported for storage images, as specified by the
<c>VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT</c> flag in
<c>VkFormatProperties</c>::<c>linearTilingFeatures</c> returned by
<c>vkGetPhysicalDeviceFormatProperties</c> with the same value of
<c>format</c>
</description></item><item><description>

If <c>image</c> was created with <c>VK_IMAGE_TILING_LINEAR</c> and
<c>usage</c> contains <c>VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT</c>,
<c>format</c> must be supported for color attachments, as specified by
the <c>VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT</c> flag in
<c>VkFormatProperties</c>::<c>linearTilingFeatures</c> returned by
<c>vkGetPhysicalDeviceFormatProperties</c> with the same value of
<c>format</c>
</description></item><item><description>

If <c>image</c> was created with <c>VK_IMAGE_TILING_LINEAR</c> and
<c>usage</c> containing
<c>VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT</c>, <c>format</c> must be
supported for depth/stencil attachments, as specified by the
<c>VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT</c> flag in
<c>VkFormatProperties</c>::<c>linearTilingFeatures</c> returned by
<c>vkGetPhysicalDeviceFormatProperties</c> with the same value of
<c>format</c>
</description></item><item><description>

If <c>image</c> was created with <c>VK_IMAGE_TILING_OPTIMAL</c>,
<c>format</c> must be format that has at least one supported feature bit
present in the value of
<c>VkFormatProperties</c>::<c>optimalTilingFeatures</c> returned by
<c>vkGetPhysicalDeviceFormatProperties</c> with the same value of
<c>format</c>
</description></item><item><description>

If <c>image</c> was created with <c>VK_IMAGE_TILING_OPTIMAL</c> and
<c>usage</c> contains <c>VK_IMAGE_USAGE_SAMPLED_BIT</c>, <c>format</c> must be supported for sampled images, as specified by the
<c>VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT</c> flag in
<c>VkFormatProperties</c>::<c>optimalTilingFeatures</c> returned by
<c>vkGetPhysicalDeviceFormatProperties</c> with the same value of
<c>format</c>
</description></item><item><description>

If <c>image</c> was created with <c>VK_IMAGE_TILING_OPTIMAL</c> and
<c>usage</c> contains <c>VK_IMAGE_USAGE_STORAGE_BIT</c>, <c>format</c> must be supported for storage images, as specified by the
<c>VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT</c> flag in
<c>VkFormatProperties</c>::<c>optimalTilingFeatures</c> returned by
<c>vkGetPhysicalDeviceFormatProperties</c> with the same value of
<c>format</c>
</description></item><item><description>

If <c>image</c> was created with <c>VK_IMAGE_TILING_OPTIMAL</c> and
<c>usage</c> contains <c>VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT</c>,
<c>format</c> must be supported for color attachments, as specified by
the <c>VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT</c> flag in
<c>VkFormatProperties</c>::<c>optimalTilingFeatures</c> returned by
<c>vkGetPhysicalDeviceFormatProperties</c> with the same value of
<c>format</c>
</description></item><item><description>

If <c>image</c> was created with <c>VK_IMAGE_TILING_OPTIMAL</c> and
<c>usage</c> containing
<c>VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT</c>, <c>format</c> must be
supported for depth/stencil attachments, as specified by the
<c>VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT</c> flag in
<c>VkFormatProperties</c>::<c>optimalTilingFeatures</c> returned by
<c>vkGetPhysicalDeviceFormatProperties</c> with the same value of
<c>format</c>
</description></item><item><description>
<c>subresourceRange</c> must be a valid image subresource range for
<c>image</c> (see <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#resources-image-views">../../html/vkspec.html#resources-image-views</a>)
</description></item><item><description>

If <c>image</c> was created with the
<c>VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT</c> flag, <c>format</c> must be
compatible with the <c>format</c> used to create <c>image</c>, as defined
in <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-formats-compatibility-classes">Format Compatibility
Classes</a>
</description></item><item><description>

If <c>image</c> was not created with the
<c>VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT</c> flag, <c>format</c> must be
identical to the <c>format</c> used to create <c>image</c>
</description></item><item><description>

If <c>image</c> is non-sparse then it  must be bound completely and
contiguously to a single <c>VkDeviceMemory</c> object
</description></item><item><description>
<c>subresourceRange</c> and <c>viewType</c> must be compatible with the
image, as described in the
<a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#resources-image-views-compatibility">compatibility table</a>
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>sType</c> must be <c>VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO</c>
</description></item><item><description>
<c>pNext</c> must be <c>NULL</c>
</description></item><item><description>
<c>flags</c> must be <c>0</c>
</description></item><item><description>
<c>image</c> must be a valid <c>VkImage</c> handle
</description></item><item><description>
<c>viewType</c> must be a valid <see cref="T:VkImageViewType" /> value
</description></item><item><description>
<c>format</c> must be a valid <see cref="T:VkFormat" /> value
</description></item><item><description>
<c>components</c> must be a valid <c>VkComponentMapping</c> structure
</description></item><item><description>
<c>subresourceRange</c> must be a valid <c>VkImageSubresourceRange</c> structure
</description></item></list>




The <c>VkImageViewCreateInfo</c> structure is defined as:


<code> typedef struct VkImageViewCreateInfo {
    VkStructureType            sType;
    const void*                pNext;
    VkImageViewCreateFlags     flags;
    VkImage                    image;
    VkImageViewType            viewType;
    VkFormat                   format;
    VkComponentMapping         components;
    VkImageSubresourceRange    subresourceRange;
} VkImageViewCreateInfo; </code>

</remarks>
      <seealso cref="T:VkComponentMapping" />
      <seealso cref="T:VkFormat" />
      <seealso cref="T:VkImage" />
      <seealso cref="T:VkImageSubresourceRange" />
      <seealso cref="T:VkImageViewCreateFlags" />
      <seealso cref="T:VkImageViewType" />
      <seealso cref="T:VkStructureType" />
      <seealso cref="T:vkCreateImageView" />
    </member>
    <member name="T:VkImageViewCreateInfo32">
      <summary>See: <see cref="T:IVkImageViewCreateInfo" /></summary>
      <seealso cref="T:IVkImageViewCreateInfo" />
    </member>
    <member name="T:VkImageViewCreateInfo64">
      <summary>See: <see cref="T:IVkImageViewCreateInfo" /></summary>
      <seealso cref="T:IVkImageViewCreateInfo" />
    </member>
    <member name="T:VkDisplayModePropertiesKHR" />
    <member name="T:IVkBindImageMemorySwapchainInfoKHX" />
    <member name="T:VkBindImageMemorySwapchainInfoKHX32">
      <summary>See: <see cref="T:IVkBindImageMemorySwapchainInfoKHX" /></summary>
      <seealso cref="T:IVkBindImageMemorySwapchainInfoKHX" />
    </member>
    <member name="T:VkBindImageMemorySwapchainInfoKHX64">
      <summary>See: <see cref="T:IVkBindImageMemorySwapchainInfoKHX" /></summary>
      <seealso cref="T:IVkBindImageMemorySwapchainInfoKHX" />
    </member>
    <member name="T:vkGetDisplayPlaneSupportedDisplaysKHR" />
    <member name="T:IVkSurfaceFormat2KHR" />
    <member name="T:VkSurfaceFormat2KHR32">
      <summary>See: <see cref="T:IVkSurfaceFormat2KHR" /></summary>
      <seealso cref="T:IVkSurfaceFormat2KHR" />
    </member>
    <member name="T:VkSurfaceFormat2KHR64">
      <summary>See: <see cref="T:IVkSurfaceFormat2KHR" /></summary>
      <seealso cref="T:IVkSurfaceFormat2KHR" />
    </member>
    <member name="T:vkSetEvent">
      <summary>Set an event to signaled state</summary>
      <remarks>

When <see cref="T:vkSetEvent" /> is executed on the host, it defines an  event signal
operation which sets the event to the signaled state.


If <c>event</c> is already in the signaled state when <see cref="T:vkSetEvent" /> is
executed, then <see cref="T:vkSetEvent" /> has no effect, and no event signal operation
occurs.



Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>device</c> must be a valid <c>VkDevice</c> handle
</description></item><item><description>
<c>event</c> must be a valid <c>VkEvent</c> handle
</description></item><item><description>
<c>event</c> must have been created, allocated, or retrieved from <c>device</c>
</description></item></list>




Host Synchronization
<list type="bullet"><item><description>
Host access to <c>event</c> must  be externally synchronized
</description></item></list>




Return Codes
<dl><dt>On success, this command returns</dt><dd>
<list type="bullet"><item><description>
<c>VK_SUCCESS</c>
</description></item></list>
</dd><dt>On failure, this command returns</dt><dd>
<list type="bullet"><item><description>
<c>VK_ERROR_OUT_OF_HOST_MEMORY</c>
</description></item><item><description>
<c>VK_ERROR_OUT_OF_DEVICE_MEMORY</c>
</description></item></list>
</dd></dl>




To set the state of an event to signaled from the host, call:


<code> VkResult vkSetEvent(
    VkDevice                                    device,
    VkEvent                                     event); </code>

</remarks>
      <seealso cref="T:VkDevice" />
      <seealso cref="T:VkEvent" />
    </member>
    <member name="T:IVkPipelineCacheCreateInfo">
      <summary>Structure specifying parameters of a newly created pipeline cache</summary>
      <remarks>


Valid Usage
<list type="bullet"><item><description>

If <c>initialDataSize</c> is not <c>0</c>, it  must be equal to the size of
<c>pInitialData</c>, as returned by <c>vkGetPipelineCacheData</c> when
<c>pInitialData</c> was originally retrieved
</description></item><item><description>

If <c>initialDataSize</c> is not <c>0</c>, <c>pInitialData</c> must have been
retrieved from a previous call to <c>vkGetPipelineCacheData</c>
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>sType</c> must be <c>VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO</c>
</description></item><item><description>
<c>pNext</c> must be <c>NULL</c>
</description></item><item><description>
<c>flags</c> must be <c>0</c>
</description></item><item><description>
 If <c>initialDataSize</c> is not <c>0</c>, <c>pInitialData</c> must be a pointer to an array of <c>initialDataSize</c> bytes
</description></item></list>




The <c>VkPipelineCacheCreateInfo</c> structure is defined as:


<code> typedef struct VkPipelineCacheCreateInfo {
    VkStructureType               sType;
    const void*                   pNext;
    VkPipelineCacheCreateFlags    flags;
    size_t                        initialDataSize;
    const void*                   pInitialData;
} VkPipelineCacheCreateInfo; </code>

</remarks>
      <seealso cref="T:VkPipelineCacheCreateFlags" />
      <seealso cref="T:VkStructureType" />
      <seealso cref="T:vkCreatePipelineCache" />
    </member>
    <member name="T:VkPipelineCacheCreateInfo32">
      <summary>See: <see cref="T:IVkPipelineCacheCreateInfo" /></summary>
      <seealso cref="T:IVkPipelineCacheCreateInfo" />
    </member>
    <member name="T:VkPipelineCacheCreateInfo64">
      <summary>See: <see cref="T:IVkPipelineCacheCreateInfo" /></summary>
      <seealso cref="T:IVkPipelineCacheCreateInfo" />
    </member>
    <member name="T:IVkPresentTimesInfoGOOGLE" />
    <member name="T:VkPresentTimesInfoGOOGLE32">
      <summary>See: <see cref="T:IVkPresentTimesInfoGOOGLE" /></summary>
      <seealso cref="T:IVkPresentTimesInfoGOOGLE" />
    </member>
    <member name="T:VkPresentTimesInfoGOOGLE64">
      <summary>See: <see cref="T:IVkPresentTimesInfoGOOGLE" /></summary>
      <seealso cref="T:IVkPresentTimesInfoGOOGLE" />
    </member>
    <member name="T:IVkSparseImageMemoryBindInfo">
      <summary>Structure specifying sparse image memory bind info</summary>
      <remarks>


Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>image</c> must be a valid <c>VkImage</c> handle
</description></item><item><description>
<c>pBinds</c> must be a pointer to an array of <c>bindCount</c> valid <c>VkSparseImageMemoryBind</c> structures
</description></item><item><description>
<c>bindCount</c> must be greater than <c>0</c>
</description></item></list>




Memory  can be bound to sparse image blocks of <c>VkImage</c> objects created
with the <c>VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT</c> flag using the following
structure:


<code> typedef struct VkSparseImageMemoryBindInfo {
    VkImage                           image;
    uint32_t                          bindCount;
    const VkSparseImageMemoryBind*    pBinds;
} VkSparseImageMemoryBindInfo; </code>

</remarks>
      <seealso cref="T:IVkBindSparseInfo" />
      <seealso cref="T:VkImage" />
      <seealso cref="T:VkSparseImageMemoryBind" />
    </member>
    <member name="T:VkSparseImageMemoryBindInfo32">
      <summary>See: <see cref="T:IVkSparseImageMemoryBindInfo" /></summary>
      <seealso cref="T:IVkSparseImageMemoryBindInfo" />
    </member>
    <member name="T:VkSparseImageMemoryBindInfo64">
      <summary>See: <see cref="T:IVkSparseImageMemoryBindInfo" /></summary>
      <seealso cref="T:IVkSparseImageMemoryBindInfo" />
    </member>
    <member name="T:VkDrawIndexedIndirectCommand">
      <summary>Structure specifying a draw indexed indirect command</summary>
      <remarks>

The members of <c>VkDrawIndexedIndirectCommand</c> have the same meaning as
the similarly named parameters of <see cref="T:vkCmdDrawIndexed" />.



Valid Usage
<list type="bullet"><item><description>

For a given vertex buffer binding, any attribute data fetched  must be
entirely contained within the corresponding vertex buffer binding, as
described in <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#fxvertex-input">../../html/vkspec.html#fxvertex-input</a>
</description></item><item><description>
 (<c>indexSize</c> * (<c>firstIndex</c> +  <c>indexCount</c>)
+  <c>offset</c>)  must be less than or equal to the size of the
currently bound index buffer, with <c>indexSize</c> being based on the
type specified by <c>indexType</c>, where the index buffer,
<c>indexType</c>, and <c>offset</c> are specified via
<c>vkCmdBindIndexBuffer</c>
</description></item><item><description>

If the
<a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-drawIndirectFirstInstance">drawIndirectFirstInstance</a>
feature is not enabled, <c>firstInstance</c> must be <c>0</c>
</description></item></list>




The <c>VkDrawIndexedIndirectCommand</c> structure is defined as:


<code> typedef struct VkDrawIndexedIndirectCommand {
    uint32_t    indexCount;
    uint32_t    instanceCount;
    uint32_t    firstIndex;
    int32_t     vertexOffset;
    uint32_t    firstInstance;
} VkDrawIndexedIndirectCommand; </code>

</remarks>
      <seealso cref="T:vkCmdDrawIndexedIndirect" />
    </member>
    <member name="T:VkXYColorEXT" />
    <member name="T:VkViewport">
      <summary>Structure specifying a viewport</summary>
      <remarks>

The framebuffer depth coordinate  <c>z</c><sub>f</sub> may be represented using
either a fixed-point or floating-point representation.
However, a floating-point representation  must be used if the depth/stencil
attachment has a floating-point depth component.
If an  m-bit fixed-point representation is used, we assume that it
represents each value \(\frac{k}{2^m - 1}\), where  k ∈ {
0, 1, &amp;#8230;&amp;#8203;, 2<sup>m</sup>-1 }, as  k (e.g. 1.0 is represented in binary as a
string of all ones).


The viewport parameters shown in the above equations are found from these
values as

<dl><dt></dt><dd>
 o<sub>x</sub> = <c>x</c> +  <c>width</c> / 2 
</dd><dt></dt><dd>
 o<sub>y</sub> = <c>y</c> +  <c>height</c> / 2 
</dd><dt></dt><dd>
 o<sub>z</sub> = <c>minDepth</c> 
</dd><dt></dt><dd>
 p<sub>x</sub> = <c>width</c> 
</dd><dt></dt><dd>
 p<sub>y</sub> = <c>height</c> 
</dd><dt></dt><dd>
 p<sub>z</sub> = <c>maxDepth</c> - <c>minDepth</c> .
</dd></dl>

The width and height of the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-limits-maxViewportDimensions">implementation-dependent maximum viewport dimensions</a> must be greater than
or equal to the width and height of the largest image which  can be created
and attached to a framebuffer.


The floating-point viewport bounds are represented with an
<a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-limits-viewportSubPixelBits">implementation-dependent precision</a>.



Valid Usage
<list type="bullet"><item><description>
<c>width</c> must be greater than <c>0.0</c> and less than or equal to
<c>VkPhysicalDeviceLimits</c>::<c>maxViewportDimensions</c>[0]
</description></item><item><description>
<c>height</c> must be greater than <c>0.0</c> and less than or equal to
<c>VkPhysicalDeviceLimits</c>::<c>maxViewportDimensions</c>[1]
</description></item><item><description>
<c>x</c> and <c>y</c> must each be between <c>viewportBoundsRange</c>[0]
and <c>viewportBoundsRange</c>[1], inclusive
</description></item><item><description>
 (<c>x</c> +  <c>width</c>)  must be less than or equal to
<c>viewportBoundsRange</c>[1]
</description></item><item><description>
 (<c>y</c> +  <c>height</c>)  must be less than or equal to
<c>viewportBoundsRange</c>[1]
</description></item><item><description>
<c>minDepth</c> must be between <c>0.0</c> and <c>1.0</c>, inclusive
</description></item><item><description>
<c>maxDepth</c> must be between <c>0.0</c> and <c>1.0</c>, inclusive
</description></item></list>




The <c>VkViewport</c> structure is defined as:


<code> typedef struct VkViewport {
    float    x;
    float    y;
    float    width;
    float    height;
    float    minDepth;
    float    maxDepth;
} VkViewport; </code>

</remarks>
      <seealso cref="T:IVkPipelineViewportStateCreateInfo" />
      <seealso cref="T:vkCmdSetViewport" />
    </member>
    <member name="T:IVkPipelineViewportWScalingStateCreateInfoNV" />
    <member name="T:VkPipelineViewportWScalingStateCreateInfoNV32">
      <summary>See: <see cref="T:IVkPipelineViewportWScalingStateCreateInfoNV" /></summary>
      <seealso cref="T:IVkPipelineViewportWScalingStateCreateInfoNV" />
    </member>
    <member name="T:VkPipelineViewportWScalingStateCreateInfoNV64">
      <summary>See: <see cref="T:IVkPipelineViewportWScalingStateCreateInfoNV" /></summary>
      <seealso cref="T:IVkPipelineViewportWScalingStateCreateInfoNV" />
    </member>
    <member name="T:IVkImageCreateInfo">
      <summary>Structure specifying the parameters of a newly created image object</summary>
      <remarks>

Images created with <c>tiling</c> equal to <c>VK_IMAGE_TILING_LINEAR</c> have
further restrictions on their limits and capabilities compared to images
created with <c>tiling</c> equal to <c>VK_IMAGE_TILING_OPTIMAL</c>.
Creation of images with tiling <c>VK_IMAGE_TILING_LINEAR</c> may  not be
supported unless other parameters meet all of the constraints:

<list type="bullet"><item><description>
<c>imageType</c> is <c>VK_IMAGE_TYPE_2D</c>
</description></item><item><description>
<c>format</c> is not a depth/stencil format
</description></item><item><description>
<c>mipLevels</c> is 1
</description></item><item><description>
<c>arrayLayers</c> is 1
</description></item><item><description>
<c>samples</c> is <c>VK_SAMPLE_COUNT_1_BIT</c>
</description></item><item><description>
<c>usage</c> only includes <c>VK_IMAGE_USAGE_TRANSFER_SRC_BIT</c> and/or
<c>VK_IMAGE_USAGE_TRANSFER_DST_BIT</c>
</description></item></list>

Implementations  may support additional limits and capabilities beyond those
listed above.


To query an implementation&amp;#8217;s specific capabilities for a given combination
of <c>format</c>, <c>type</c>, <c>tiling</c>, <c>usage</c>,
and <c>flags</c>, call
<see cref="T:vkGetPhysicalDeviceImageFormatProperties" />.
The return value indicates whether that combination of image settings is
supported.
On success, the <c>VkImageFormatProperties</c> output parameter indicates the
set of valid <c>samples</c> bits and the limits for <c>extent</c>,
<c>mipLevels</c>, and <c>arrayLayers</c>.


To determine the set of valid <c>usage</c> bits for a given format, call
<see cref="T:vkGetPhysicalDeviceFormatProperties" />.



Valid Usage
<list type="bullet"><item><description>

The combination of <c>format</c>, <c>type</c>, <c>tiling</c>, <c>usage</c>,
and <c>flags</c> must be supported, as indicated by a <c>VK_SUCCESS</c>
return value from <c>vkGetPhysicalDeviceImageFormatProperties</c> invoked
with the same values passed to the corresponding parameters.
</description></item><item><description>

If <c>sharingMode</c> is <c>VK_SHARING_MODE_CONCURRENT</c>,
<c>pQueueFamilyIndices</c> must be a pointer to an array of
<c>queueFamilyIndexCount</c><c>uint32_t</c> values
</description></item><item><description>

If <c>sharingMode</c> is <c>VK_SHARING_MODE_CONCURRENT</c>,
<c>queueFamilyIndexCount</c> must be greater than <c>1</c>
</description></item><item><description>

If <c>sharingMode</c> is <c>VK_SHARING_MODE_CONCURRENT</c>, each element
of <c>pQueueFamilyIndices</c> must be unique and  must be less than
<c>pQueueFamilyPropertyCount</c> returned by
<see cref="T:vkGetPhysicalDeviceQueueFamilyProperties" /> for the
<c>physicalDevice</c> that was used to create <c>device</c>
</description></item><item><description>
<c>format</c> must not be <c>VK_FORMAT_UNDEFINED</c>
</description></item><item><description>
<c>extent</c>::<c>width</c> must be greater than <c>0</c>.
</description></item><item><description>
<c>extent</c>::<c>height</c> must be greater than <c>0</c>.
</description></item><item><description>
<c>extent</c>::<c>depth</c> must be greater than <c>0</c>.
</description></item><item><description>
<c>mipLevels</c> must be greater than <c>0</c>
</description></item><item><description>
<c>arrayLayers</c> must be greater than <c>0</c>
</description></item><item><description>

If <c>flags</c> contains <c>VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT</c>,
<c>imageType</c> must be <c>VK_IMAGE_TYPE_2D</c>
</description></item><item><description>

If <c>imageType</c> is <c>VK_IMAGE_TYPE_1D</c>, <c>extent.width</c> must
be less than or equal to
<c>VkPhysicalDeviceLimits</c>::<c>maxImageDimension1D</c>, or
<c>VkImageFormatProperties</c>::<c>maxExtent.width</c> (as returned by
<c>vkGetPhysicalDeviceImageFormatProperties</c> with <c>format</c>,
<c>type</c>, <c>tiling</c>, <c>usage</c>, and <c>flags</c> equal to those in
this structure) - whichever is higher
</description></item><item><description>

If <c>imageType</c> is <c>VK_IMAGE_TYPE_2D</c> and <c>flags</c> does not
contain <c>VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT</c>, <c>extent.width</c>
and <c>extent.height</c> must be less than or equal to
<c>VkPhysicalDeviceLimits</c>::<c>maxImageDimension2D</c>, or
<c>VkImageFormatProperties</c>::<c>maxExtent.width</c>/height (as returned
by <c>vkGetPhysicalDeviceImageFormatProperties</c> with <c>format</c>,
<c>type</c>, <c>tiling</c>, <c>usage</c>, and <c>flags</c> equal to those in
this structure) - whichever is higher
</description></item><item><description>

If <c>imageType</c> is <c>VK_IMAGE_TYPE_2D</c> and <c>flags</c> contains
<c>VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT</c>, <c>extent.width</c> and
<c>extent.height</c> must be less than or equal to
<c>VkPhysicalDeviceLimits</c>::<c>maxImageDimensionCube</c>, or
<c>VkImageFormatProperties</c>::<c>maxExtent.width</c>/height (as returned
by <c>vkGetPhysicalDeviceImageFormatProperties</c> with <c>format</c>,
<c>type</c>, <c>tiling</c>, <c>usage</c>, and <c>flags</c> equal to those in
this structure) - whichever is higher
</description></item><item><description>

If <c>imageType</c> is <c>VK_IMAGE_TYPE_2D</c> and <c>flags</c> contains
<c>VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT</c>, <c>extent.width</c> and
<c>extent.height</c> must be equal and <c>arrayLayers</c> must  be
greater than or equal to 6
</description></item><item><description>

If <c>imageType</c> is <c>VK_IMAGE_TYPE_3D</c>, <c>extent.width</c>,
<c>extent.height</c> and <c>extent.depth</c> must be less than or equal
to <c>VkPhysicalDeviceLimits</c>::<c>maxImageDimension3D</c>, or
<c>VkImageFormatProperties</c>::<c>maxExtent.width</c>/height/depth (as
returned by <c>vkGetPhysicalDeviceImageFormatProperties</c> with
<c>format</c>, <c>type</c>, <c>tiling</c>, <c>usage</c>, and <c>flags</c>
equal to those in this structure) - whichever is higher
</description></item><item><description>

If <c>imageType</c> is <c>VK_IMAGE_TYPE_1D</c>, both <c>extent.height</c>
and <c>extent.depth</c> must be <c>1</c>
</description></item><item><description>

If <c>imageType</c> is <c>VK_IMAGE_TYPE_2D</c>, <c>extent.depth</c> must
be <c>1</c>
</description></item><item><description>
<c>mipLevels</c> must be less than or equal to
 ⌊log<sub>2</sub>(max(<c>extent.width</c>, <c>extent.height</c>,
<c>extent.depth</c>))⌋ +  1.
</description></item><item><description>

If any of <c>extent.width</c>, <c>extent.height</c>, or <c>extent.depth</c>
are greater than the equivalently named members of
<c>VkPhysicalDeviceLimits</c>::<c>maxImageDimension3D</c>, <c>mipLevels</c> must be less than or equal to
<c>VkImageFormatProperties</c>::<c>maxMipLevels</c> (as returned by
<c>vkGetPhysicalDeviceImageFormatProperties</c> with <c>format</c>,
<c>type</c>, <c>tiling</c>, <c>usage</c>, and <c>flags</c> equal to those in
this structure)
</description></item><item><description>
<c>arrayLayers</c> must be less than or equal to
<c>VkImageFormatProperties</c>::<c>maxArrayLayers</c> (as returned by
<c>vkGetPhysicalDeviceImageFormatProperties</c> with <c>format</c>,
<c>type</c>, <c>tiling</c>, <c>usage</c>, and <c>flags</c> equal to those in
this structure)
</description></item><item><description>

If <c>imageType</c> is <c>VK_IMAGE_TYPE_3D</c>, <c>arrayLayers</c> must be
<c>1</c>.
</description></item><item><description>

If <c>samples</c> is not <c>VK_SAMPLE_COUNT_1_BIT</c>, <c>imageType</c> must be <c>VK_IMAGE_TYPE_2D</c>, <c>flags</c> must not contain
<c>VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT</c>, <c>tiling</c> must be
<c>VK_IMAGE_TILING_OPTIMAL</c>, and <c>mipLevels</c> must be equal to <c>1</c>
</description></item><item><description>

If <c>usage</c> includes <c>VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT</c>,
then bits other than <c>VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT</c>,
<c>VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT</c>, and
<c>VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT</c> must  not be set
</description></item><item><description>

If <c>usage</c> includes <c>VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT</c>,
<c>VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT</c>,
<c>VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT</c>, or
<c>VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT</c>, <c>extent.width</c> must be
less than or equal to
<c>VkPhysicalDeviceLimits</c>::<c>maxFramebufferWidth</c>
</description></item><item><description>

If <c>usage</c> includes <c>VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT</c>,
<c>VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT</c>,
<c>VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT</c>, or
<c>VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT</c>, <c>extent.height</c> must be
less than or equal to
<c>VkPhysicalDeviceLimits</c>::<c>maxFramebufferHeight</c>
</description></item><item><description>

If <c>usage</c> includes <c>VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT</c>,
<c>usage</c> must also contain at least one of
<c>VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT</c>,
<c>VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT</c>, or
<c>VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT</c>.
</description></item><item><description>
<c>samples</c> must be a bit value that is set in
<c>VkImageFormatProperties</c>::<c>sampleCounts</c> returned by
<c>vkGetPhysicalDeviceImageFormatProperties</c> with <c>format</c>,
<c>type</c>, <c>tiling</c>, <c>usage</c>, and <c>flags</c> equal to those in
this structure
</description></item><item><description>

If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-shaderStorageImageMultisample">multisampled
storage images</a> feature is not enabled, and <c>usage</c> contains
<c>VK_IMAGE_USAGE_STORAGE_BIT</c>, <c>samples</c> must be
<c>VK_SAMPLE_COUNT_1_BIT</c>
</description></item><item><description>

If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-sparseBinding">sparse bindings</a> feature is
not enabled, <c>flags</c> must not contain
<c>VK_IMAGE_CREATE_SPARSE_BINDING_BIT</c>
</description></item><item><description>

If <c>imageType</c> is <c>VK_IMAGE_TYPE_1D</c>, <c>flags</c> must not
contain <c>VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT</c>
</description></item><item><description>

If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-sparseResidencyImage2D">sparse residency for
2D images</a> feature is not enabled, and <c>imageType</c> is
<c>VK_IMAGE_TYPE_2D</c>, <c>flags</c> must not contain
<c>VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT</c>
</description></item><item><description>

If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-sparseResidencyImage3D">sparse residency for
3D images</a> feature is not enabled, and <c>imageType</c> is
<c>VK_IMAGE_TYPE_3D</c>, <c>flags</c> must not contain
<c>VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT</c>
</description></item><item><description>

If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-sparseResidency2Samples">sparse residency for
images with 2 samples</a> feature is not enabled, <c>imageType</c> is
<c>VK_IMAGE_TYPE_2D</c>, and <c>samples</c> is
<c>VK_SAMPLE_COUNT_2_BIT</c>, <c>flags</c> must not contain
<c>VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT</c>
</description></item><item><description>

If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-sparseResidency4Samples">sparse residency for
images with 4 samples</a> feature is not enabled, <c>imageType</c> is
<c>VK_IMAGE_TYPE_2D</c>, and <c>samples</c> is
<c>VK_SAMPLE_COUNT_4_BIT</c>, <c>flags</c> must not contain
<c>VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT</c>
</description></item><item><description>

If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-sparseResidency8Samples">sparse residency for
images with 8 samples</a> feature is not enabled, <c>imageType</c> is
<c>VK_IMAGE_TYPE_2D</c>, and <c>samples</c> is
<c>VK_SAMPLE_COUNT_8_BIT</c>, <c>flags</c> must not contain
<c>VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT</c>
</description></item><item><description>

If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-sparseResidency16Samples">sparse residency for
images with 16 samples</a> feature is not enabled, <c>imageType</c> is
<c>VK_IMAGE_TYPE_2D</c>, and <c>samples</c> is
<c>VK_SAMPLE_COUNT_16_BIT</c>, <c>flags</c> must not contain
<c>VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT</c>
</description></item><item><description>

If <c>tiling</c> is <c>VK_IMAGE_TILING_LINEAR</c>, <c>format</c> must be a
format that has at least one supported feature bit present in the value
of <c>VkFormatProperties</c>::<c>linearTilingFeatures</c> returned by
<c>vkGetPhysicalDeviceFormatProperties</c> with the same value of
<c>format</c>
</description></item><item><description>

If <c>tiling</c> is <c>VK_IMAGE_TILING_LINEAR</c>, and
<c>VkFormatProperties</c>::<c>linearTilingFeatures</c> (as returned by
<c>vkGetPhysicalDeviceFormatProperties</c> with the same value of
<c>format</c>) does not include
<c>VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT</c>, <c>usage</c> must not contain
<c>VK_IMAGE_USAGE_SAMPLED_BIT</c>
</description></item><item><description>

If <c>tiling</c> is <c>VK_IMAGE_TILING_LINEAR</c>, and
<c>VkFormatProperties</c>::<c>linearTilingFeatures</c> (as returned by
<c>vkGetPhysicalDeviceFormatProperties</c> with the same value of
<c>format</c>) does not include
<c>VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT</c>, <c>usage</c> must not contain
<c>VK_IMAGE_USAGE_STORAGE_BIT</c>
</description></item><item><description>

If <c>tiling</c> is <c>VK_IMAGE_TILING_LINEAR</c>, and
<c>VkFormatProperties</c>::<c>linearTilingFeatures</c> (as returned by
<c>vkGetPhysicalDeviceFormatProperties</c> with the same value of
<c>format</c>) does not include
<c>VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT</c>, <c>usage</c> must not
contain <c>VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT</c>
</description></item><item><description>

If <c>tiling</c> is <c>VK_IMAGE_TILING_LINEAR</c>, and
<c>VkFormatProperties</c>::<c>linearTilingFeatures</c> (as returned by
<c>vkGetPhysicalDeviceFormatProperties</c> with the same value of
<c>format</c>) does not include
<c>VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT</c>, <c>usage</c> must
not contain <c>VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT</c>
</description></item><item><description>

If <c>tiling</c> is <c>VK_IMAGE_TILING_OPTIMAL</c>, <c>format</c> must be
a format that has at least one supported feature bit present in the
value of <c>VkFormatProperties</c>::<c>optimalTilingFeatures</c> returned
by <c>vkGetPhysicalDeviceFormatProperties</c> with the same value of
<c>format</c>
</description></item><item><description>

If <c>tiling</c> is <c>VK_IMAGE_TILING_OPTIMAL</c>, and
<c>VkFormatProperties</c>::<c>optimalTilingFeatures</c> (as returned by
<c>vkGetPhysicalDeviceFormatProperties</c> with the same value of
<c>format</c>) does not include
<c>VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT</c>, <c>usage</c> must not contain
<c>VK_IMAGE_USAGE_SAMPLED_BIT</c>
</description></item><item><description>

If <c>tiling</c> is <c>VK_IMAGE_TILING_OPTIMAL</c>, and
<c>VkFormatProperties</c>::<c>optimalTilingFeatures</c> (as returned by
<c>vkGetPhysicalDeviceFormatProperties</c> with the same value of
<c>format</c>) does not include
<c>VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT</c>, <c>usage</c> must not contain
<c>VK_IMAGE_USAGE_STORAGE_BIT</c>
</description></item><item><description>

If <c>tiling</c> is <c>VK_IMAGE_TILING_OPTIMAL</c>, and
<c>VkFormatProperties</c>::<c>optimalTilingFeatures</c> (as returned by
<c>vkGetPhysicalDeviceFormatProperties</c> with the same value of
<c>format</c>) does not include
<c>VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT</c>, <c>usage</c> must not
contain <c>VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT</c>
</description></item><item><description>

If <c>tiling</c> is <c>VK_IMAGE_TILING_OPTIMAL</c>, and
<c>VkFormatProperties</c>::<c>optimalTilingFeatures</c> (as returned by
<c>vkGetPhysicalDeviceFormatProperties</c> with the same value of
<c>format</c>) does not include
<c>VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT</c>, <c>usage</c> must
not contain <c>VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT</c>
</description></item><item><description>

If <c>flags</c> contains <c>VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT</c> or
<c>VK_IMAGE_CREATE_SPARSE_ALIASED_BIT</c>, it  must also contain
<c>VK_IMAGE_CREATE_SPARSE_BINDING_BIT</c>
</description></item><item><description>
<c>initialLayout</c> must be <c>VK_IMAGE_LAYOUT_UNDEFINED</c> or
<c>VK_IMAGE_LAYOUT_PREINITIALIZED</c>.
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>sType</c> must be <c>VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO</c>
</description></item><item><description>
<c>pNext</c> must be <c>NULL</c>
</description></item><item><description>
<c>flags</c> must be a valid combination of <see cref="T:VkImageCreateFlags" /> values
</description></item><item><description>
<c>imageType</c> must be a valid <see cref="T:VkImageType" /> value
</description></item><item><description>
<c>format</c> must be a valid <see cref="T:VkFormat" /> value
</description></item><item><description>
<c>samples</c> must be a valid <see cref="T:VkSampleCountFlags" /> value
</description></item><item><description>
<c>tiling</c> must be a valid <see cref="T:VkImageTiling" /> value
</description></item><item><description>
<c>usage</c> must be a valid combination of <see cref="T:VkImageUsageFlags" /> values
</description></item><item><description>
<c>usage</c> must not be <c>0</c>
</description></item><item><description>
<c>sharingMode</c> must be a valid <see cref="T:VkSharingMode" /> value
</description></item><item><description>
<c>initialLayout</c> must be a valid <see cref="T:VkImageLayout" /> value
</description></item></list>




The <c>VkImageCreateInfo</c> structure is defined as:


<code> typedef struct VkImageCreateInfo {
    VkStructureType          sType;
    const void*              pNext;
    VkImageCreateFlags       flags;
    VkImageType              imageType;
    VkFormat                 format;
    VkExtent3D               extent;
    uint32_t                 mipLevels;
    uint32_t                 arrayLayers;
    VkSampleCountFlagBits    samples;
    VkImageTiling            tiling;
    VkImageUsageFlags        usage;
    VkSharingMode            sharingMode;
    uint32_t                 queueFamilyIndexCount;
    const uint32_t*          pQueueFamilyIndices;
    VkImageLayout            initialLayout;
} VkImageCreateInfo; </code>

</remarks>
      <seealso cref="T:VkExtent3D" />
      <seealso cref="T:VkFormat" />
      <seealso cref="T:VkImageCreateFlags" />
      <seealso cref="T:VkImageLayout" />
      <seealso cref="T:VkImageTiling" />
      <seealso cref="T:VkImageType" />
      <seealso cref="T:VkImageUsageFlags" />
      <seealso cref="T:VkSampleCountFlags" />
      <seealso cref="T:VkSharingMode" />
      <seealso cref="T:VkStructureType" />
      <seealso cref="T:vkCreateImage" />
    </member>
    <member name="T:VkImageCreateInfo32">
      <summary>See: <see cref="T:IVkImageCreateInfo" /></summary>
      <seealso cref="T:IVkImageCreateInfo" />
    </member>
    <member name="T:VkImageCreateInfo64">
      <summary>See: <see cref="T:IVkImageCreateInfo" /></summary>
      <seealso cref="T:IVkImageCreateInfo" />
    </member>
    <member name="T:IVkMemoryAllocateInfo">
      <summary>Structure containing parameters of a memory allocation</summary>
      <remarks>


Valid Usage
<list type="bullet"><item><description>
<c>allocationSize</c> must be less than or equal to the amount of memory
available to the <c>VkMemoryHeap</c> specified by <c>memoryTypeIndex</c>
and the calling command&amp;#8217;s <c>VkDevice</c>
</description></item><item><description>
<c>allocationSize</c> must be greater than <c>0</c>
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>sType</c> must be <c>VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO</c>
</description></item><item><description>
<c>pNext</c> must be <c>NULL</c>
</description></item></list>




The <c>VkMemoryAllocateInfo</c> structure is defined as:


<code> typedef struct VkMemoryAllocateInfo {
    VkStructureType    sType;
    const void*        pNext;
    VkDeviceSize       allocationSize;
    uint32_t           memoryTypeIndex;
} VkMemoryAllocateInfo; </code>

</remarks>
      <seealso cref="T:VkStructureType" />
      <seealso cref="T:vkAllocateMemory" />
    </member>
    <member name="T:VkMemoryAllocateInfo32">
      <summary>See: <see cref="T:IVkMemoryAllocateInfo" /></summary>
      <seealso cref="T:IVkMemoryAllocateInfo" />
    </member>
    <member name="T:VkMemoryAllocateInfo64">
      <summary>See: <see cref="T:IVkMemoryAllocateInfo" /></summary>
      <seealso cref="T:IVkMemoryAllocateInfo" />
    </member>
    <member name="T:IVkDebugMarkerObjectTagInfoEXT" />
    <member name="T:VkDebugMarkerObjectTagInfoEXT32">
      <summary>See: <see cref="T:IVkDebugMarkerObjectTagInfoEXT" /></summary>
      <seealso cref="T:IVkDebugMarkerObjectTagInfoEXT" />
    </member>
    <member name="T:VkDebugMarkerObjectTagInfoEXT64">
      <summary>See: <see cref="T:IVkDebugMarkerObjectTagInfoEXT" /></summary>
      <seealso cref="T:IVkDebugMarkerObjectTagInfoEXT" />
    </member>
    <member name="T:vkGetDeviceGroupPresentCapabilitiesKHX" />
    <member name="T:IVkDeviceGeneratedCommandsLimitsNVX" />
    <member name="T:VkDeviceGeneratedCommandsLimitsNVX32">
      <summary>See: <see cref="T:IVkDeviceGeneratedCommandsLimitsNVX" /></summary>
      <seealso cref="T:IVkDeviceGeneratedCommandsLimitsNVX" />
    </member>
    <member name="T:VkDeviceGeneratedCommandsLimitsNVX64">
      <summary>See: <see cref="T:IVkDeviceGeneratedCommandsLimitsNVX" /></summary>
      <seealso cref="T:IVkDeviceGeneratedCommandsLimitsNVX" />
    </member>
    <member name="T:IVkImportMemoryFdInfoKHX" />
    <member name="T:VkImportMemoryFdInfoKHX32">
      <summary>See: <see cref="T:IVkImportMemoryFdInfoKHX" /></summary>
      <seealso cref="T:IVkImportMemoryFdInfoKHX" />
    </member>
    <member name="T:VkImportMemoryFdInfoKHX64">
      <summary>See: <see cref="T:IVkImportMemoryFdInfoKHX" /></summary>
      <seealso cref="T:IVkImportMemoryFdInfoKHX" />
    </member>
    <member name="T:vkCmdReserveSpaceForCommandsNVX" />
    <member name="T:VkClearValue">
      <summary>Structure specifying a clear value</summary>
      <remarks>

This union is used where part of the API requires either color or
depth/stencil clear values, depending on the attachment, and defines the
initial clear values in the <see cref="T:IVkRenderPassBeginInfo" /> structure.



Valid Usage
<list type="bullet"><item><description>
<c>depthStencil</c> must be a valid <c>VkClearDepthStencilValue</c>
structure
</description></item></list>




The <c>VkClearValue</c> union is defined as:


<code> typedef union VkClearValue {
    VkClearColorValue           color;
    VkClearDepthStencilValue    depthStencil;
} VkClearValue; </code>

</remarks>
      <seealso cref="T:VkClearAttachment" />
      <seealso cref="T:VkClearColorValue" />
      <seealso cref="T:VkClearDepthStencilValue" />
      <seealso cref="T:IVkRenderPassBeginInfo" />
    </member>
    <member name="T:vkCmdPushDescriptorSetKHR" />
    <member name="T:VkInstance">
      <summary>Opaque handle to a instance object</summary>
      <remarks>

There is no global state in Vulkan and all per-application state is stored
in a <c>VkInstance</c> object.
Creating a <c>VkInstance</c> object initializes the Vulkan library and allows
the application to pass information about itself to the implementation.


Instances are represented by <c>VkInstance</c> handles:


<code> VK_DEFINE_HANDLE(VkInstance) </code>

</remarks>
      <seealso cref="T:vkCreateInstance" />
      <seealso cref="T:vkDestroyInstance" />
      <seealso cref="T:vkEnumeratePhysicalDevices" />
      <seealso cref="T:vkGetInstanceProcAddr" />
    </member>
    <member name="T:VkDisplayModeParametersKHR" />
    <member name="T:VkViewportSwizzleNV" />
    <member name="T:vkFreeMemory">
      <summary>Free GPU memory</summary>
      <remarks>

Before freeing a memory object, an application  must ensure the memory
object is no longer in use by the device&amp;#8212;&amp;#8203;for example by command buffers
queued for execution.
The memory  can remain bound to images or buffers at the time the memory
object is freed, but any further use of them (on host or device) for
anything other than destroying those objects will result in undefined
behavior.
If there are still any bound images or buffers, the memory  may not be
immediately released by the implementation, but  must be released by the
time all bound images and buffers have been destroyed.
Once memory is released, it is returned to the heap from which it was
allocated.


How memory objects are bound to Images and Buffers is described in detail in
the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#resources-association">Resource Memory Association</a> section.


If a memory object is mapped at the time it is freed, it is implicitly
unmapped.

<list type="table"><tr><td><i title="Note"></i></td><td>
Note

As described <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#memory-device-unmap-does-not-flush">below</a>, host writes are
not implicitly flushed when the memory object is unmapped, but the
implementation  must guarantee that writes that have not been flushed do not
affect any other memory.

</td></tr></list>


Valid Usage
<list type="bullet"><item><description>

All submitted commands that refer to <c>memory</c> (via images or
buffers)  must have completed execution
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>device</c> must be a valid <c>VkDevice</c> handle
</description></item><item><description>
 If <c>memory</c> is not <see cref="!:VK_NULL_HANDLE" />, <c>memory</c> must be a valid <c>VkDeviceMemory</c> handle
</description></item><item><description>
 If <c>pAllocator</c> is not <c>NULL</c>, <c>pAllocator</c> must be a pointer to a valid <c>VkAllocationCallbacks</c> structure
</description></item><item><description>
 If <c>memory</c> is a valid handle, it  must have been created, allocated, or retrieved from <c>device</c>
</description></item></list>




Host Synchronization
<list type="bullet"><item><description>
Host access to <c>memory</c> must  be externally synchronized
</description></item></list>




To free a memory object, call:


<code> void vkFreeMemory(
    VkDevice                                    device,
    VkDeviceMemory                              memory,
    const VkAllocationCallbacks*                pAllocator); </code>

</remarks>
      <seealso cref="T:IVkAllocationCallbacks" />
      <seealso cref="T:VkDevice" />
      <seealso cref="T:VkDeviceMemory" />
    </member>
    <member name="T:vkCmdEndRenderPass">
      <summary>End the current render pass</summary>
      <remarks>

Ending a render pass instance performs any multisample resolve operations on
the final subpass.



Valid Usage
<list type="bullet"><item><description>

The current subpass index  must be equal to the number of subpasses in
the render pass minus one
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>commandBuffer</c> must be a valid <c>VkCommandBuffer</c> handle
</description></item><item><description>
<c>commandBuffer</c> must be in the  recording state
</description></item><item><description>
 The <c>VkCommandPool</c> that <c>commandBuffer</c> was allocated from  must support graphics operations
</description></item><item><description>
 This command  must only be called inside of a render pass instance
</description></item><item><description>
<c>commandBuffer</c> must be a primary <c>VkCommandBuffer</c>
</description></item></list>




Host Synchronization
<list type="bullet"><item><description>
Host access to <c>commandBuffer</c> must  be externally synchronized
</description></item><item><description>
Host access to the <c>VkCommandPool</c> that <c>commandBuffer</c> was allocated from  must be externally synchronized
</description></item></list>




Command Properties
<list type="table">       <listheader><tr><term> Command Buffer Levels </term><term> Render Pass Scope </term><term> Supported Queue Types </term><term> Pipeline Type </term></tr></listheader>
<item><term>
Primary
</term><term>
Inside
</term><term>
Graphics
</term><term>
Graphics
</term></item>
</list>



To record a command to end a render pass instance after recording the
commands for the last subpass, call:


<code> void vkCmdEndRenderPass(
    VkCommandBuffer                             commandBuffer); </code>

</remarks>
      <seealso cref="T:VkCommandBuffer" />
    </member>
    <member name="T:vkGetQueryPoolResults">
      <summary>Copy results of queries in a query pool to a host memory region</summary>
      <remarks>

If no bits are set in <c>flags</c>, and all requested queries are in the
available state, results are written as an array of 32-bit unsigned integer
values.
The behavior when not all queries are available, is described
<a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#queries-wait-bit-not-set">below</a>.


If <c>VK_QUERY_RESULT_64_BIT</c> is not set and the result overflows a 32-bit
value, the value  may either wrap or saturate.
Similarly, if <c>VK_QUERY_RESULT_64_BIT</c> is set and the result overflows a
64-bit value, the value  may either wrap or saturate.


If <c>VK_QUERY_RESULT_WAIT_BIT</c> is set, Vulkan will wait for each query to
be in the available state before retrieving the numerical results for that
query.
In this case, <c>vkGetQueryPoolResults</c> is guaranteed to succeed and
return <c>VK_SUCCESS</c> if the queries become available in a finite time
(i.e. if they have been issued and not reset).
If queries will never finish (e.g. due to being reset but not issued), then
<c>vkGetQueryPoolResults</c> may  not return in finite time.


If <c>VK_QUERY_RESULT_WAIT_BIT</c> and <c>VK_QUERY_RESULT_PARTIAL_BIT</c> are
both not set then no result values are written to <c>pData</c> for queries
that are in the unavailable state at the time of the call, and
<c>vkGetQueryPoolResults</c> returns <c>VK_NOT_READY</c>.
However, availability state is still written to <c>pData</c> for those
queries if <c>VK_QUERY_RESULT_WITH_AVAILABILITY_BIT</c> is set.

<list type="table"><tr><td><i title="Note"></i></td><td>
Note

Applications  must take care to ensure that use of the
<c>VK_QUERY_RESULT_WAIT_BIT</c> bit has the desired effect.


For example, if a query has been used previously and a command buffer
records the commands <c>vkCmdResetQueryPool</c>, <c>vkCmdBeginQuery</c>, and
<c>vkCmdEndQuery</c> for that query, then the query will remain in the
available state until the <c>vkCmdResetQueryPool</c> command executes on a
queue.
Applications  can use fences or events to ensure that a query has already
been reset before checking for its results or availability status.
Otherwise, a stale value could be returned from a previous use of the query.


The above also applies when <c>VK_QUERY_RESULT_WAIT_BIT</c> is used in
combination with <c>VK_QUERY_RESULT_WITH_AVAILABILITY_BIT</c>.
In this case, the returned availability status  may reflect the result of a
previous use of the query unless the <c>vkCmdResetQueryPool</c> command has
been executed since the last use of the query.

</td></tr></list>
<list type="table"><tr><td><i title="Note"></i></td><td>
Note

Applications  can double-buffer query pool usage, with a pool per frame, and
reset queries at the end of the frame in which they are read.

</td></tr></list>

If <c>VK_QUERY_RESULT_PARTIAL_BIT</c> is set, <c>VK_QUERY_RESULT_WAIT_BIT</c>
is not set, and the query&amp;#8217;s status is unavailable, an intermediate result
value between zero and the final result value is written to <c>pData</c> for
that query.


<c>VK_QUERY_RESULT_PARTIAL_BIT</c> must not be used if the pool&amp;#8217;s
<c>queryType</c> is <c>VK_QUERY_TYPE_TIMESTAMP</c>.


If <c>VK_QUERY_RESULT_WITH_AVAILABILITY_BIT</c> is set, the final integer
value written for each query is non-zero if the query&amp;#8217;s status was available
or zero if the status was unavailable.
When <c>VK_QUERY_RESULT_WITH_AVAILABILITY_BIT</c> is used, implementations
 must guarantee that if they return a non-zero availability value then the
numerical results  must be valid, assuming the results are not reset by a
subsequent command.

<list type="table"><tr><td><i title="Note"></i></td><td>
Note

Satisfying this guarantee  may require careful ordering by the application,
e.g. to read the availability status before reading the results.

</td></tr></list>


Valid Usage
<list type="bullet"><item><description>
<c>firstQuery</c> must be less than the number of queries in
<c>queryPool</c>
</description></item><item><description>

If <c>VK_QUERY_RESULT_64_BIT</c> is not set in <c>flags</c> then
<c>pData</c> and <c>stride</c> must be multiples of <c>4</c>
</description></item><item><description>

If <c>VK_QUERY_RESULT_64_BIT</c> is set in <c>flags</c> then <c>pData</c>
and <c>stride</c> must be multiples of <c>8</c>
</description></item><item><description>

The sum of <c>firstQuery</c> and <c>queryCount</c> must be less than or
equal to the number of queries in <c>queryPool</c>
</description></item><item><description>
<c>dataSize</c> must be large enough to contain the result of each
query, as described <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#queries-operation-memorylayout">here</a>
</description></item><item><description>

If the <c>queryType</c> used to create <c>queryPool</c> was
<c>VK_QUERY_TYPE_TIMESTAMP</c>, <c>flags</c> must not contain
<c>VK_QUERY_RESULT_PARTIAL_BIT</c>
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>device</c> must be a valid <c>VkDevice</c> handle
</description></item><item><description>
<c>queryPool</c> must be a valid <c>VkQueryPool</c> handle
</description></item><item><description>
<c>pData</c> must be a pointer to an array of <c>dataSize</c> bytes
</description></item><item><description>
<c>flags</c> must be a valid combination of <see cref="T:VkQueryResultFlags" /> values
</description></item><item><description>
<c>dataSize</c> must be greater than <c>0</c>
</description></item><item><description>
<c>queryPool</c> must have been created, allocated, or retrieved from <c>device</c>
</description></item></list>




Return Codes
<dl><dt>On success, this command returns</dt><dd>
<list type="bullet"><item><description>
<c>VK_SUCCESS</c>
</description></item><item><description>
<c>VK_NOT_READY</c>
</description></item></list>
</dd><dt>On failure, this command returns</dt><dd>
<list type="bullet"><item><description>
<c>VK_ERROR_OUT_OF_HOST_MEMORY</c>
</description></item><item><description>
<c>VK_ERROR_OUT_OF_DEVICE_MEMORY</c>
</description></item><item><description>
<c>VK_ERROR_DEVICE_LOST</c>
</description></item></list>
</dd></dl>




To retrieve status and results for a set of queries, call:


<code> VkResult vkGetQueryPoolResults(
    VkDevice                                    device,
    VkQueryPool                                 queryPool,
    uint32_t                                    firstQuery,
    uint32_t                                    queryCount,
    size_t                                      dataSize,
    void*                                       pData,
    VkDeviceSize                                stride,
    VkQueryResultFlags                          flags); </code>

</remarks>
      <seealso cref="T:VkDevice" />
      <seealso cref="T:VkQueryPool" />
      <seealso cref="T:VkQueryResultFlags" />
    </member>
    <member name="T:IVkCopyDescriptorSet">
      <summary>Structure specifying a copy descriptor set operation</summary>
      <remarks>


Valid Usage
<list type="bullet"><item><description>
<c>srcBinding</c> must be a valid binding within <c>srcSet</c>
</description></item><item><description>

The sum of <c>srcArrayElement</c> and <c>descriptorCount</c> must be less
than or equal to the number of array elements in the descriptor set
binding specified by <c>srcBinding</c>, and all applicable consecutive
bindings, as described by <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#descriptorsets-updates-consecutive">../../html/vkspec.html#descriptorsets-updates-consecutive</a>
</description></item><item><description>
<c>dstBinding</c> must be a valid binding within <c>dstSet</c>
</description></item><item><description>

The sum of <c>dstArrayElement</c> and <c>descriptorCount</c> must be less
than or equal to the number of array elements in the descriptor set
binding specified by <c>dstBinding</c>, and all applicable consecutive
bindings, as described by <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#descriptorsets-updates-consecutive">../../html/vkspec.html#descriptorsets-updates-consecutive</a>
</description></item><item><description>

If <c>srcSet</c> is equal to <c>dstSet</c>, then the source and
destination ranges of descriptors  must not overlap, where the ranges
 may include array elements from consecutive bindings as described by
<a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#descriptorsets-updates-consecutive">../../html/vkspec.html#descriptorsets-updates-consecutive</a>
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>sType</c> must be <c>VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET</c>
</description></item><item><description>
<c>pNext</c> must be <c>NULL</c>
</description></item><item><description>
<c>srcSet</c> must be a valid <c>VkDescriptorSet</c> handle
</description></item><item><description>
<c>dstSet</c> must be a valid <c>VkDescriptorSet</c> handle
</description></item><item><description>
 Both of <c>dstSet</c>, and <c>srcSet</c> must have been created, allocated, or retrieved from the same <c>VkDevice</c>
</description></item></list>




The <c>VkCopyDescriptorSet</c> structure is defined as:


<code> typedef struct VkCopyDescriptorSet {
    VkStructureType    sType;
    const void*        pNext;
    VkDescriptorSet    srcSet;
    uint32_t           srcBinding;
    uint32_t           srcArrayElement;
    VkDescriptorSet    dstSet;
    uint32_t           dstBinding;
    uint32_t           dstArrayElement;
    uint32_t           descriptorCount;
} VkCopyDescriptorSet; </code>

</remarks>
      <seealso cref="T:VkDescriptorSet" />
      <seealso cref="T:VkStructureType" />
      <seealso cref="T:vkUpdateDescriptorSets" />
    </member>
    <member name="T:VkCopyDescriptorSet32">
      <summary>See: <see cref="T:IVkCopyDescriptorSet" /></summary>
      <seealso cref="T:IVkCopyDescriptorSet" />
    </member>
    <member name="T:VkCopyDescriptorSet64">
      <summary>See: <see cref="T:IVkCopyDescriptorSet" /></summary>
      <seealso cref="T:IVkCopyDescriptorSet" />
    </member>
    <member name="T:VkObjectTableVertexBufferEntryNVX" />
    <member name="T:VkSubpassDependency">
      <summary>Structure specifying a subpass dependency</summary>
      <remarks>

If <c>srcSubpass</c> is equal to <c>dstSubpass</c> then the
<see cref="T:VkSubpassDependency" /> describes a
<a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-pipeline-barriers-subpass-self-dependencies">subpass
self-dependency</a>, and only constrains the pipeline barriers allowed within
a subpass instance.
Otherwise, when a render pass instance which includes a subpass dependency
is submitted to a queue, it defines a memory dependency between the
subpasses identified by <c>srcSubpass</c> and <c>dstSubpass</c>.


If <c>srcSubpass</c> is equal to <c>VK_SUBPASS_EXTERNAL</c>, the first
<a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-dependencies-scopes">synchronization scope</a> includes
commands submitted to the queue before the render pass instance began.
Otherwise, the first set of commands includes all commands submitted as part
of the subpass instance identified by <c>srcSubpass</c> and any load, store
or multisample resolve operations on attachments used in <c>srcSubpass</c>.
In either case, the first synchronization scope is limited to operations on
the pipeline stages determined by the
<a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-pipeline-stages-masks">source stage mask</a> specified by
<c>srcStageMask</c>.


If <c>dstSubpass</c> is equal to <c>VK_SUBPASS_EXTERNAL</c>, the second
<a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-dependencies-scopes">synchronization scope</a> includes
commands submitted after the render pass instance is ended.
Otherwise, the second set of commands includes all commands submitted as
part of the subpass instance identified by <c>dstSubpass</c> and any load,
store or multisample resolve operations on attachments used in
<c>dstSubpass</c>.
In either case, the second synchronization scope is limited to operations on
the pipeline stages determined by the
<a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-pipeline-stages-masks">destination stage mask</a> specified
by <c>dstStageMask</c>.


The first <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-dependencies-access-scopes">access scope</a> is
limited to access in the pipeline stages determined by the
<a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-pipeline-stages-masks">source stage mask</a> specified by
<c>srcStageMask</c>.
It is also limited to access types in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-access-masks">source access mask</a> specified by <c>srcAccessMask</c>.


The second <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-dependencies-access-scopes">access scope</a> is
limited to access in the pipeline stages determined by the
<a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-pipeline-stages-masks">destination stage mask</a> specified
by <c>dstStageMask</c>.
It is also limited to access types in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-access-masks">destination access mask</a> specified by <c>dstAccessMask</c>.


The <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-dependencies-available-and-visible">availability and
visibility operations</a> defined by a subpass dependency affect the execution
of <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#renderpass-layout-transitions">image layout transitions</a> within the
render pass.



Valid Usage
<list type="bullet"><item><description>

If <c>srcSubpass</c> is not <c>VK_SUBPASS_EXTERNAL</c>, <c>srcStageMask</c> must not include <c>VK_PIPELINE_STAGE_HOST_BIT</c>
</description></item><item><description>

If <c>dstSubpass</c> is not <c>VK_SUBPASS_EXTERNAL</c>, <c>dstStageMask</c> must not include <c>VK_PIPELINE_STAGE_HOST_BIT</c>
</description></item><item><description>

If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-geometryShader">geometry shaders</a> feature is
not enabled, <c>srcStageMask</c> must not contain
<c>VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT</c>
</description></item><item><description>

If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-geometryShader">geometry shaders</a> feature is
not enabled, <c>dstStageMask</c> must not contain
<c>VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT</c>
</description></item><item><description>

If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-tessellationShader">tessellation shaders</a>
feature is not enabled, <c>srcStageMask</c> must not contain
<c>VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT</c> or
<c>VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT</c>
</description></item><item><description>

If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-tessellationShader">tessellation shaders</a>
feature is not enabled, <c>dstStageMask</c> must not contain
<c>VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT</c> or
<c>VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT</c>
</description></item><item><description>
<c>srcSubpass</c> must be less than or equal to <c>dstSubpass</c>, unless
one of them is <c>VK_SUBPASS_EXTERNAL</c>, to avoid cyclic dependencies
and ensure a valid execution order
</description></item><item><description>
<c>srcSubpass</c> and <c>dstSubpass</c> must not both be equal to
<c>VK_SUBPASS_EXTERNAL</c>
</description></item><item><description>

If <c>srcSubpass</c> is equal to <c>dstSubpass</c>, <c>srcStageMask</c> and
<c>dstStageMask</c> must only contain one of
<c>VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT</c>,
<c>VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT</c>,
<c>VK_PIPELINE_STAGE_VERTEX_INPUT_BIT</c>,
<c>VK_PIPELINE_STAGE_VERTEX_SHADER_BIT</c>,
<c>VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT</c>,
<c>VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT</c>,
<c>VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT</c>,
<c>VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT</c>,
<c>VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT</c>,
<c>VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT</c>,
<c>VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT</c>,
<c>VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT</c>, or
<c>VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT</c>
</description></item><item><description>

If <c>srcSubpass</c> is equal to <c>dstSubpass</c> and not all of the
stages in <c>srcStageMask</c> and <c>dstStageMask</c> are
<a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-framebuffer-regions">framebuffer-space stages</a>, the
<a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-pipeline-stages-order">logically latest</a> pipeline
stage in <c>srcStageMask</c> must be
<a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-pipeline-stages-order">logically earlier</a> than or
equal to the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-pipeline-stages-order">logically
earliest</a> pipeline stage in <c>dstStageMask</c>
</description></item><item><description>

Any access flag included in <c>srcAccessMask</c> must be supported by
one of the pipeline stages in <c>srcStageMask</c>, as specified in the
<a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-access-types-supported">table of supported access
types</a>.
</description></item><item><description>

Any access flag included in <c>dstAccessMask</c> must be supported by
one of the pipeline stages in <c>dstStageMask</c>, as specified in the
<a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-access-types-supported">table of supported access
types</a>.
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>srcStageMask</c> must be a valid combination of <see cref="T:VkPipelineStageFlags" /> values
</description></item><item><description>
<c>srcStageMask</c> must not be <c>0</c>
</description></item><item><description>
<c>dstStageMask</c> must be a valid combination of <see cref="T:VkPipelineStageFlags" /> values
</description></item><item><description>
<c>dstStageMask</c> must not be <c>0</c>
</description></item><item><description>
<c>srcAccessMask</c> must be a valid combination of <see cref="T:VkAccessFlags" /> values
</description></item><item><description>
<c>dstAccessMask</c> must be a valid combination of <see cref="T:VkAccessFlags" /> values
</description></item><item><description>
<c>dependencyFlags</c> must be a valid combination of <see cref="T:VkDependencyFlags" /> values
</description></item></list>




The <c>VkSubpassDependency</c> structure is defined as:


<code> typedef struct VkSubpassDependency {
    uint32_t                srcSubpass;
    uint32_t                dstSubpass;
    VkPipelineStageFlags    srcStageMask;
    VkPipelineStageFlags    dstStageMask;
    VkAccessFlags           srcAccessMask;
    VkAccessFlags           dstAccessMask;
    VkDependencyFlags       dependencyFlags;
} VkSubpassDependency; </code>

</remarks>
      <seealso cref="T:VkAccessFlags" />
      <seealso cref="T:VkDependencyFlags" />
      <seealso cref="T:VkPipelineStageFlags" />
      <seealso cref="T:IVkRenderPassCreateInfo" />
    </member>
    <member name="T:VkPhysicalDeviceFeatures">
      <summary>Structure describing the fine-grained features that can be supported by an implementation</summary>
      <remarks>
<list type="bullet"><item><description>
<c>robustBufferAccess</c>
indicates that accesses to buffers are bounds-checked against the range
of the buffer descriptor (as determined by
<c>VkDescriptorBufferInfo</c>::<c>range</c>,
<c>VkBufferViewCreateInfo</c>::<c>range</c>, or the size of the buffer).
Out of bounds accesses  must not cause application termination, and the
effects of shader loads, stores, and atomics  must conform to an
implementation-dependent behavior as described below.
<list type="bullet"><item><description>
A buffer access is considered to be out of bounds if any of the
following are true:
<list type="bullet"><item><description>
The pointer was formed by <c>OpImageTexelPointer</c> and the coordinate
is less than zero or greater than or equal to the number of whole
elements in the bound range.
</description></item><item><description>
The pointer was not formed by <c>OpImageTexelPointer</c> and the object
pointed to is not wholly contained within the bound range.
<list type="table"><tr><td><i title="Note"></i></td><td>
Note

If a SPIR-V <c>OpLoad</c> instruction loads a structure and the tail end of
the structure is out of bounds, then all members of the structure are
considered out of bounds even if the members at the end are not statically
used.

</td></tr></list>
</description></item><item><description>
If any buffer access in a given SPIR-V block is determined to be out
of bounds, then any other access of the same type (load, store, or
atomic) in the same SPIR-V block that accesses an address less than 16
bytes away from the out of bounds address  may also be considered out
of bounds.
</description></item></list>
</description></item><item><description>
Out-of-bounds buffer loads will return any of the following values:
<list type="bullet"><item><description>
Values from anywhere within the memory range(s) bound to the buffer
(possibly including bytes of memory past the end of the buffer, up to
the end of the bound range).
</description></item><item><description>
Zero values, or  (0,0,0,x) vectors for vector reads where x is a
valid value represented in the type of the vector components and  may
be any of:
<list type="bullet"><item><description>
0, 1, or the maximum representable positive integer value, for signed
or unsigned integer components
</description></item><item><description>
0.0 or 1.0, for floating-point components
</description></item></list>
</description></item></list>
</description></item><item><description>
Out-of-bounds writes  may modify values within the memory range(s)
bound to the buffer, but  must not modify any other memory.
</description></item><item><description>
Out-of-bounds atomics  may modify values within the memory range(s)
bound to the buffer, but  must not modify any other memory, and return
an undefined value.
</description></item><item><description>
Vertex input attributes are considered out of bounds if the address of
the attribute plus the size of the attribute is greater than the size
of the bound buffer.
Further, if any vertex input attribute using a specific vertex input
binding is out of bounds, then all vertex input attributes using that
vertex input binding for that vertex shader invocation are considered
out of bounds.
<list type="bullet"><item><description>
If a vertex input attribute is out of bounds, it will be assigned one
of the following values:
<list type="bullet"><item><description>
Values from anywhere within the memory range(s) bound to the buffer,
converted according to the format of the attribute.
</description></item><item><description>
Zero values, format converted according to the format of the
attribute.
</description></item><item><description>
Zero values, or  (0,0,0,x) vectors, as described above.
</description></item></list>
</description></item></list>
</description></item><item><description>
If <c>robustBufferAccess</c> is not enabled, out of bounds accesses  may
corrupt any memory within the process and cause undefined behavior up
to and including application termination.
</description></item></list>
</description></item><item><description>
<c>fullDrawIndexUint32</c>
indicates the full 32-bit range of indices is supported for indexed draw
calls when using a <see cref="T:VkIndexType" /> of <c>VK_INDEX_TYPE_UINT32</c>.
<c>maxDrawIndexedIndexValue</c> is the maximum index value that  may be
used (aside from the primitive restart index, which is always 2<sup>32</sup>-1
when the <see cref="T:VkIndexType" /> is <c>VK_INDEX_TYPE_UINT32</c>).
If this feature is supported, <c>maxDrawIndexedIndexValue</c> must  be
2<sup>32</sup>-1; otherwise it  must be no smaller than 2<sup>24</sup>-1.
See
<a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-limits-maxDrawIndexedIndexValue">maxDrawIndexedIndexValue</a>.
</description></item><item><description>
<c>imageCubeArray</c> indicates
whether image views with a <see cref="T:VkImageViewType" /> of
<c>VK_IMAGE_VIEW_TYPE_CUBE_ARRAY</c> can be created, and that the
corresponding <c>SampledCubeArray</c> and <c>ImageCubeArray</c> SPIR-V
capabilities  can be used in shader code.
</description></item><item><description>
<c>independentBlend</c> indicates
whether the <c>VkPipelineColorBlendAttachmentState</c> settings are
controlled independently per-attachment.
If this feature is not enabled, the
<c>VkPipelineColorBlendAttachmentState</c> settings for all color
attachments  must be identical.
Otherwise, a different <c>VkPipelineColorBlendAttachmentState</c> can  be
provided for each bound color attachment.
</description></item><item><description>
<c>geometryShader</c> indicates
whether geometry shaders are supported.
If this feature is not enabled, the <c>VK_SHADER_STAGE_GEOMETRY_BIT</c>
and <c>VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT</c> enum values  must not be
used.
This also indicates whether shader modules  can declare the
<c>Geometry</c> capability.
</description></item><item><description>
<c>tessellationShader</c>
indicates whether tessellation control and evaluation shaders are
supported.
If this feature is not enabled, the
<c>VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT</c>,
<c>VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT</c>,
<c>VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT</c>,
<c>VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT</c>, and
<c>VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO</c> enum
values  must not be used.
This also indicates whether shader modules  can declare the
<c>Tessellation</c> capability.
</description></item><item><description>
<c>sampleRateShading</c>
indicates whether per-sample shading and multisample interpolation are
supported.
If this feature is not enabled, the <c>sampleShadingEnable</c> member of
the <c>VkPipelineMultisampleStateCreateInfo</c> structure  must be set to
<c>VK_FALSE</c> and the <c>minSampleShading</c> member is ignored.
This also indicates whether shader modules  can declare the
<c>SampleRateShading</c> capability.
</description></item><item><description>
<c>dualSrcBlend</c> indicates whether
blend operations which take two sources are supported.
If this feature is not enabled, the <c>VK_BLEND_FACTOR_SRC1_COLOR</c>,
<c>VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR</c>,
<c>VK_BLEND_FACTOR_SRC1_ALPHA</c>, and
<c>VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA</c> enum values  must not be used
as source or destination blending factors.
See <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#framebuffer-dsb">../../html/vkspec.html#framebuffer-dsb</a>.
</description></item><item><description>
<c>logicOp</c> indicates whether logic
operations are supported.
If this feature is not enabled, the <c>logicOpEnable</c> member of the
<c>VkPipelineColorBlendStateCreateInfo</c> structure  must be set to
<c>VK_FALSE</c>, and the <c>logicOp</c> member is ignored.
</description></item><item><description>
<c>multiDrawIndirect</c>
indicates whether multiple draw indirect is supported.
If this feature is not enabled, the <c>drawCount</c> parameter to the
<c>vkCmdDrawIndirect</c> and <c>vkCmdDrawIndexedIndirect</c> commands
 must be 0 or 1.
The <c>maxDrawIndirectCount</c> member of the
<c>VkPhysicalDeviceLimits</c> structure  must also be 1 if this feature
is not supported.
See <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-limits-maxDrawIndirectCount">maxDrawIndirectCount</a>.
</description></item><item><description>
<c>drawIndirectFirstInstance</c> indicates whether indirect draw calls
support the <c>firstInstance</c> parameter.
If this feature is not enabled, the <c>firstInstance</c> member of all
<c>VkDrawIndirectCommand</c> and <c>VkDrawIndexedIndirectCommand</c>
structures that are provided to the <c>vkCmdDrawIndirect</c> and
<c>vkCmdDrawIndexedIndirect</c> commands  must be 0.
</description></item><item><description>
<c>depthClamp</c> indicates whether
depth clamping is supported.
If this feature is not enabled, the <c>depthClampEnable</c> member of the
<c>VkPipelineRasterizationStateCreateInfo</c> structure  must be set to
<c>VK_FALSE</c>.
Otherwise, setting <c>depthClampEnable</c> to <c>VK_TRUE</c> will enable
depth clamping.
</description></item><item><description>
<c>depthBiasClamp</c> indicates
whether depth bias clamping is supported.
If this feature is not enabled, the <c>depthBiasClamp</c> member of the
<c>VkPipelineRasterizationStateCreateInfo</c> structure  must be set to
0.0 unless the <c>VK_DYNAMIC_STATE_DEPTH_BIAS</c> dynamic state is
enabled, and the <c>depthBiasClamp</c> parameter to
<c>vkCmdSetDepthBias</c> must  be set to 0.0.
</description></item><item><description>
<c>fillModeNonSolid</c> indicates
whether point and wireframe fill modes are supported.
If this feature is not enabled, the <c>VK_POLYGON_MODE_POINT</c> and
<c>VK_POLYGON_MODE_LINE</c> enum values  must not be used.
</description></item><item><description>
<c>depthBounds</c> indicates whether
depth bounds tests are supported.
If this feature is not enabled, the <c>depthBoundsTestEnable</c> member
of the <c>VkPipelineDepthStencilStateCreateInfo</c> structure  must be
set to <c>VK_FALSE</c>.
When <c>depthBoundsTestEnable</c> is set to <c>VK_FALSE</c>, the
<c>minDepthBounds</c> and <c>maxDepthBounds</c> members of the
<c>VkPipelineDepthStencilStateCreateInfo</c> structure are ignored.
</description></item><item><description>
<c>wideLines</c> indicates whether lines
with width other than 1.0 are supported.
If this feature is not enabled, the <c>lineWidth</c> member of the
<c>VkPipelineRasterizationStateCreateInfo</c> structure  must be set to
1.0 unless the <c>VK_DYNAMIC_STATE_LINE_WIDTH</c> dynamic state is
enabled, and the <c>lineWidth</c> parameter to <c>vkCmdSetLineWidth</c> must be set to 1.0.
When this feature is supported, the range and granularity of supported
line widths are indicated by the <c>lineWidthRange</c> and
<c>lineWidthGranularity</c> members of the <c>VkPhysicalDeviceLimits</c>
structure, respectively.
</description></item><item><description>
<c>largePoints</c> indicates whether
points with size greater than 1.0 are supported.
If this feature is not enabled, only a point size of 1.0 written by a
shader is supported.
The range and granularity of supported point sizes are indicated by the
<c>pointSizeRange</c> and <c>pointSizeGranularity</c> members of the
<c>VkPhysicalDeviceLimits</c> structure, respectively.
</description></item><item><description>
<c>alphaToOne</c> indicates whether the
implementation is able to replace the alpha value of the color fragment
output from the fragment shader with the maximum representable alpha
value for fixed-point colors or 1.0 for floating-point colors.
If this feature is not enabled, then the <c>alphaToOneEnable</c> member
of the <c>VkPipelineMultisampleStateCreateInfo</c> structure  must be set
to <c>VK_FALSE</c>.
Otherwise setting <c>alphaToOneEnable</c> to <c>VK_TRUE</c> will enable
alpha-to-one behavior.
</description></item><item><description>
<c>multiViewport</c> indicates
whether more than one viewport is supported.
If this feature is not enabled, the <c>viewportCount</c> and
<c>scissorCount</c> members of the
<c>VkPipelineViewportStateCreateInfo</c> structure  must be set to 1.
Similarly, the <c>viewportCount</c> parameter to the
<c>vkCmdSetViewport</c> command and the <c>scissorCount</c> parameter to
the <c>vkCmdSetScissor</c> command  must be 1, and the
<c>firstViewport</c> parameter to the <c>vkCmdSetViewport</c> command and
the <c>firstScissor</c> parameter to the <c>vkCmdSetScissor</c> command
 must be 0.
</description></item><item><description>
<c>samplerAnisotropy</c>
indicates whether anisotropic filtering is supported.
If this feature is not enabled, the <c>maxAnisotropy</c> member of the
<c>VkSamplerCreateInfo</c> structure  must be 1.0.
</description></item><item><description>
<c>textureCompressionETC2</c> indicates whether all of the ETC2 and EAC
compressed texture formats are supported.
If this feature is enabled, then the
<c>VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT</c>,
<c>VK_FORMAT_FEATURE_BLIT_SRC_BIT</c> and
<c>VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT</c> features  must
be supported in <c>optimalTilingFeatures</c> for the following formats:
<list type="bullet"><item><description>
<c>VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK</c>
</description></item><item><description>
<c>VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK</c>
</description></item><item><description>
<c>VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK</c>
</description></item><item><description>
<c>VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK</c>
</description></item><item><description>
<c>VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK</c>
</description></item><item><description>
<c>VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK</c>
</description></item><item><description>
<c>VK_FORMAT_EAC_R11_UNORM_BLOCK</c>
</description></item><item><description>
<c>VK_FORMAT_EAC_R11_SNORM_BLOCK</c>
</description></item><item><description>
<c>VK_FORMAT_EAC_R11G11_UNORM_BLOCK</c>
</description></item><item><description>
<c>VK_FORMAT_EAC_R11G11_SNORM_BLOCK</c>
</description></item></list>

<see cref="T:vkGetPhysicalDeviceFormatProperties" /> and
<see cref="T:vkGetPhysicalDeviceImageFormatProperties" /> can  be used to check for
additional supported properties of individual formats.

</description></item><item><description>
<c>textureCompressionASTC_LDR</c> indicates whether all of the ASTC LDR
compressed texture formats are supported.
If this feature is enabled, then the
<c>VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT</c>,
<c>VK_FORMAT_FEATURE_BLIT_SRC_BIT</c> and
<c>VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT</c> features  must
be supported in <c>optimalTilingFeatures</c> for the following formats:
<list type="bullet"><item><description>
<c>VK_FORMAT_ASTC_4x4_UNORM_BLOCK</c>
</description></item><item><description>
<c>VK_FORMAT_ASTC_4x4_SRGB_BLOCK</c>
</description></item><item><description>
<c>VK_FORMAT_ASTC_5x4_UNORM_BLOCK</c>
</description></item><item><description>
<c>VK_FORMAT_ASTC_5x4_SRGB_BLOCK</c>
</description></item><item><description>
<c>VK_FORMAT_ASTC_5x5_UNORM_BLOCK</c>
</description></item><item><description>
<c>VK_FORMAT_ASTC_5x5_SRGB_BLOCK</c>
</description></item><item><description>
<c>VK_FORMAT_ASTC_6x5_UNORM_BLOCK</c>
</description></item><item><description>
<c>VK_FORMAT_ASTC_6x5_SRGB_BLOCK</c>
</description></item><item><description>
<c>VK_FORMAT_ASTC_6x6_UNORM_BLOCK</c>
</description></item><item><description>
<c>VK_FORMAT_ASTC_6x6_SRGB_BLOCK</c>
</description></item><item><description>
<c>VK_FORMAT_ASTC_8x5_UNORM_BLOCK</c>
</description></item><item><description>
<c>VK_FORMAT_ASTC_8x5_SRGB_BLOCK</c>
</description></item><item><description>
<c>VK_FORMAT_ASTC_8x6_UNORM_BLOCK</c>
</description></item><item><description>
<c>VK_FORMAT_ASTC_8x6_SRGB_BLOCK</c>
</description></item><item><description>
<c>VK_FORMAT_ASTC_8x8_UNORM_BLOCK</c>
</description></item><item><description>
<c>VK_FORMAT_ASTC_8x8_SRGB_BLOCK</c>
</description></item><item><description>
<c>VK_FORMAT_ASTC_10x5_UNORM_BLOCK</c>
</description></item><item><description>
<c>VK_FORMAT_ASTC_10x5_SRGB_BLOCK</c>
</description></item><item><description>
<c>VK_FORMAT_ASTC_10x6_UNORM_BLOCK</c>
</description></item><item><description>
<c>VK_FORMAT_ASTC_10x6_SRGB_BLOCK</c>
</description></item><item><description>
<c>VK_FORMAT_ASTC_10x8_UNORM_BLOCK</c>
</description></item><item><description>
<c>VK_FORMAT_ASTC_10x8_SRGB_BLOCK</c>
</description></item><item><description>
<c>VK_FORMAT_ASTC_10x10_UNORM_BLOCK</c>
</description></item><item><description>
<c>VK_FORMAT_ASTC_10x10_SRGB_BLOCK</c>
</description></item><item><description>
<c>VK_FORMAT_ASTC_12x10_UNORM_BLOCK</c>
</description></item><item><description>
<c>VK_FORMAT_ASTC_12x10_SRGB_BLOCK</c>
</description></item><item><description>
<c>VK_FORMAT_ASTC_12x12_UNORM_BLOCK</c>
</description></item><item><description>
<c>VK_FORMAT_ASTC_12x12_SRGB_BLOCK</c>
</description></item></list>

<see cref="T:vkGetPhysicalDeviceFormatProperties" /> and
<see cref="T:vkGetPhysicalDeviceImageFormatProperties" /> can  be used to check for
additional supported properties of individual formats.

</description></item><item><description>
<c>textureCompressionBC</c>
indicates whether all of the BC compressed texture formats are
supported.
If this feature is enabled, then the
<c>VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT</c>,
<c>VK_FORMAT_FEATURE_BLIT_SRC_BIT</c> and
<c>VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT</c> features  must
be supported in <c>optimalTilingFeatures</c> for the following formats:
<list type="bullet"><item><description>
<c>VK_FORMAT_BC1_RGB_UNORM_BLOCK</c>
</description></item><item><description>
<c>VK_FORMAT_BC1_RGB_SRGB_BLOCK</c>
</description></item><item><description>
<c>VK_FORMAT_BC1_RGBA_UNORM_BLOCK</c>
</description></item><item><description>
<c>VK_FORMAT_BC1_RGBA_SRGB_BLOCK</c>
</description></item><item><description>
<c>VK_FORMAT_BC2_UNORM_BLOCK</c>
</description></item><item><description>
<c>VK_FORMAT_BC2_SRGB_BLOCK</c>
</description></item><item><description>
<c>VK_FORMAT_BC3_UNORM_BLOCK</c>
</description></item><item><description>
<c>VK_FORMAT_BC3_SRGB_BLOCK</c>
</description></item><item><description>
<c>VK_FORMAT_BC4_UNORM_BLOCK</c>
</description></item><item><description>
<c>VK_FORMAT_BC4_SNORM_BLOCK</c>
</description></item><item><description>
<c>VK_FORMAT_BC5_UNORM_BLOCK</c>
</description></item><item><description>
<c>VK_FORMAT_BC5_SNORM_BLOCK</c>
</description></item><item><description>
<c>VK_FORMAT_BC6H_UFLOAT_BLOCK</c>
</description></item><item><description>
<c>VK_FORMAT_BC6H_SFLOAT_BLOCK</c>
</description></item><item><description>
<c>VK_FORMAT_BC7_UNORM_BLOCK</c>
</description></item><item><description>
<c>VK_FORMAT_BC7_SRGB_BLOCK</c>
</description></item></list>

<see cref="T:vkGetPhysicalDeviceFormatProperties" /> and
<see cref="T:vkGetPhysicalDeviceImageFormatProperties" /> can  be used to check for
additional supported properties of individual formats.

</description></item><item><description>
<c>occlusionQueryPrecise</c>
indicates whether occlusion queries returning actual sample counts are
supported.
Occlusion queries are created in a <c>VkQueryPool</c> by specifying the
<c>queryType</c> of <c>VK_QUERY_TYPE_OCCLUSION</c> in the
<c>VkQueryPoolCreateInfo</c> structure which is passed to
<c>vkCreateQueryPool</c>.
If this feature is enabled, queries of this type  can enable
<c>VK_QUERY_CONTROL_PRECISE_BIT</c> in the <c>flags</c> parameter to
<c>vkCmdBeginQuery</c>.
If this feature is not supported, the implementation supports only
boolean occlusion queries.
When any samples are passed, boolean queries will return a non-zero
result value, otherwise a result value of zero is returned.
When this feature is enabled and <c>VK_QUERY_CONTROL_PRECISE_BIT</c> is
set, occlusion queries will report the actual number of samples passed.
</description></item><item><description>
<c>pipelineStatisticsQuery</c> indicates whether the pipeline statistics
queries are supported.
If this feature is not enabled, queries of type
<c>VK_QUERY_TYPE_PIPELINE_STATISTICS</c> cannot be created, and none of
the <see cref="T:VkQueryPipelineStatisticFlags" /> bits  can be set in the
<c>pipelineStatistics</c> member of the <c>VkQueryPoolCreateInfo</c>
structure.
</description></item><item><description>
<c>vertexPipelineStoresAndAtomics</c> indicates whether storage buffers
and images support stores and atomic operations in the vertex,
tessellation, and geometry shader stages.
If this feature is not enabled, all storage image, storage texel
buffers, and storage buffer variables used by these stages in shader
modules  must be decorated with the <c>NonWriteable</c> decoration (or the
<c>readonly</c> memory qualifier in GLSL).
</description></item><item><description>
<c>fragmentStoresAndAtomics</c> indicates whether storage buffers and
images support stores and atomic operations in the fragment shader
stage.
If this feature is not enabled, all storage image, storage texel
buffers, and storage buffer variables used by the fragment stage in
shader modules  must be decorated with the <c>NonWriteable</c> decoration
(or the <c>readonly</c> memory qualifier in GLSL).
</description></item><item><description>
<c>shaderTessellationAndGeometryPointSize</c> indicates whether the
<c>PointSize</c> built-in decoration is available in the tessellation
control, tessellation evaluation, and geometry shader stages.
If this feature is not enabled, members decorated with the
<c>PointSize</c> built-in decoration  must not be read from or written to
and all points written from a tessellation or geometry shader will have
a size of 1.0.
This also indicates whether shader modules  can declare the
<c>TessellationPointSize</c> capability for tessellation control and
evaluation shaders, or if the shader modules  can declare the
<c>GeometryPointSize</c> capability for geometry shaders.
An implementation supporting this feature  must also support one or both
of the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-tessellationShader"><c>tessellationShader</c></a>
or <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-geometryShader"><c>geometryShader</c></a> features.
</description></item><item><description>
<c>shaderImageGatherExtended</c> indicates whether the extended set of
image gather instructions are available in shader code.
If this feature is not enabled, the <c>OpImage</c>*<c>Gather</c>
instructions do not support the <c>Offset</c> and <c>ConstOffsets</c>
operands.
This also indicates whether shader modules  can declare the
<c>ImageGatherExtended</c> capability.
</description></item><item><description>
<c>shaderStorageImageExtendedFormats</c> indicates whether the extended
storage image formats are available in shader code.
If this feature is not enabled, the formats requiring the
<c>StorageImageExtendedFormats</c> capability are not supported for
storage images.
This also indicates whether shader modules  can declare the
<c>StorageImageExtendedFormats</c> capability.
</description></item><item><description>
<c>shaderStorageImageMultisample</c> indicates whether multisampled
storage images are supported.
If this feature is not enabled, images that are created with a
<c>usage</c> that includes <c>VK_IMAGE_USAGE_STORAGE_BIT</c> must be
created with <c>samples</c> equal to <c>VK_SAMPLE_COUNT_1_BIT</c>.
This also indicates whether shader modules  can declare the
<c>StorageImageMultisample</c> capability.
</description></item><item><description>
<c>shaderStorageImageReadWithoutFormat</c> indicates whether storage
images require a format qualifier to be specified when reading from
storage images.
If this feature is not enabled, the <c>OpImageRead</c> instruction  must
not have an <c>OpTypeImage</c> of <c>Unknown</c>.
This also indicates whether shader modules  can declare the
<c>StorageImageReadWithoutFormat</c> capability.
</description></item><item><description>
<c>shaderStorageImageWriteWithoutFormat</c> indicates whether storage
images require a format qualifier to be specified when writing to
storage images.
If this feature is not enabled, the <c>OpImageWrite</c> instruction  must
not have an <c>OpTypeImage</c> of <c>Unknown</c>.
This also indicates whether shader modules  can declare the
<c>StorageImageWriteWithoutFormat</c> capability.
</description></item><item><description>
<c>shaderUniformBufferArrayDynamicIndexing</c> indicates whether arrays
of uniform buffers  can be indexed by  dynamically uniform integer
expressions in shader code.
If this feature is not enabled, resources with a descriptor type of
<c>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER</c> or
<c>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC</c> must be indexed only by
constant integral expressions when aggregated into arrays in shader
code.
This also indicates whether shader modules  can declare the
<c>UniformBufferArrayDynamicIndexing</c> capability.
</description></item><item><description>
<c>shaderSampledImageArrayDynamicIndexing</c> indicates whether arrays of
samplers or sampled images  can be indexed by dynamically uniform
integer expressions in shader code.
If this feature is not enabled, resources with a descriptor type of
<c>VK_DESCRIPTOR_TYPE_SAMPLER</c>,
<c>VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER</c>, or
<c>VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE</c> must be indexed only by constant
integral expressions when aggregated into arrays in shader code.
This also indicates whether shader modules  can declare the
<c>SampledImageArrayDynamicIndexing</c> capability.
</description></item><item><description>
<c>shaderStorageBufferArrayDynamicIndexing</c> indicates whether arrays
of storage buffers  can be indexed by dynamically uniform integer
expressions in shader code.
If this feature is not enabled, resources with a descriptor type of
<c>VK_DESCRIPTOR_TYPE_STORAGE_BUFFER</c> or
<c>VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC</c> must be indexed only by
constant integral expressions when aggregated into arrays in shader
code.
This also indicates whether shader modules  can declare the
<c>StorageBufferArrayDynamicIndexing</c> capability.
</description></item><item><description>
<c>shaderStorageImageArrayDynamicIndexing</c> indicates whether arrays of
storage images  can be indexed by dynamically uniform integer
expressions in shader code.
If this feature is not enabled, resources with a descriptor type of
<c>VK_DESCRIPTOR_TYPE_STORAGE_IMAGE</c> must be indexed only by constant
integral expressions when aggregated into arrays in shader code.
This also indicates whether shader modules  can declare the
<c>StorageImageArrayDynamicIndexing</c> capability.
</description></item><item><description>
<c>shaderClipDistance</c>
indicates whether clip distances are supported in shader code.
If this feature is not enabled, any members decorated with the
<c>ClipDistance</c> built-in decoration  must not be read from or written
to in shader modules.
This also indicates whether shader modules  can declare the
<c>ClipDistance</c> capability.
</description></item><item><description>
<c>shaderCullDistance</c>
indicates whether cull distances are supported in shader code.
If this feature is not enabled, any members decorated with the
<c>CullDistance</c> built-in decoration  must not be read from or written
to in shader modules.
This also indicates whether shader modules  can declare the
<c>CullDistance</c> capability.
</description></item><item><description>
<c>shaderFloat64</c> indicates
whether 64-bit floats (doubles) are supported in shader code.
If this feature is not enabled, 64-bit floating-point types  must not be
used in shader code.
This also indicates whether shader modules  can declare the <c>Float64</c>
capability.
</description></item><item><description>
<c>shaderInt64</c> indicates whether
64-bit integers (signed and unsigned) are supported in shader code.
If this feature is not enabled, 64-bit integer types  must not be used
in shader code.
This also indicates whether shader modules  can declare the <c>Int64</c>
capability.
</description></item><item><description>
<c>shaderInt16</c> indicates whether
16-bit integers (signed and unsigned) are supported in shader code.
If this feature is not enabled, 16-bit integer types  must not be used
in shader code.
This also indicates whether shader modules  can declare the <c>Int16</c>
capability.
</description></item><item><description>
<c>shaderResourceResidency</c> indicates whether image operations that
return resource residency information are supported in shader code.
If this feature is not enabled, the <c>OpImageSparse</c>* instructions
 must not be used in shader code.
This also indicates whether shader modules  can declare the
<c>SparseResidency</c> capability.
The feature requires at least one of the <c>sparseResidency</c>* features
to be supported.
</description></item><item><description>
<c>shaderResourceMinLod</c>
indicates whether image operations that specify the minimum resource
level-of-detail (LOD) are supported in shader code.
If this feature is not enabled, the <c>MinLod</c> image operand  must not
be used in shader code.
This also indicates whether shader modules  can declare the <c>MinLod</c>
capability.
</description></item><item><description>
<c>sparseBinding</c> indicates
whether resource memory  can be managed at opaque sparse block level
instead of at the object level.
If this feature is not enabled, resource memory  must be bound only on a
per-object basis using the <c>vkBindBufferMemory</c> and
<c>vkBindImageMemory</c> commands.
In this case, buffers and images  must not be created with
<c>VK_BUFFER_CREATE_SPARSE_BINDING_BIT</c> and
<c>VK_IMAGE_CREATE_SPARSE_BINDING_BIT</c> set in the <c>flags</c> member
of the <c>VkBufferCreateInfo</c> and <c>VkImageCreateInfo</c> structures,
respectively.
Otherwise resource memory  can be managed as described in
<a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#sparsememory-sparseresourcefeatures">Sparse Resource Features</a>.
</description></item><item><description>
<c>sparseResidencyBuffer</c>
indicates whether the device  can access partially resident buffers.
If this feature is not enabled, buffers  must not be created with
<c>VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT</c> set in the <c>flags</c>
member of the <c>VkBufferCreateInfo</c> structure.
</description></item><item><description>
<c>sparseResidencyImage2D</c> indicates whether the device  can access
partially resident 2D images with 1 sample per pixel.
If this feature is not enabled, images with an <c>imageType</c> of
<c>VK_IMAGE_TYPE_2D</c> and <c>samples</c> set to
<c>VK_SAMPLE_COUNT_1_BIT</c> must not be created with
<c>VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT</c> set in the <c>flags</c> member
of the <c>VkImageCreateInfo</c> structure.
</description></item><item><description>
<c>sparseResidencyImage3D</c> indicates whether the device  can access
partially resident 3D images.
If this feature is not enabled, images with an <c>imageType</c> of
<c>VK_IMAGE_TYPE_3D</c> must not be created with
<c>VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT</c> set in the <c>flags</c> member
of the <c>VkImageCreateInfo</c> structure.
</description></item><item><description>
<c>sparseResidency2Samples</c> indicates whether the physical device  can
access partially resident 2D images with 2 samples per pixel.
If this feature is not enabled, images with an <c>imageType</c> of
<c>VK_IMAGE_TYPE_2D</c> and <c>samples</c> set to
<c>VK_SAMPLE_COUNT_2_BIT</c> must not be created with
<c>VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT</c> set in the <c>flags</c> member
of the <c>VkImageCreateInfo</c> structure.
</description></item><item><description>
<c>sparseResidency4Samples</c> indicates whether the physical device  can
access partially resident 2D images with 4 samples per pixel.
If this feature is not enabled, images with an <c>imageType</c> of
<c>VK_IMAGE_TYPE_2D</c> and <c>samples</c> set to
<c>VK_SAMPLE_COUNT_4_BIT</c> must not be created with
<c>VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT</c> set in the <c>flags</c> member
of the <c>VkImageCreateInfo</c> structure.
</description></item><item><description>
<c>sparseResidency8Samples</c> indicates whether the physical device  can
access partially resident 2D images with 8 samples per pixel.
If this feature is not enabled, images with an <c>imageType</c> of
<c>VK_IMAGE_TYPE_2D</c> and <c>samples</c> set to
<c>VK_SAMPLE_COUNT_8_BIT</c> must not be created with
<c>VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT</c> set in the <c>flags</c> member
of the <c>VkImageCreateInfo</c> structure.
</description></item><item><description>
<c>sparseResidency16Samples</c> indicates whether the physical device
 can access partially resident 2D images with 16 samples per pixel.
If this feature is not enabled, images with an <c>imageType</c> of
<c>VK_IMAGE_TYPE_2D</c> and <c>samples</c> set to
<c>VK_SAMPLE_COUNT_16_BIT</c> must not be created with
<c>VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT</c> set in the <c>flags</c> member
of the <c>VkImageCreateInfo</c> structure.
</description></item><item><description>
<c>sparseResidencyAliased</c> indicates whether the physical device  can
correctly access data aliased into multiple locations.
If this feature is not enabled, the
<c>VK_BUFFER_CREATE_SPARSE_ALIASED_BIT</c> and
<c>VK_IMAGE_CREATE_SPARSE_ALIASED_BIT</c> enum values  must not be used
in <c>flags</c> members of the <c>VkBufferCreateInfo</c> and
<c>VkImageCreateInfo</c> structures, respectively.
</description></item><item><description>
<c>variableMultisampleRate</c> indicates whether all pipelines that will
be bound to a command buffer during a subpass with no attachments  must
have the same value for
<c>VkPipelineMultisampleStateCreateInfo</c>::<c>rasterizationSamples</c>.
If set to <c>VK_TRUE</c>, the implementation supports variable
multisample rates in a subpass with no attachments.
If set to <c>VK_FALSE</c>, then all pipelines bound in such a subpass
 must have the same multisample rate.
This has no effect in situations where a subpass uses any attachments.
</description></item><item><description>
<c>inheritedQueries</c> indicates
whether a secondary command buffer  may be executed while a query is
active.
</description></item></list>


The <c>VkPhysicalDeviceFeatures</c> structure is defined as:


<code> typedef struct VkPhysicalDeviceFeatures {
    VkBool32    robustBufferAccess;
    VkBool32    fullDrawIndexUint32;
    VkBool32    imageCubeArray;
    VkBool32    independentBlend;
    VkBool32    geometryShader;
    VkBool32    tessellationShader;
    VkBool32    sampleRateShading;
    VkBool32    dualSrcBlend;
    VkBool32    logicOp;
    VkBool32    multiDrawIndirect;
    VkBool32    drawIndirectFirstInstance;
    VkBool32    depthClamp;
    VkBool32    depthBiasClamp;
    VkBool32    fillModeNonSolid;
    VkBool32    depthBounds;
    VkBool32    wideLines;
    VkBool32    largePoints;
    VkBool32    alphaToOne;
    VkBool32    multiViewport;
    VkBool32    samplerAnisotropy;
    VkBool32    textureCompressionETC2;
    VkBool32    textureCompressionASTC_LDR;
    VkBool32    textureCompressionBC;
    VkBool32    occlusionQueryPrecise;
    VkBool32    pipelineStatisticsQuery;
    VkBool32    vertexPipelineStoresAndAtomics;
    VkBool32    fragmentStoresAndAtomics;
    VkBool32    shaderTessellationAndGeometryPointSize;
    VkBool32    shaderImageGatherExtended;
    VkBool32    shaderStorageImageExtendedFormats;
    VkBool32    shaderStorageImageMultisample;
    VkBool32    shaderStorageImageReadWithoutFormat;
    VkBool32    shaderStorageImageWriteWithoutFormat;
    VkBool32    shaderUniformBufferArrayDynamicIndexing;
    VkBool32    shaderSampledImageArrayDynamicIndexing;
    VkBool32    shaderStorageBufferArrayDynamicIndexing;
    VkBool32    shaderStorageImageArrayDynamicIndexing;
    VkBool32    shaderClipDistance;
    VkBool32    shaderCullDistance;
    VkBool32    shaderFloat64;
    VkBool32    shaderInt64;
    VkBool32    shaderInt16;
    VkBool32    shaderResourceResidency;
    VkBool32    shaderResourceMinLod;
    VkBool32    sparseBinding;
    VkBool32    sparseResidencyBuffer;
    VkBool32    sparseResidencyImage2D;
    VkBool32    sparseResidencyImage3D;
    VkBool32    sparseResidency2Samples;
    VkBool32    sparseResidency4Samples;
    VkBool32    sparseResidency8Samples;
    VkBool32    sparseResidency16Samples;
    VkBool32    sparseResidencyAliased;
    VkBool32    variableMultisampleRate;
    VkBool32    inheritedQueries;
} VkPhysicalDeviceFeatures; </code>

</remarks>
      <seealso cref="T:IVkDeviceCreateInfo" />
      <seealso cref="T:vkGetPhysicalDeviceFeatures" />
    </member>
    <member name="T:IVkApplicationInfo">
      <summary>Structure specifying application info</summary>
      <remarks>


Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>sType</c> must be <c>VK_STRUCTURE_TYPE_APPLICATION_INFO</c>
</description></item><item><description>
<c>pNext</c> must be <c>NULL</c>
</description></item><item><description>
 If <c>pApplicationName</c> is not <c>NULL</c>, <c>pApplicationName</c> must  be a null-terminated UTF-8 string
</description></item><item><description>
 If <c>pEngineName</c> is not <c>NULL</c>, <c>pEngineName</c> must  be a null-terminated UTF-8 string
</description></item></list>




The <c>VkApplicationInfo</c> structure is defined as:


<code> typedef struct VkApplicationInfo {
    VkStructureType    sType;
    const void*        pNext;
    const char*        pApplicationName;
    uint32_t           applicationVersion;
    const char*        pEngineName;
    uint32_t           engineVersion;
    uint32_t           apiVersion;
} VkApplicationInfo; </code>

</remarks>
      <seealso cref="T:IVkInstanceCreateInfo" />
      <seealso cref="T:VkStructureType" />
    </member>
    <member name="T:VkApplicationInfo32">
      <summary>See: <see cref="T:IVkApplicationInfo" /></summary>
      <seealso cref="T:IVkApplicationInfo" />
    </member>
    <member name="T:VkApplicationInfo64">
      <summary>See: <see cref="T:IVkApplicationInfo" /></summary>
      <seealso cref="T:IVkApplicationInfo" />
    </member>
    <member name="T:IVkSparseImageFormatProperties2KHR" />
    <member name="T:VkSparseImageFormatProperties2KHR32">
      <summary>See: <see cref="T:IVkSparseImageFormatProperties2KHR" /></summary>
      <seealso cref="T:IVkSparseImageFormatProperties2KHR" />
    </member>
    <member name="T:VkSparseImageFormatProperties2KHR64">
      <summary>See: <see cref="T:IVkSparseImageFormatProperties2KHR" /></summary>
      <seealso cref="T:IVkSparseImageFormatProperties2KHR" />
    </member>
    <member name="T:IVkCommandBufferInheritanceInfo">
      <summary>Structure specifying command buffer inheritance info</summary>
      <remarks>


Valid Usage
<list type="bullet"><item><description>

If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-inheritedQueries">inherited queries</a> feature
is not enabled, <c>occlusionQueryEnable</c> must be <c>VK_FALSE</c>
</description></item><item><description>

If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-inheritedQueries">inherited queries</a> feature
is enabled, <c>queryFlags</c> must be a valid combination of
<see cref="T:VkQueryControlFlags" /> values
</description></item><item><description>

If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-pipelineStatisticsQuery">pipeline statistics
queries</a> feature is not enabled, <c>pipelineStatistics</c> must be
<c>0</c>
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>sType</c> must be <c>VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO</c>
</description></item><item><description>
<c>pNext</c> must be <c>NULL</c>
</description></item><item><description>
 Both of <c>framebuffer</c>, and <c>renderPass</c> that are valid handles  must have been created, allocated, or retrieved from the same <c>VkDevice</c>
</description></item></list>




If the command buffer is a secondary command buffer, then the
<c>VkCommandBufferInheritanceInfo</c> structure defines any state that will
be inherited from the primary command buffer:


<code> typedef struct VkCommandBufferInheritanceInfo {
    VkStructureType                  sType;
    const void*                      pNext;
    VkRenderPass                     renderPass;
    uint32_t                         subpass;
    VkFramebuffer                    framebuffer;
    VkBool32                         occlusionQueryEnable;
    VkQueryControlFlags              queryFlags;
    VkQueryPipelineStatisticFlags    pipelineStatistics;
} VkCommandBufferInheritanceInfo; </code>

</remarks>
      <seealso cref="T:IVkCommandBufferBeginInfo" />
      <seealso cref="T:VkFramebuffer" />
      <seealso cref="T:VkQueryControlFlags" />
      <seealso cref="T:VkQueryPipelineStatisticFlags" />
      <seealso cref="T:VkRenderPass" />
      <seealso cref="T:VkStructureType" />
    </member>
    <member name="T:VkCommandBufferInheritanceInfo32">
      <summary>See: <see cref="T:IVkCommandBufferInheritanceInfo" /></summary>
      <seealso cref="T:IVkCommandBufferInheritanceInfo" />
    </member>
    <member name="T:VkCommandBufferInheritanceInfo64">
      <summary>See: <see cref="T:IVkCommandBufferInheritanceInfo" /></summary>
      <seealso cref="T:IVkCommandBufferInheritanceInfo" />
    </member>
    <member name="T:IVkQueueFamilyProperties2KHR" />
    <member name="T:VkQueueFamilyProperties2KHR32">
      <summary>See: <see cref="T:IVkQueueFamilyProperties2KHR" /></summary>
      <seealso cref="T:IVkQueueFamilyProperties2KHR" />
    </member>
    <member name="T:VkQueueFamilyProperties2KHR64">
      <summary>See: <see cref="T:IVkQueueFamilyProperties2KHR" /></summary>
      <seealso cref="T:IVkQueueFamilyProperties2KHR" />
    </member>
    <member name="T:IVkDeviceGroupPresentInfoKHX" />
    <member name="T:VkDeviceGroupPresentInfoKHX32">
      <summary>See: <see cref="T:IVkDeviceGroupPresentInfoKHX" /></summary>
      <seealso cref="T:IVkDeviceGroupPresentInfoKHX" />
    </member>
    <member name="T:VkDeviceGroupPresentInfoKHX64">
      <summary>See: <see cref="T:IVkDeviceGroupPresentInfoKHX" /></summary>
      <seealso cref="T:IVkDeviceGroupPresentInfoKHX" />
    </member>
    <member name="T:IVkDedicatedAllocationMemoryAllocateInfoNV" />
    <member name="T:VkDedicatedAllocationMemoryAllocateInfoNV32">
      <summary>See: <see cref="T:IVkDedicatedAllocationMemoryAllocateInfoNV" /></summary>
      <seealso cref="T:IVkDedicatedAllocationMemoryAllocateInfoNV" />
    </member>
    <member name="T:VkDedicatedAllocationMemoryAllocateInfoNV64">
      <summary>See: <see cref="T:IVkDedicatedAllocationMemoryAllocateInfoNV" /></summary>
      <seealso cref="T:IVkDedicatedAllocationMemoryAllocateInfoNV" />
    </member>
    <member name="T:VkVertexInputAttributeDescription">
      <summary>Structure specifying vertex input attribute description</summary>
      <remarks>


Valid Usage
<list type="bullet"><item><description>
<c>location</c> must be less than
<c>VkPhysicalDeviceLimits</c>::<c>maxVertexInputAttributes</c>
</description></item><item><description>
<c>binding</c> must be less than
<c>VkPhysicalDeviceLimits</c>::<c>maxVertexInputBindings</c>
</description></item><item><description>
<c>offset</c> must be less than or equal to
<c>VkPhysicalDeviceLimits</c>::<c>maxVertexInputAttributeOffset</c>
</description></item><item><description>
<c>format</c> must be allowed as a vertex buffer format, as specified by
the <c>VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT</c> flag in
<c>VkFormatProperties</c>::<c>bufferFeatures</c> returned by
<c>vkGetPhysicalDeviceFormatProperties</c>
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>format</c> must be a valid <see cref="T:VkFormat" /> value
</description></item></list>




Each vertex input attribute is specified by an instance of the
<c>VkVertexInputAttributeDescription</c> structure.


The <c>VkVertexInputAttributeDescription</c> structure is defined as:


<code> typedef struct VkVertexInputAttributeDescription {
    uint32_t    location;
    uint32_t    binding;
    VkFormat    format;
    uint32_t    offset;
} VkVertexInputAttributeDescription; </code>

</remarks>
      <seealso cref="T:VkFormat" />
      <seealso cref="T:IVkPipelineVertexInputStateCreateInfo" />
    </member>
    <member name="T:VkClearAttachment">
      <summary>Structure specifying a clear attachment</summary>
      <remarks>

No memory barriers are needed between <c>vkCmdClearAttachments</c> and
preceding or subsequent draw or attachment clear commands in the same
subpass.


The <c>vkCmdClearAttachments</c> command is not affected by the bound
pipeline state.


Attachments  can also be cleared at the beginning of a render pass instance
by setting <c>loadOp</c> (or <c>stencilLoadOp</c>) of
<see cref="T:VkAttachmentDescription" /> to <c>VK_ATTACHMENT_LOAD_OP_CLEAR</c>, as
described for <see cref="T:vkCreateRenderPass" />.



Valid Usage
<list type="bullet"><item><description>

If <c>aspectMask</c> includes <c>VK_IMAGE_ASPECT_COLOR_BIT</c>, it  must
not include <c>VK_IMAGE_ASPECT_DEPTH_BIT</c> or
<c>VK_IMAGE_ASPECT_STENCIL_BIT</c>
</description></item><item><description>
<c>aspectMask</c> must not include <c>VK_IMAGE_ASPECT_METADATA_BIT</c>
</description></item><item><description>
<c>clearValue</c> must be a valid <c>VkClearValue</c> union
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>aspectMask</c> must be a valid combination of <see cref="T:VkImageAspectFlags" /> values
</description></item><item><description>
<c>aspectMask</c> must not be <c>0</c>
</description></item></list>




The <c>VkClearAttachment</c> structure is defined as:


<code> typedef struct VkClearAttachment {
    VkImageAspectFlags    aspectMask;
    uint32_t              colorAttachment;
    VkClearValue          clearValue;
} VkClearAttachment; </code>

</remarks>
      <seealso cref="T:VkClearValue" />
      <seealso cref="T:VkImageAspectFlags" />
      <seealso cref="T:vkCmdClearAttachments" />
    </member>
    <member name="T:IVkDisplayModeCreateInfoKHR" />
    <member name="T:VkDisplayModeCreateInfoKHR32">
      <summary>See: <see cref="T:IVkDisplayModeCreateInfoKHR" /></summary>
      <seealso cref="T:IVkDisplayModeCreateInfoKHR" />
    </member>
    <member name="T:VkDisplayModeCreateInfoKHR64">
      <summary>See: <see cref="T:IVkDisplayModeCreateInfoKHR" /></summary>
      <seealso cref="T:IVkDisplayModeCreateInfoKHR" />
    </member>
    <member name="T:VkFormatProperties">
      <summary>Structure specifying image format properties</summary>
      <remarks>
<list type="table"><tr><td><i title="Note"></i></td><td>
Note

If no format feature flags are supported, then the only possible use would
be image transfers - which alone are not useful.
As such, if no format feature flags are supported, the format itself is not
supported, and images of that format cannot be created.

</td></tr></list>

If <c>format</c> is a block-compression format, then buffers  must not
support any features for the format.



The <c>VkFormatProperties</c> structure is defined as:


<code> typedef struct VkFormatProperties {
    VkFormatFeatureFlags    linearTilingFeatures;
    VkFormatFeatureFlags    optimalTilingFeatures;
    VkFormatFeatureFlags    bufferFeatures;
} VkFormatProperties; </code>

</remarks>
      <seealso cref="T:VkFormatFeatureFlags" />
      <seealso cref="T:vkGetPhysicalDeviceFormatProperties" />
    </member>
    <member name="T:VkLayerProperties">
      <summary>Structure specifying layer properties</summary>
      <remarks>

The <c>VkLayerProperties</c> structure is defined as:


<code> typedef struct VkLayerProperties {
    char        layerName[VK_MAX_EXTENSION_NAME_SIZE];
    uint32_t    specVersion;
    uint32_t    implementationVersion;
    char        description[VK_MAX_DESCRIPTION_SIZE];
} VkLayerProperties; </code>

</remarks>
      <seealso cref="T:vkEnumerateDeviceLayerProperties" />
      <seealso cref="T:vkEnumerateInstanceLayerProperties" />
    </member>
    <member name="T:IVkDescriptorSetAllocateInfo">
      <summary>Structure specifying the allocation parameters for descriptor sets</summary>
      <remarks>


Valid Usage
<list type="bullet"><item><description>
<c>descriptorSetCount</c> must not be greater than the number of sets
that are currently available for allocation in <c>descriptorPool</c>
</description></item><item><description>
<c>descriptorPool</c> must  have enough free descriptor capacity
remaining to allocate the descriptor sets of the specified layouts
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>sType</c> must be <c>VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO</c>
</description></item><item><description>
<c>pNext</c> must be <c>NULL</c>
</description></item><item><description>
<c>descriptorPool</c> must be a valid <c>VkDescriptorPool</c> handle
</description></item><item><description>
<c>pSetLayouts</c> must be a pointer to an array of <c>descriptorSetCount</c> valid <c>VkDescriptorSetLayout</c> handles
</description></item><item><description>
<c>descriptorSetCount</c> must be greater than <c>0</c>
</description></item><item><description>
 Both of <c>descriptorPool</c>, and the elements of <c>pSetLayouts</c> must have been created, allocated, or retrieved from the same <c>VkDevice</c>
</description></item></list>




The <c>VkDescriptorSetAllocateInfo</c> structure is defined as:


<code> typedef struct VkDescriptorSetAllocateInfo {
    VkStructureType                 sType;
    const void*                     pNext;
    VkDescriptorPool                descriptorPool;
    uint32_t                        descriptorSetCount;
    const VkDescriptorSetLayout*    pSetLayouts;
} VkDescriptorSetAllocateInfo; </code>

</remarks>
      <seealso cref="T:VkDescriptorPool" />
      <seealso cref="T:VkDescriptorSetLayout" />
      <seealso cref="T:VkStructureType" />
      <seealso cref="T:vkAllocateDescriptorSets" />
    </member>
    <member name="T:VkDescriptorSetAllocateInfo32">
      <summary>See: <see cref="T:IVkDescriptorSetAllocateInfo" /></summary>
      <seealso cref="T:IVkDescriptorSetAllocateInfo" />
    </member>
    <member name="T:VkDescriptorSetAllocateInfo64">
      <summary>See: <see cref="T:IVkDescriptorSetAllocateInfo" /></summary>
      <seealso cref="T:IVkDescriptorSetAllocateInfo" />
    </member>
    <member name="T:IVkBindImageMemoryInfoKHX" />
    <member name="T:VkBindImageMemoryInfoKHX32">
      <summary>See: <see cref="T:IVkBindImageMemoryInfoKHX" /></summary>
      <seealso cref="T:IVkBindImageMemoryInfoKHX" />
    </member>
    <member name="T:VkBindImageMemoryInfoKHX64">
      <summary>See: <see cref="T:IVkBindImageMemoryInfoKHX" /></summary>
      <seealso cref="T:IVkBindImageMemoryInfoKHX" />
    </member>
    <member name="T:IVkDisplaySurfaceCreateInfoKHR" />
    <member name="T:VkDisplaySurfaceCreateInfoKHR32">
      <summary>See: <see cref="T:IVkDisplaySurfaceCreateInfoKHR" /></summary>
      <seealso cref="T:IVkDisplaySurfaceCreateInfoKHR" />
    </member>
    <member name="T:VkDisplaySurfaceCreateInfoKHR64">
      <summary>See: <see cref="T:IVkDisplaySurfaceCreateInfoKHR" /></summary>
      <seealso cref="T:IVkDisplaySurfaceCreateInfoKHR" />
    </member>
    <member name="T:IVkPipelineViewportStateCreateInfo">
      <summary>Structure specifying parameters of a newly created pipeline viewport state</summary>
      <remarks>


Valid Usage
<list type="bullet"><item><description>

If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-multiViewport">multiple viewports</a> feature is
not enabled, <c>viewportCount</c> must be <c>1</c>
</description></item><item><description>

If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-multiViewport">multiple viewports</a> feature is
not enabled, <c>scissorCount</c> must be <c>1</c>
</description></item><item><description>
<c>viewportCount</c> must be between <c>1</c> and
<c>VkPhysicalDeviceLimits</c>::<c>maxViewports</c>, inclusive
</description></item><item><description>
<c>scissorCount</c> must be between <c>1</c> and
<c>VkPhysicalDeviceLimits</c>::<c>maxViewports</c>, inclusive
</description></item><item><description>
<c>scissorCount</c> and <c>viewportCount</c> must  be identical
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>sType</c> must be <c>VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO</c>
</description></item><item><description>
<c>pNext</c> must be <c>NULL</c>
</description></item><item><description>
<c>flags</c> must be <c>0</c>
</description></item><item><description>
<c>viewportCount</c> must be greater than <c>0</c>
</description></item><item><description>
<c>scissorCount</c> must be greater than <c>0</c>
</description></item></list>




The <c>VkPipelineViewportStateCreateInfo</c> structure is defined as:


<code> typedef struct VkPipelineViewportStateCreateInfo {
    VkStructureType                       sType;
    const void*                           pNext;
    VkPipelineViewportStateCreateFlags    flags;
    uint32_t                              viewportCount;
    const VkViewport*                     pViewports;
    uint32_t                              scissorCount;
    const VkRect2D*                       pScissors;
} VkPipelineViewportStateCreateInfo; </code>

</remarks>
      <seealso cref="T:IVkGraphicsPipelineCreateInfo" />
      <seealso cref="T:VkPipelineViewportStateCreateFlags" />
      <seealso cref="T:VkRect2D" />
      <seealso cref="T:VkStructureType" />
      <seealso cref="T:VkViewport" />
    </member>
    <member name="T:VkPipelineViewportStateCreateInfo32">
      <summary>See: <see cref="T:IVkPipelineViewportStateCreateInfo" /></summary>
      <seealso cref="T:IVkPipelineViewportStateCreateInfo" />
    </member>
    <member name="T:VkPipelineViewportStateCreateInfo64">
      <summary>See: <see cref="T:IVkPipelineViewportStateCreateInfo" /></summary>
      <seealso cref="T:IVkPipelineViewportStateCreateInfo" />
    </member>
    <member name="T:IVkSubmitInfo">
      <summary>Structure specifying a queue submit operation</summary>
      <remarks>

The order that command buffers appear in <c>pCommandBuffers</c> is used to
determine <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-submission-order">submission order</a>, and thus
all the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-implicit">implicit ordering guarantees</a> that
respect it.
Other than these implicit ordering guarantees and any <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization">explicit synchronization primitives</a>, these command buffers  may overlap or
otherwise execute out of order.



Valid Usage
<list type="bullet"><item><description>

Any given element of <c>pCommandBuffers</c> must not have been allocated
with <c>VK_COMMAND_BUFFER_LEVEL_SECONDARY</c>
</description></item><item><description>

If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-geometryShader">geometry shaders</a> feature is
not enabled, any given element of <c>pWaitDstStageMask</c> must not
contain <c>VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT</c>
</description></item><item><description>

If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-tessellationShader">tessellation shaders</a>
feature is not enabled, any given element of <c>pWaitDstStageMask</c> must not contain
<c>VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT</c> or
<c>VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT</c>
</description></item><item><description>

Any given element of <c>pWaitDstStageMask</c> must not include
<c>VK_PIPELINE_STAGE_HOST_BIT</c>.
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>sType</c> must be <c>VK_STRUCTURE_TYPE_SUBMIT_INFO</c>
</description></item><item><description>
<c>pNext</c> must be <c>NULL</c>
</description></item><item><description>
 If <c>waitSemaphoreCount</c> is not <c>0</c>, <c>pWaitSemaphores</c> must be a pointer to an array of <c>waitSemaphoreCount</c> valid <c>VkSemaphore</c> handles
</description></item><item><description>
 If <c>waitSemaphoreCount</c> is not <c>0</c>, <c>pWaitDstStageMask</c> must be a pointer to an array of <c>waitSemaphoreCount</c> valid combinations of <see cref="T:VkPipelineStageFlags" /> values
</description></item><item><description>
 Each element of <c>pWaitDstStageMask</c> must not be <c>0</c>
</description></item><item><description>
 If <c>commandBufferCount</c> is not <c>0</c>, <c>pCommandBuffers</c> must be a pointer to an array of <c>commandBufferCount</c> valid <c>VkCommandBuffer</c> handles
</description></item><item><description>
 If <c>signalSemaphoreCount</c> is not <c>0</c>, <c>pSignalSemaphores</c> must be a pointer to an array of <c>signalSemaphoreCount</c> valid <c>VkSemaphore</c> handles
</description></item><item><description>
 Each of the elements of <c>pCommandBuffers</c>, the elements of <c>pSignalSemaphores</c>, and the elements of <c>pWaitSemaphores</c> that are valid handles  must have been created, allocated, or retrieved from the same <c>VkDevice</c>
</description></item></list>




The <c>VkSubmitInfo</c> structure is defined as:


<code> typedef struct VkSubmitInfo {
    VkStructureType                sType;
    const void*                    pNext;
    uint32_t                       waitSemaphoreCount;
    const VkSemaphore*             pWaitSemaphores;
    const VkPipelineStageFlags*    pWaitDstStageMask;
    uint32_t                       commandBufferCount;
    const VkCommandBuffer*         pCommandBuffers;
    uint32_t                       signalSemaphoreCount;
    const VkSemaphore*             pSignalSemaphores;
} VkSubmitInfo; </code>

</remarks>
      <seealso cref="T:VkCommandBuffer" />
      <seealso cref="T:VkPipelineStageFlags" />
      <seealso cref="T:VkSemaphore" />
      <seealso cref="T:VkStructureType" />
      <seealso cref="T:vkQueueSubmit" />
    </member>
    <member name="T:VkSubmitInfo32">
      <summary>See: <see cref="T:IVkSubmitInfo" /></summary>
      <seealso cref="T:IVkSubmitInfo" />
    </member>
    <member name="T:VkSubmitInfo64">
      <summary>See: <see cref="T:IVkSubmitInfo" /></summary>
      <seealso cref="T:IVkSubmitInfo" />
    </member>
    <member name="T:vkCmdClearDepthStencilImage">
      <summary>Fill regions of a combined depth/stencil image</summary>
      <remarks>


Valid Usage
<list type="bullet"><item><description>
<c>image</c> must have been created with
<c>VK_IMAGE_USAGE_TRANSFER_DST_BIT</c> usage flag
</description></item><item><description>

If <c>image</c> is non-sparse then it  must be bound completely and
contiguously to a single <c>VkDeviceMemory</c> object
</description></item><item><description>
<c>imageLayout</c> must specify the layout of the image subresource
ranges of <c>image</c> specified in <c>pRanges</c> at the time this
command is executed on a <c>VkDevice</c>
</description></item><item><description>
<c>imageLayout</c> must be either of
<c>VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL</c> or
<c>VK_IMAGE_LAYOUT_GENERAL</c>
</description></item><item><description>

The image range of any given element of <c>pRanges</c> must be an image
subresource range that is contained within <c>image</c>
</description></item><item><description>
<c>image</c> must  have a depth/stencil format
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>commandBuffer</c> must be a valid <c>VkCommandBuffer</c> handle
</description></item><item><description>
<c>image</c> must be a valid <c>VkImage</c> handle
</description></item><item><description>
<c>imageLayout</c> must be a valid <see cref="T:VkImageLayout" /> value
</description></item><item><description>
<c>pDepthStencil</c> must be a pointer to a valid <c>VkClearDepthStencilValue</c> structure
</description></item><item><description>
<c>pRanges</c> must be a pointer to an array of <c>rangeCount</c> valid <c>VkImageSubresourceRange</c> structures
</description></item><item><description>
<c>commandBuffer</c> must be in the  recording state
</description></item><item><description>
 The <c>VkCommandPool</c> that <c>commandBuffer</c> was allocated from  must support graphics operations
</description></item><item><description>
 This command  must only be called outside of a render pass instance
</description></item><item><description>
<c>rangeCount</c> must be greater than <c>0</c>
</description></item><item><description>
 Both of <c>commandBuffer</c>, and <c>image</c> must have been created, allocated, or retrieved from the same <c>VkDevice</c>
</description></item></list>




Host Synchronization
<list type="bullet"><item><description>
Host access to <c>commandBuffer</c> must  be externally synchronized
</description></item><item><description>
Host access to the <c>VkCommandPool</c> that <c>commandBuffer</c> was allocated from  must be externally synchronized
</description></item></list>




Command Properties
<list type="table">       <listheader><tr><term> Command Buffer Levels </term><term> Render Pass Scope </term><term> Supported Queue Types </term><term> Pipeline Type </term></tr></listheader>
<item><term>
Primary<br />
Secondary
</term><term>
Outside
</term><term>
Graphics
</term><term>
Transfer
</term></item>
</list>



To clear one or more subranges of a depth/stencil image, call:


<code> void vkCmdClearDepthStencilImage(
    VkCommandBuffer                             commandBuffer,
    VkImage                                     image,
    VkImageLayout                               imageLayout,
    const VkClearDepthStencilValue*             pDepthStencil,
    uint32_t                                    rangeCount,
    const VkImageSubresourceRange*              pRanges); </code>

</remarks>
      <seealso cref="T:VkClearDepthStencilValue" />
      <seealso cref="T:VkCommandBuffer" />
      <seealso cref="T:VkImage" />
      <seealso cref="T:VkImageLayout" />
      <seealso cref="T:VkImageSubresourceRange" />
    </member>
    <member name="T:IVkEventCreateInfo">
      <summary>Structure specifying parameters of a newly created event</summary>
      <remarks>


Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>sType</c> must be <c>VK_STRUCTURE_TYPE_EVENT_CREATE_INFO</c>
</description></item><item><description>
<c>pNext</c> must be <c>NULL</c>
</description></item><item><description>
<c>flags</c> must be <c>0</c>
</description></item></list>




The <c>VkEventCreateInfo</c> structure is defined as:


<code> typedef struct VkEventCreateInfo {
    VkStructureType       sType;
    const void*           pNext;
    VkEventCreateFlags    flags;
} VkEventCreateInfo; </code>

</remarks>
      <seealso cref="T:VkEventCreateFlags" />
      <seealso cref="T:VkStructureType" />
      <seealso cref="T:vkCreateEvent" />
    </member>
    <member name="T:VkEventCreateInfo32">
      <summary>See: <see cref="T:IVkEventCreateInfo" /></summary>
      <seealso cref="T:IVkEventCreateInfo" />
    </member>
    <member name="T:VkEventCreateInfo64">
      <summary>See: <see cref="T:IVkEventCreateInfo" /></summary>
      <seealso cref="T:IVkEventCreateInfo" />
    </member>
    <member name="T:VkSparseImageMemoryRequirements">
      <summary>Structure specifying sparse image memory requirements</summary>
      <remarks>

The <c>VkSparseImageMemoryRequirements</c> structure is defined as:


<code> typedef struct VkSparseImageMemoryRequirements {
    VkSparseImageFormatProperties    formatProperties;
    uint32_t                         imageMipTailFirstLod;
    VkDeviceSize                     imageMipTailSize;
    VkDeviceSize                     imageMipTailOffset;
    VkDeviceSize                     imageMipTailStride;
} VkSparseImageMemoryRequirements; </code>

</remarks>
      <seealso cref="T:VkSparseImageFormatProperties" />
      <seealso cref="T:vkGetImageSparseMemoryRequirements" />
    </member>
    <member name="T:vkGetSwapchainImagesKHR" />
    <member name="T:VkPipelineColorBlendAttachmentState">
      <summary>Structure specifying a pipeline color blend attachment state</summary>
      <remarks>


Valid Usage
<list type="bullet"><item><description>

If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-dualSrcBlend">dual source blending</a> feature
is not enabled, <c>srcColorBlendFactor</c> must not be
<c>VK_BLEND_FACTOR_SRC1_COLOR</c>,
<c>VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR</c>,
<c>VK_BLEND_FACTOR_SRC1_ALPHA</c>, or
<c>VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA</c>
</description></item><item><description>

If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-dualSrcBlend">dual source blending</a> feature
is not enabled, <c>dstColorBlendFactor</c> must not be
<c>VK_BLEND_FACTOR_SRC1_COLOR</c>,
<c>VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR</c>,
<c>VK_BLEND_FACTOR_SRC1_ALPHA</c>, or
<c>VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA</c>
</description></item><item><description>

If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-dualSrcBlend">dual source blending</a> feature
is not enabled, <c>srcAlphaBlendFactor</c> must not be
<c>VK_BLEND_FACTOR_SRC1_COLOR</c>,
<c>VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR</c>,
<c>VK_BLEND_FACTOR_SRC1_ALPHA</c>, or
<c>VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA</c>
</description></item><item><description>

If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-dualSrcBlend">dual source blending</a> feature
is not enabled, <c>dstAlphaBlendFactor</c> must not be
<c>VK_BLEND_FACTOR_SRC1_COLOR</c>,
<c>VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR</c>,
<c>VK_BLEND_FACTOR_SRC1_ALPHA</c>, or
<c>VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA</c>
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>srcColorBlendFactor</c> must be a valid <see cref="T:VkBlendFactor" /> value
</description></item><item><description>
<c>dstColorBlendFactor</c> must be a valid <see cref="T:VkBlendFactor" /> value
</description></item><item><description>
<c>colorBlendOp</c> must be a valid <see cref="T:VkBlendOp" /> value
</description></item><item><description>
<c>srcAlphaBlendFactor</c> must be a valid <see cref="T:VkBlendFactor" /> value
</description></item><item><description>
<c>dstAlphaBlendFactor</c> must be a valid <see cref="T:VkBlendFactor" /> value
</description></item><item><description>
<c>alphaBlendOp</c> must be a valid <see cref="T:VkBlendOp" /> value
</description></item><item><description>
<c>colorWriteMask</c> must be a valid combination of <see cref="T:VkColorComponentFlags" /> values
</description></item></list>




The <c>VkPipelineColorBlendAttachmentState</c> structure is defined as:


<code> typedef struct VkPipelineColorBlendAttachmentState {
    VkBool32                 blendEnable;
    VkBlendFactor            srcColorBlendFactor;
    VkBlendFactor            dstColorBlendFactor;
    VkBlendOp                colorBlendOp;
    VkBlendFactor            srcAlphaBlendFactor;
    VkBlendFactor            dstAlphaBlendFactor;
    VkBlendOp                alphaBlendOp;
    VkColorComponentFlags    colorWriteMask;
} VkPipelineColorBlendAttachmentState; </code>

</remarks>
      <seealso cref="T:VkBlendFactor" />
      <seealso cref="T:VkBlendOp" />
      <seealso cref="T:VkColorComponentFlags" />
      <seealso cref="T:IVkPipelineColorBlendStateCreateInfo" />
    </member>
    <member name="T:IVkPipelineColorBlendAdvancedStateCreateInfoEXT" />
    <member name="T:VkPipelineColorBlendAdvancedStateCreateInfoEXT32">
      <summary>See: <see cref="T:IVkPipelineColorBlendAdvancedStateCreateInfoEXT" /></summary>
      <seealso cref="T:IVkPipelineColorBlendAdvancedStateCreateInfoEXT" />
    </member>
    <member name="T:VkPipelineColorBlendAdvancedStateCreateInfoEXT64">
      <summary>See: <see cref="T:IVkPipelineColorBlendAdvancedStateCreateInfoEXT" /></summary>
      <seealso cref="T:IVkPipelineColorBlendAdvancedStateCreateInfoEXT" />
    </member>
    <member name="T:IVkSpecializationInfo">
      <summary>Structure specifying specialization info</summary>
      <remarks>

<c>pMapEntries</c> points to a structure of type
<see cref="T:IVkSpecializationMapEntry" />.



Valid Usage
<list type="bullet"><item><description>

The <c>offset</c> member of any given element of <c>pMapEntries</c> must
be less than <c>dataSize</c>
</description></item><item><description>

For any given element of <c>pMapEntries</c>, <c>size</c> must be less
than or equal to <c>dataSize</c> minus <c>offset</c>
</description></item><item><description>

If <c>mapEntryCount</c> is not <c>0</c>, <c>pMapEntries</c> must be a pointer
to an array of <c>mapEntryCount</c> valid <c>VkSpecializationMapEntry</c>
structures
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
 If <c>dataSize</c> is not <c>0</c>, <c>pData</c> must be a pointer to an array of <c>dataSize</c> bytes
</description></item></list>




The <c>VkSpecializationInfo</c> structure is defined as:


<code> typedef struct VkSpecializationInfo {
    uint32_t                           mapEntryCount;
    const VkSpecializationMapEntry*    pMapEntries;
    size_t                             dataSize;
    const void*                        pData;
} VkSpecializationInfo; </code>

</remarks>
      <seealso cref="T:IVkPipelineShaderStageCreateInfo" />
      <seealso cref="T:IVkSpecializationMapEntry" />
    </member>
    <member name="T:VkSpecializationInfo32">
      <summary>See: <see cref="T:IVkSpecializationInfo" /></summary>
      <seealso cref="T:IVkSpecializationInfo" />
    </member>
    <member name="T:VkSpecializationInfo64">
      <summary>See: <see cref="T:IVkSpecializationInfo" /></summary>
      <seealso cref="T:IVkSpecializationInfo" />
    </member>
    <member name="T:VkExtent3D">
      <summary>Structure specifying a three-dimensional extent</summary>
      <remarks>

A three-dimensional extent is defined by the structure:


<code> typedef struct VkExtent3D {
    uint32_t    width;
    uint32_t    height;
    uint32_t    depth;
} VkExtent3D; </code>

</remarks>
      <seealso cref="T:VkBufferImageCopy" />
      <seealso cref="T:VkImageCopy" />
      <seealso cref="T:IVkImageCreateInfo" />
      <seealso cref="T:VkImageFormatProperties" />
      <seealso cref="T:VkImageResolve" />
      <seealso cref="T:VkQueueFamilyProperties" />
      <seealso cref="T:VkSparseImageFormatProperties" />
      <seealso cref="T:VkSparseImageMemoryBind" />
    </member>
    <member name="T:VkSparseImageFormatProperties">
      <summary>Structure specifying sparse image format properties</summary>
      <remarks>

The <c>VkSparseImageFormatProperties</c> structure is defined as:


<code> typedef struct VkSparseImageFormatProperties {
    VkImageAspectFlags          aspectMask;
    VkExtent3D                  imageGranularity;
    VkSparseImageFormatFlags    flags;
} VkSparseImageFormatProperties; </code>

</remarks>
      <seealso cref="T:VkExtent3D" />
      <seealso cref="T:VkImageAspectFlags" />
      <seealso cref="T:VkSparseImageFormatFlags" />
      <seealso cref="T:VkSparseImageMemoryRequirements" />
      <seealso cref="T:vkGetPhysicalDeviceSparseImageFormatProperties" />
    </member>
    <member name="T:IVkImageMemoryBarrier">
      <summary>Structure specifying the parameters of an image memory barrier</summary>
      <remarks>

The first <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-dependencies-access-scopes">access scope</a> is
limited to access to memory through the specified image subresource range,
via access types in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-access-masks">source access mask</a>
specified by <c>srcAccessMask</c>.
If <c>srcAccessMask</c> includes <c>VK_ACCESS_HOST_WRITE_BIT</c>, memory
writes performed by that access type are also made visible, as that access
type is not performed through a resource.


The second <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-dependencies-access-scopes">access scope</a> is
limited to access to memory through the specified image subresource range,
via access types in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-access-masks">destination access
mask</a> specified by <c>dstAccessMask</c>.
If <c>dstAccessMask</c> includes <c>VK_ACCESS_HOST_WRITE_BIT</c> or
<c>VK_ACCESS_HOST_READ_BIT</c>, available memory writes are also made visible
to accesses of those types, as those access types are not performed through
a resource.


If <c>srcQueueFamilyIndex</c> is not equal to <c>dstQueueFamilyIndex</c>, and
<c>srcQueueFamilyIndex</c> is equal to the current queue family, then the
memory barrier defines a <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-queue-transfers-release">queue
family release operation</a> for the specified image subresource range, and
the second access scope includes no access, as if <c>dstAccessMask</c> was
<c>0</c>.


If <c>dstQueueFamilyIndex</c> is not equal to <c>srcQueueFamilyIndex</c>, and
<c>dstQueueFamilyIndex</c> is equal to the current queue family, then the
memory barrier defines a <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-queue-transfers-acquire">queue
family acquire operation</a> for the specified image subresource range, and
the first access scope includes no access, as if <c>srcAccessMask</c> was
<c>0</c>.


If <c>oldLayout</c> is not equal to <c>newLayout</c>, then the memory barrier
defines an <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-image-layout-transitions">image layout
transition</a> for the specified image subresource range.


Layout transitions that are performed via image memory barriers execute in
their entirety in <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-submission-order">submission order</a>,
relative to other image layout transitions submitted to the same queue,
including those performed by <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#renderpass">render passes</a>.
In effect there is an implicit execution dependency from each such layout
transition to all layout transitions previously submitted to the same queue.



Valid Usage
<list type="bullet"><item><description>
<c>oldLayout</c> must be <c>VK_IMAGE_LAYOUT_UNDEFINED</c> or the current
layout of the image subresources affected by the barrier
</description></item><item><description>
<c>newLayout</c> must not be <c>VK_IMAGE_LAYOUT_UNDEFINED</c> or
<c>VK_IMAGE_LAYOUT_PREINITIALIZED</c>
</description></item><item><description>

If <c>image</c> was created with a sharing mode of
<c>VK_SHARING_MODE_CONCURRENT</c>, <c>srcQueueFamilyIndex</c> and
<c>dstQueueFamilyIndex</c> must both be <c>VK_QUEUE_FAMILY_IGNORED</c>
</description></item><item><description>

If <c>image</c> was created with a sharing mode of
<c>VK_SHARING_MODE_EXCLUSIVE</c>, <c>srcQueueFamilyIndex</c> and
<c>dstQueueFamilyIndex</c> must either both be
<c>VK_QUEUE_FAMILY_IGNORED</c>, or both be a valid queue family (see
<a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#devsandqueues-queueprops">../../html/vkspec.html#devsandqueues-queueprops</a>).
</description></item><item><description>

If <c>image</c> was created with a sharing mode of
<c>VK_SHARING_MODE_EXCLUSIVE</c>, and <c>srcQueueFamilyIndex</c> and
<c>dstQueueFamilyIndex</c> are not <c>VK_QUEUE_FAMILY_IGNORED</c>, at
least one of them  must be the same as the family of the queue that will
execute this barrier
</description></item><item><description>
<c>subresourceRange</c> must be a valid image subresource range for the
image (see <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#resources-image-views">../../html/vkspec.html#resources-image-views</a>)
</description></item><item><description>

If <c>image</c> has a depth/stencil format with both depth and stencil
components, then <c>aspectMask</c> member of <c>subresourceRange</c> must
include both <c>VK_IMAGE_ASPECT_DEPTH_BIT</c> and
<c>VK_IMAGE_ASPECT_STENCIL_BIT</c>
</description></item><item><description>

If either <c>oldLayout</c> or <c>newLayout</c> is
<c>VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL</c> then <c>image</c> must
have been created with <c>VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT</c> set
</description></item><item><description>

If either <c>oldLayout</c> or <c>newLayout</c> is
<c>VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL</c> then <c>image</c> must have been created with
<c>VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT</c> set
</description></item><item><description>

If either <c>oldLayout</c> or <c>newLayout</c> is
<c>VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL</c> then <c>image</c> must have been created with
<c>VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT</c> set
</description></item><item><description>

If either <c>oldLayout</c> or <c>newLayout</c> is
<c>VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL</c> then <c>image</c> must
have been created with <c>VK_IMAGE_USAGE_SAMPLED_BIT</c> or
<c>VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT</c> set
</description></item><item><description>

If either <c>oldLayout</c> or <c>newLayout</c> is
<c>VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL</c> then <c>image</c> must have
been created with <c>VK_IMAGE_USAGE_TRANSFER_SRC_BIT</c> set
</description></item><item><description>

If either <c>oldLayout</c> or <c>newLayout</c> is
<c>VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL</c> then <c>image</c> must have
been created with <c>VK_IMAGE_USAGE_TRANSFER_DST_BIT</c> set
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>sType</c> must be <c>VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER</c>
</description></item><item><description>
<c>pNext</c> must be <c>NULL</c>
</description></item><item><description>
<c>srcAccessMask</c> must be a valid combination of <see cref="T:VkAccessFlags" /> values
</description></item><item><description>
<c>dstAccessMask</c> must be a valid combination of <see cref="T:VkAccessFlags" /> values
</description></item><item><description>
<c>oldLayout</c> must be a valid <see cref="T:VkImageLayout" /> value
</description></item><item><description>
<c>newLayout</c> must be a valid <see cref="T:VkImageLayout" /> value
</description></item><item><description>
<c>image</c> must be a valid <c>VkImage</c> handle
</description></item><item><description>
<c>subresourceRange</c> must be a valid <c>VkImageSubresourceRange</c> structure
</description></item></list>




The <c>VkImageMemoryBarrier</c> structure is defined as:


<code> typedef struct VkImageMemoryBarrier {
    VkStructureType            sType;
    const void*                pNext;
    VkAccessFlags              srcAccessMask;
    VkAccessFlags              dstAccessMask;
    VkImageLayout              oldLayout;
    VkImageLayout              newLayout;
    uint32_t                   srcQueueFamilyIndex;
    uint32_t                   dstQueueFamilyIndex;
    VkImage                    image;
    VkImageSubresourceRange    subresourceRange;
} VkImageMemoryBarrier; </code>

</remarks>
      <seealso cref="T:VkAccessFlags" />
      <seealso cref="T:VkImage" />
      <seealso cref="T:VkImageLayout" />
      <seealso cref="T:VkImageSubresourceRange" />
      <seealso cref="T:VkStructureType" />
      <seealso cref="T:vkCmdPipelineBarrier" />
      <seealso cref="T:vkCmdWaitEvents" />
    </member>
    <member name="T:VkImageMemoryBarrier32">
      <summary>See: <see cref="T:IVkImageMemoryBarrier" /></summary>
      <seealso cref="T:IVkImageMemoryBarrier" />
    </member>
    <member name="T:VkImageMemoryBarrier64">
      <summary>See: <see cref="T:IVkImageMemoryBarrier" /></summary>
      <seealso cref="T:IVkImageMemoryBarrier" />
    </member>
    <member name="T:IVkRenderPassMultiviewCreateInfoKHX" />
    <member name="T:VkRenderPassMultiviewCreateInfoKHX32">
      <summary>See: <see cref="T:IVkRenderPassMultiviewCreateInfoKHX" /></summary>
      <seealso cref="T:IVkRenderPassMultiviewCreateInfoKHX" />
    </member>
    <member name="T:VkRenderPassMultiviewCreateInfoKHX64">
      <summary>See: <see cref="T:IVkRenderPassMultiviewCreateInfoKHX" /></summary>
      <seealso cref="T:IVkRenderPassMultiviewCreateInfoKHX" />
    </member>
    <member name="T:IVkPhysicalDeviceGroupPropertiesKHX" />
    <member name="T:VkPhysicalDeviceGroupPropertiesKHX32">
      <summary>See: <see cref="T:IVkPhysicalDeviceGroupPropertiesKHX" /></summary>
      <seealso cref="T:IVkPhysicalDeviceGroupPropertiesKHX" />
    </member>
    <member name="T:VkPhysicalDeviceGroupPropertiesKHX64">
      <summary>See: <see cref="T:IVkPhysicalDeviceGroupPropertiesKHX" /></summary>
      <seealso cref="T:IVkPhysicalDeviceGroupPropertiesKHX" />
    </member>
    <member name="T:vkCreateSwapchainKHR" />
    <member name="T:IVkDescriptorUpdateTemplateEntryKHR" />
    <member name="T:VkDescriptorUpdateTemplateEntryKHR32">
      <summary>See: <see cref="T:IVkDescriptorUpdateTemplateEntryKHR" /></summary>
      <seealso cref="T:IVkDescriptorUpdateTemplateEntryKHR" />
    </member>
    <member name="T:VkDescriptorUpdateTemplateEntryKHR64">
      <summary>See: <see cref="T:IVkDescriptorUpdateTemplateEntryKHR" /></summary>
      <seealso cref="T:IVkDescriptorUpdateTemplateEntryKHR" />
    </member>
    <member name="T:IVkPipelineVertexInputStateCreateInfo">
      <summary>Structure specifying parameters of a newly created pipeline vertex input state</summary>
      <remarks>


Valid Usage
<list type="bullet"><item><description>
<c>vertexBindingDescriptionCount</c> must be less than or equal to
<c>VkPhysicalDeviceLimits</c>::<c>maxVertexInputBindings</c>
</description></item><item><description>
<c>vertexAttributeDescriptionCount</c> must be less than or equal to
<c>VkPhysicalDeviceLimits</c>::<c>maxVertexInputAttributes</c>
</description></item><item><description>

For every <c>binding</c> specified by any given element of
<c>pVertexAttributeDescriptions</c>, a
<c>VkVertexInputBindingDescription</c> must exist in
<c>pVertexBindingDescriptions</c> with the same value of <c>binding</c>
</description></item><item><description>

All elements of <c>pVertexBindingDescriptions</c> must  describe distinct
binding numbers
</description></item><item><description>

All elements of <c>pVertexAttributeDescriptions</c> must  describe
distinct attribute locations
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>sType</c> must be <c>VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO</c>
</description></item><item><description>
<c>pNext</c> must be <c>NULL</c>
</description></item><item><description>
<c>flags</c> must be <c>0</c>
</description></item><item><description>
 If <c>vertexBindingDescriptionCount</c> is not <c>0</c>, <c>pVertexBindingDescriptions</c> must be a pointer to an array of <c>vertexBindingDescriptionCount</c> valid <c>VkVertexInputBindingDescription</c> structures
</description></item><item><description>
 If <c>vertexAttributeDescriptionCount</c> is not <c>0</c>, <c>pVertexAttributeDescriptions</c> must be a pointer to an array of <c>vertexAttributeDescriptionCount</c> valid <c>VkVertexInputAttributeDescription</c> structures
</description></item></list>




The <c>VkPipelineVertexInputStateCreateInfo</c> structure is defined as:


<code> typedef struct VkPipelineVertexInputStateCreateInfo {
    VkStructureType                             sType;
    const void*                                 pNext;
    VkPipelineVertexInputStateCreateFlags       flags;
    uint32_t                                    vertexBindingDescriptionCount;
    const VkVertexInputBindingDescription*      pVertexBindingDescriptions;
    uint32_t                                    vertexAttributeDescriptionCount;
    const VkVertexInputAttributeDescription*    pVertexAttributeDescriptions;
} VkPipelineVertexInputStateCreateInfo; </code>

</remarks>
      <seealso cref="T:IVkGraphicsPipelineCreateInfo" />
      <seealso cref="T:VkPipelineVertexInputStateCreateFlags" />
      <seealso cref="T:VkStructureType" />
      <seealso cref="T:VkVertexInputAttributeDescription" />
      <seealso cref="T:VkVertexInputBindingDescription" />
    </member>
    <member name="T:VkPipelineVertexInputStateCreateInfo32">
      <summary>See: <see cref="T:IVkPipelineVertexInputStateCreateInfo" /></summary>
      <seealso cref="T:IVkPipelineVertexInputStateCreateInfo" />
    </member>
    <member name="T:VkPipelineVertexInputStateCreateInfo64">
      <summary>See: <see cref="T:IVkPipelineVertexInputStateCreateInfo" /></summary>
      <seealso cref="T:IVkPipelineVertexInputStateCreateInfo" />
    </member>
    <member name="T:VkOffset3D">
      <summary>Structure specifying a three-dimensional offset</summary>
      <remarks>

A three-dimensional offset is defined by the structure:


<code> typedef struct VkOffset3D {
    int32_t    x;
    int32_t    y;
    int32_t    z;
} VkOffset3D; </code>

</remarks>
      <seealso cref="T:VkBufferImageCopy" />
      <seealso cref="T:VkImageBlit" />
      <seealso cref="T:VkImageCopy" />
      <seealso cref="T:VkImageResolve" />
      <seealso cref="T:VkSparseImageMemoryBind" />
    </member>
    <member name="T:IVkDisplayPowerInfoEXT" />
    <member name="T:VkDisplayPowerInfoEXT32">
      <summary>See: <see cref="T:IVkDisplayPowerInfoEXT" /></summary>
      <seealso cref="T:IVkDisplayPowerInfoEXT" />
    </member>
    <member name="T:VkDisplayPowerInfoEXT64">
      <summary>See: <see cref="T:IVkDisplayPowerInfoEXT" /></summary>
      <seealso cref="T:IVkDisplayPowerInfoEXT" />
    </member>
    <member name="T:IVkAcquireNextImageInfoKHX" />
    <member name="T:VkAcquireNextImageInfoKHX32">
      <summary>See: <see cref="T:IVkAcquireNextImageInfoKHX" /></summary>
      <seealso cref="T:IVkAcquireNextImageInfoKHX" />
    </member>
    <member name="T:VkAcquireNextImageInfoKHX64">
      <summary>See: <see cref="T:IVkAcquireNextImageInfoKHX" /></summary>
      <seealso cref="T:IVkAcquireNextImageInfoKHX" />
    </member>
    <member name="T:VkSurfaceFormatKHR" />
    <member name="T:VkDisplayPlanePropertiesKHR" />
    <member name="T:IVkPipelineInputAssemblyStateCreateInfo">
      <summary>Structure specifying parameters of a newly created pipeline input assembly state</summary>
      <remarks>

Restarting the assembly of primitives discards the most recent index values
if those elements formed an incomplete primitive, and restarts the primitive
assembly using the subsequent indices, but only assembling the immediately
following element through the end of the originally specified elements.
The primitive restart index value comparison is performed before adding the
<c>vertexOffset</c> value to the index value.



Valid Usage
<list type="bullet"><item><description>

If <c>topology</c> is <c>VK_PRIMITIVE_TOPOLOGY_POINT_LIST</c>,
<c>VK_PRIMITIVE_TOPOLOGY_LINE_LIST</c>,
<c>VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST</c>,
<c>VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY</c>,
<c>VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY</c> or
<c>VK_PRIMITIVE_TOPOLOGY_PATCH_LIST</c>, <c>primitiveRestartEnable</c> must be <c>VK_FALSE</c>
</description></item><item><description>

If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-geometryShader">geometry shaders</a> feature is
not enabled, <c>topology</c> must not be any of
<c>VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY</c>,
<c>VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY</c>,
<c>VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY</c> or
<c>VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY</c>
</description></item><item><description>

If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-tessellationShader">tessellation shaders</a>
feature is not enabled, <c>topology</c> must not be
<c>VK_PRIMITIVE_TOPOLOGY_PATCH_LIST</c>
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>sType</c> must be <c>VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO</c>
</description></item><item><description>
<c>pNext</c> must be <c>NULL</c>
</description></item><item><description>
<c>flags</c> must be <c>0</c>
</description></item><item><description>
<c>topology</c> must be a valid <see cref="T:VkPrimitiveTopology" /> value
</description></item></list>




Each draw is made up of zero or more vertices and zero or more instances,
which are processed by the device and result in the assembly of primitives.
Primitives are assembled according to the <c>pInputAssemblyState</c> member
of the <c>VkGraphicsPipelineCreateInfo</c> structure, which is of type
<c>VkPipelineInputAssemblyStateCreateInfo</c>:


<code> typedef struct VkPipelineInputAssemblyStateCreateInfo {
    VkStructureType                            sType;
    const void*                                pNext;
    VkPipelineInputAssemblyStateCreateFlags    flags;
    VkPrimitiveTopology                        topology;
    VkBool32                                   primitiveRestartEnable;
} VkPipelineInputAssemblyStateCreateInfo; </code>

</remarks>
      <seealso cref="T:IVkGraphicsPipelineCreateInfo" />
      <seealso cref="T:VkPipelineInputAssemblyStateCreateFlags" />
      <seealso cref="T:VkPrimitiveTopology" />
      <seealso cref="T:VkStructureType" />
    </member>
    <member name="T:VkPipelineInputAssemblyStateCreateInfo32">
      <summary>See: <see cref="T:IVkPipelineInputAssemblyStateCreateInfo" /></summary>
      <seealso cref="T:IVkPipelineInputAssemblyStateCreateInfo" />
    </member>
    <member name="T:VkPipelineInputAssemblyStateCreateInfo64">
      <summary>See: <see cref="T:IVkPipelineInputAssemblyStateCreateInfo" /></summary>
      <seealso cref="T:IVkPipelineInputAssemblyStateCreateInfo" />
    </member>
    <member name="T:IVkSamplerCreateInfo">
      <summary>Structure specifying parameters of a newly created sampler</summary>
      <remarks>
<list type="table"><tr><td><i title="Note"></i></td><td>
Mapping of OpenGL to Vulkan filter modes

<c>magFilter</c> values of <c>VK_FILTER_NEAREST</c> and <c>VK_FILTER_LINEAR</c>
directly correspond to <c>GL_NEAREST</c> and <c>GL_LINEAR</c> magnification
filters.
<c>minFilter</c> and <c>mipmapMode</c> combine to correspond to the similarly
named OpenGL minification filter of <c>GL_minFilter_MIPMAP_mipmapMode</c>
(e.g. <c>minFilter</c> of <c>VK_FILTER_LINEAR</c> and <c>mipmapMode</c> of
<c>VK_SAMPLER_MIPMAP_MODE_NEAREST</c> correspond to
<c>GL_LINEAR_MIPMAP_NEAREST</c>).


There are no Vulkan filter modes that directly correspond to OpenGL
minification filters of <c>GL_LINEAR</c> or <c>GL_NEAREST</c>, but they  can be
emulated using <c>VK_SAMPLER_MIPMAP_MODE_NEAREST</c>, <c>minLod</c> = 0, and
<c>maxLod</c> = 0.25, and using <c>minFilter</c> = <c>VK_FILTER_LINEAR</c> or
<c>minFilter</c> = <c>VK_FILTER_NEAREST</c>, respectively.


Note that using a <c>maxLod</c> of zero would cause
<a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#textures-texel-filtering">magnification</a> to always be performed, and the
<c>magFilter</c> to always be used.
This is valid, just not an exact match for OpenGL behavior.
Clamping the maximum LOD to 0.25 allows the  λ value to be
non-zero and minification to be performed, while still always rounding down
to the base level.
If the <c>minFilter</c> and <c>magFilter</c> are equal, then using a
<c>maxLod</c> of zero also works.

</td></tr></list>

The maximum number of sampler objects which  can be simultaneously created
on a device is implementation-dependent and specified by the
<a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-limits-maxSamplerAllocationCount"><c>maxSamplerAllocationCount</c></a>
member of the <see cref="T:IVkPhysicalDeviceLimits" /> structure.
If <c>maxSamplerAllocationCount</c> is exceeded, <c>vkCreateSampler</c> will
return <c>VK_ERROR_TOO_MANY_OBJECTS</c>.


Since <see cref="T:VkSampler" /> is a non-dispatchable handle type, implementations
 may return the same handle for sampler state vectors that are identical.
In such cases, all such objects would only count once against the
<c>maxSamplerAllocationCount</c> limit.



Valid Usage
<list type="bullet"><item><description>

The absolute value of <c>mipLodBias</c> must be less than or equal to
<c>VkPhysicalDeviceLimits</c>::<c>maxSamplerLodBias</c>
</description></item><item><description>

If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-samplerAnisotropy">anisotropic sampling</a>
feature is not enabled, <c>anisotropyEnable</c> must be <c>VK_FALSE</c>
</description></item><item><description>

If <c>anisotropyEnable</c> is <c>VK_TRUE</c>, <c>maxAnisotropy</c> must be
between <c>1.0</c> and
<c>VkPhysicalDeviceLimits</c>::<c>maxSamplerAnisotropy</c>, inclusive
</description></item><item><description>

If <c>unnormalizedCoordinates</c> is <c>VK_TRUE</c>, <c>minFilter</c> and
<c>magFilter</c> must  be equal
</description></item><item><description>

If <c>unnormalizedCoordinates</c> is <c>VK_TRUE</c>, <c>mipmapMode</c> must be <c>VK_SAMPLER_MIPMAP_MODE_NEAREST</c>
</description></item><item><description>

If <c>unnormalizedCoordinates</c> is <c>VK_TRUE</c>, <c>minLod</c> and
<c>maxLod</c> must  be zero
</description></item><item><description>

If <c>unnormalizedCoordinates</c> is <c>VK_TRUE</c>, <c>addressModeU</c>
and <c>addressModeV</c> must each be either
<c>VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE</c> or
<c>VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER</c>
</description></item><item><description>

If <c>unnormalizedCoordinates</c> is <c>VK_TRUE</c>,
<c>anisotropyEnable</c> must be <c>VK_FALSE</c>
</description></item><item><description>

If <c>unnormalizedCoordinates</c> is <c>VK_TRUE</c>, <c>compareEnable</c> must be <c>VK_FALSE</c>
</description></item><item><description>

If any of <c>addressModeU</c>, <c>addressModeV</c> or <c>addressModeW</c>
are <c>VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER</c>, <c>borderColor</c> must be a valid <see cref="T:VkBorderColor" /> value
</description></item><item><description>

If the VK_KHR_sampler_mirror_clamp_to_edge extension is not enabled,
<c>addressModeU</c>, <c>addressModeV</c> and <c>addressModeW</c> must not
be <c>VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE</c>
</description></item><item><description>

If <c>compareEnable</c> is <c>VK_TRUE</c>, <c>compareOp</c> must be a
valid <see cref="T:VkCompareOp" /> value
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>sType</c> must be <c>VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO</c>
</description></item><item><description>
<c>pNext</c> must be <c>NULL</c>
</description></item><item><description>
<c>flags</c> must be <c>0</c>
</description></item><item><description>
<c>magFilter</c> must be a valid <see cref="T:VkFilter" /> value
</description></item><item><description>
<c>minFilter</c> must be a valid <see cref="T:VkFilter" /> value
</description></item><item><description>
<c>mipmapMode</c> must be a valid <see cref="T:VkSamplerMipmapMode" /> value
</description></item><item><description>
<c>addressModeU</c> must be a valid <see cref="T:VkSamplerAddressMode" /> value
</description></item><item><description>
<c>addressModeV</c> must be a valid <see cref="T:VkSamplerAddressMode" /> value
</description></item><item><description>
<c>addressModeW</c> must be a valid <see cref="T:VkSamplerAddressMode" /> value
</description></item></list>




The <c>VkSamplerCreateInfo</c> structure is defined as:


<code> typedef struct VkSamplerCreateInfo {
    VkStructureType         sType;
    const void*             pNext;
    VkSamplerCreateFlags    flags;
    VkFilter                magFilter;
    VkFilter                minFilter;
    VkSamplerMipmapMode     mipmapMode;
    VkSamplerAddressMode    addressModeU;
    VkSamplerAddressMode    addressModeV;
    VkSamplerAddressMode    addressModeW;
    float                   mipLodBias;
    VkBool32                anisotropyEnable;
    float                   maxAnisotropy;
    VkBool32                compareEnable;
    VkCompareOp             compareOp;
    float                   minLod;
    float                   maxLod;
    VkBorderColor           borderColor;
    VkBool32                unnormalizedCoordinates;
} VkSamplerCreateInfo; </code>

</remarks>
      <seealso cref="T:VkBorderColor" />
      <seealso cref="T:VkCompareOp" />
      <seealso cref="T:VkFilter" />
      <seealso cref="T:VkSamplerAddressMode" />
      <seealso cref="T:VkSamplerCreateFlags" />
      <seealso cref="T:VkSamplerMipmapMode" />
      <seealso cref="T:VkStructureType" />
      <seealso cref="T:vkCreateSampler" />
    </member>
    <member name="T:VkSamplerCreateInfo32">
      <summary>See: <see cref="T:IVkSamplerCreateInfo" /></summary>
      <seealso cref="T:IVkSamplerCreateInfo" />
    </member>
    <member name="T:VkSamplerCreateInfo64">
      <summary>See: <see cref="T:IVkSamplerCreateInfo" /></summary>
      <seealso cref="T:IVkSamplerCreateInfo" />
    </member>
    <member name="T:IVkImageFormatProperties2KHR" />
    <member name="T:VkImageFormatProperties2KHR32">
      <summary>See: <see cref="T:IVkImageFormatProperties2KHR" /></summary>
      <seealso cref="T:IVkImageFormatProperties2KHR" />
    </member>
    <member name="T:VkImageFormatProperties2KHR64">
      <summary>See: <see cref="T:IVkImageFormatProperties2KHR" /></summary>
      <seealso cref="T:IVkImageFormatProperties2KHR" />
    </member>
    <member name="T:IVkExternalMemoryBufferCreateInfoKHX" />
    <member name="T:VkExternalMemoryBufferCreateInfoKHX32">
      <summary>See: <see cref="T:IVkExternalMemoryBufferCreateInfoKHX" /></summary>
      <seealso cref="T:IVkExternalMemoryBufferCreateInfoKHX" />
    </member>
    <member name="T:VkExternalMemoryBufferCreateInfoKHX64">
      <summary>See: <see cref="T:IVkExternalMemoryBufferCreateInfoKHX" /></summary>
      <seealso cref="T:IVkExternalMemoryBufferCreateInfoKHX" />
    </member>
    <member name="T:IVkMemoryBarrier">
      <summary>Structure specifying a global memory barrier</summary>
      <remarks>

The first <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-dependencies-access-scopes">access scope</a> is
limited to access types in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-access-masks">source access
mask</a> specified by <c>srcAccessMask</c>.


The second <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-dependencies-access-scopes">access scope</a> is
limited to access types in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-access-masks">destination
access mask</a> specified by <c>dstAccessMask</c>.



Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>sType</c> must be <c>VK_STRUCTURE_TYPE_MEMORY_BARRIER</c>
</description></item><item><description>
<c>pNext</c> must be <c>NULL</c>
</description></item><item><description>
<c>srcAccessMask</c> must be a valid combination of <see cref="T:VkAccessFlags" /> values
</description></item><item><description>
<c>dstAccessMask</c> must be a valid combination of <see cref="T:VkAccessFlags" /> values
</description></item></list>




The <c>VkMemoryBarrier</c> structure is defined as:


<code> typedef struct VkMemoryBarrier {
    VkStructureType    sType;
    const void*        pNext;
    VkAccessFlags      srcAccessMask;
    VkAccessFlags      dstAccessMask;
} VkMemoryBarrier; </code>

</remarks>
      <seealso cref="T:VkAccessFlags" />
      <seealso cref="T:VkStructureType" />
      <seealso cref="T:vkCmdPipelineBarrier" />
      <seealso cref="T:vkCmdWaitEvents" />
    </member>
    <member name="T:VkMemoryBarrier32">
      <summary>See: <see cref="T:IVkMemoryBarrier" /></summary>
      <seealso cref="T:IVkMemoryBarrier" />
    </member>
    <member name="T:VkMemoryBarrier64">
      <summary>See: <see cref="T:IVkMemoryBarrier" /></summary>
      <seealso cref="T:IVkMemoryBarrier" />
    </member>
    <member name="T:PFN_vkReallocationFunction">
      <summary>Application-defined memory reallocation function</summary>
      <remarks>

<c>pfnReallocation</c> must return an allocation with enough space for
<c>size</c> bytes, and the contents of the original allocation from bytes
zero to  min(original size, new size) - 1 must be preserved in the
returned allocation.
If <c>size</c> is larger than the old size, the contents of the additional
space are undefined.
If satisfying these requirements involves creating a new allocation, then
the old allocation  should be freed.


If <c>pOriginal</c> is <c>NULL</c>, then <c>pfnReallocation</c> must behave
equivalently to a call to <see cref="T:PFN_vkAllocationFunction" /> with the same
parameter values (without <c>pOriginal</c>).


If <c>size</c> is zero, then <c>pfnReallocation</c> must behave equivalently
to a call to <see cref="T:PFN_vkFreeFunction" /> with the same <c>pUserData</c>
parameter value, and <c>pMemory</c> equal to <c>pOriginal</c>.


If <c>pOriginal</c> is non-<c>NULL</c>, the implementation  must ensure that
<c>alignment</c> is equal to the <c>alignment</c> used to originally allocate
<c>pOriginal</c>.


If this function fails and <c>pOriginal</c> is non-<c>NULL</c> the application
 must not free the old allocation.


<c>pfnReallocation</c> must follow the same
<a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkAllocationFunction_return_rules">rules for return values as
<c>PFN_vkAllocationFunction</c></a>.



The type of <c>pfnReallocation</c> is:


<code> typedef void* (VKAPI_PTR *PFN_vkReallocationFunction)(
    void*                                       pUserData,
    void*                                       pOriginal,
    size_t                                      size,
    size_t                                      alignment,
    VkSystemAllocationScope                     allocationScope); </code>

</remarks>
      <seealso cref="T:IVkAllocationCallbacks" />
    </member>
    <member name="T:IVkBufferMemoryBarrier">
      <summary>Structure specifying a buffer memory barrier</summary>
      <remarks>

The first <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-dependencies-access-scopes">access scope</a> is
limited to access to memory through the specified buffer range, via access
types in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-access-masks">source access mask</a> specified
by <c>srcAccessMask</c>.
If <c>srcAccessMask</c> includes <c>VK_ACCESS_HOST_WRITE_BIT</c>, memory
writes performed by that access type are also made visible, as that access
type is not performed through a resource.


The second <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-dependencies-access-scopes">access scope</a> is
limited to access to memory through the specified buffer range, via access
types in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-access-masks">destination access mask</a>.
specified by <c>dstAccessMask</c>.
If <c>dstAccessMask</c> includes <c>VK_ACCESS_HOST_WRITE_BIT</c> or
<c>VK_ACCESS_HOST_READ_BIT</c>, available memory writes are also made visible
to accesses of those types, as those access types are not performed through
a resource.


If <c>srcQueueFamilyIndex</c> is not equal to <c>dstQueueFamilyIndex</c>, and
<c>srcQueueFamilyIndex</c> is equal to the current queue family, then the
memory barrier defines a <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-queue-transfers-release">queue
family release operation</a> for the specified buffer range, and the second
access scope includes no access, as if <c>dstAccessMask</c> was <c>0</c>.


If <c>dstQueueFamilyIndex</c> is not equal to <c>srcQueueFamilyIndex</c>, and
<c>dstQueueFamilyIndex</c> is equal to the current queue family, then the
memory barrier defines a <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-queue-transfers-acquire">queue
family acquire operation</a> for the specified buffer range, and the first
access scope includes no access, as if <c>srcAccessMask</c> was <c>0</c>.



Valid Usage
<list type="bullet"><item><description>
<c>offset</c> must be less than the size of <c>buffer</c>
</description></item><item><description>

If <c>size</c> is not equal to <c>VK_WHOLE_SIZE</c>, <c>size</c> must be
greater than <c>0</c>
</description></item><item><description>

If <c>size</c> is not equal to <c>VK_WHOLE_SIZE</c>, <c>size</c> must be
less than or equal to than the size of <c>buffer</c> minus <c>offset</c>
</description></item><item><description>

If <c>buffer</c> was created with a sharing mode of
<c>VK_SHARING_MODE_CONCURRENT</c>, <c>srcQueueFamilyIndex</c> and
<c>dstQueueFamilyIndex</c> must both be <c>VK_QUEUE_FAMILY_IGNORED</c>
</description></item><item><description>

If <c>buffer</c> was created with a sharing mode of
<c>VK_SHARING_MODE_EXCLUSIVE</c>, <c>srcQueueFamilyIndex</c> and
<c>dstQueueFamilyIndex</c> must either both be
<c>VK_QUEUE_FAMILY_IGNORED</c>, or both be a valid queue family (see
<a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#devsandqueues-queueprops">../../html/vkspec.html#devsandqueues-queueprops</a>)
</description></item><item><description>

If <c>buffer</c> was created with a sharing mode of
<c>VK_SHARING_MODE_EXCLUSIVE</c>, and <c>srcQueueFamilyIndex</c> and
<c>dstQueueFamilyIndex</c> are not <c>VK_QUEUE_FAMILY_IGNORED</c>, at
least one of them  must be the same as the family of the queue that will
execute this barrier
</description></item></list>




Valid Usage (Implicit)
<list type="bullet"><item><description>
<c>sType</c> must be <c>VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER</c>
</description></item><item><description>
<c>pNext</c> must be <c>NULL</c>
</description></item><item><description>
<c>srcAccessMask</c> must be a valid combination of <see cref="T:VkAccessFlags" /> values
</description></item><item><description>
<c>dstAccessMask</c> must be a valid combination of <see cref="T:VkAccessFlags" /> values
</description></item><item><description>
<c>buffer</c> must be a valid <c>VkBuffer</c> handle
</description></item></list>




The <c>VkBufferMemoryBarrier</c> structure is defined as:


<code> typedef struct VkBufferMemoryBarrier {
    VkStructureType    sType;
    const void*        pNext;
    VkAccessFlags      srcAccessMask;
    VkAccessFlags      dstAccessMask;
    uint32_t           srcQueueFamilyIndex;
    uint32_t           dstQueueFamilyIndex;
    VkBuffer           buffer;
    VkDeviceSize       offset;
    VkDeviceSize       size;
} VkBufferMemoryBarrier; </code>

</remarks>
      <seealso cref="T:VkAccessFlags" />
      <seealso cref="T:VkBuffer" />
      <seealso cref="T:VkStructureType" />
      <seealso cref="T:vkCmdPipelineBarrier" />
      <seealso cref="T:vkCmdWaitEvents" />
    </member>
    <member name="T:VkBufferMemoryBarrier32">
      <summary>See: <see cref="T:IVkBufferMemoryBarrier" /></summary>
      <seealso cref="T:IVkBufferMemoryBarrier" />
    </member>
    <member name="T:VkBufferMemoryBarrier64">
      <summary>See: <see cref="T:IVkBufferMemoryBarrier" /></summary>
      <seealso cref="T:IVkBufferMemoryBarrier" />
    </member>
  </members>
</doc>